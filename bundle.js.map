{"version":3,"mappings":"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","names":["PieceColor","PieceType"],"ignoreList":[],"sources":["../src/utils/pieceFactory.ts","../src/piece.ts","../src/utils/utils.ts","../src/board.ts","../src/game.ts","../src/canvas-renderer.ts","../src/timer.ts","../src/index.ts","../src/pieces/pawn.ts","../src/pieces/rook.ts","../src/pieces/knight.ts","../src/pieces/bishop.ts","../src/pieces/queen.ts","../src/pieces/king.ts"],"sourcesContent":["import { PieceColor, PieceType } from '../piece';\n\nexport async function createPiece(type: PieceType, color: PieceColor) {\n  switch (type) {\n    case PieceType.PAWN:\n      const { Pawn } = await import('../pieces/pawn');\n      return new Pawn(color);\n    case PieceType.ROOK:\n      const { Rook } = await import('../pieces/rook');\n      return new Rook(color);\n    case PieceType.KNIGHT:\n      const { Knight } = await import('../pieces/knight');\n      return new Knight(color);\n    case PieceType.BISHOP:\n      const { Bishop } = await import('../pieces/bishop');\n      return new Bishop(color);\n    case PieceType.QUEEN:\n      const { Queen } = await import('../pieces/queen');\n      return new Queen(color);\n    case PieceType.KING:\n      const { King } = await import('../pieces/king');\n      return new King(color);\n    default:\n      throw new Error(`Type de pièce inconnu : ${type}`);\n  }\n}\n","// src/piece.ts\nimport { createPiece } from './utils/pieceFactory';\nimport { King } from './pieces/king';\n\nexport enum PieceColor {\n  WHITE = 'white',\n  BLACK = 'black',\n}\n\nexport enum PieceType {\n  PAWN = 'pawn',\n  ROOK = 'rook',\n  KNIGHT = 'knight',\n  BISHOP = 'bishop',\n  QUEEN = 'queen',\n  KING = 'king',\n}\n\nexport interface BoardInterface {\n  getPiece(x: number, y: number): Piece | null;\n\n  updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void;\n\n  isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean;\n\n  promotePawn(x: number, y: number, pieceType: string): void;\n\n  isSquareUnderAttack(x: number, y: number, color: string): boolean;\n\n  isKing(x: number, y: number): boolean;\n\n  isAdjacentToAnotherKing(x: number, y: number, color: PieceColor): boolean;\n}\n\nexport abstract class Piece {\n  public hasMoved: boolean = false;\n\n  protected constructor(\n    public color: PieceColor,\n    public type: PieceType,\n  ) {}\n\n  abstract isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean;\n\n  public isPathClear(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const dx = Math.sign(toX - fromX);\n    const dy = Math.sign(toY - fromY);\n\n    let x = fromX + dx;\n    let y = fromY + dy;\n    while (x !== toX || y !== toY) {\n      if (board.getPiece(x, y) !== null) return false;\n      x += dx;\n      y += dy;\n    }\n    return true;\n  }\n\n  static isKing(piece: Piece): piece is King {\n    return piece.type === PieceType.KING;\n  }\n\n  public canCapture(toX: number, toY: number, board: BoardInterface): boolean {\n    const targetPiece = board.getPiece(toX, toY);\n    return !targetPiece || targetPiece.color !== this.color;\n  }\n\n  // Sérialisation des données de la pièce\n  public toData(): any {\n    return {\n      color: this.color,\n      type: this.type,\n    };\n  }\n\n  static async fromData(data: any): Promise<Piece> {\n    return await createPiece(data.type, data.color);\n  }\n\n  // Méthode clone pour créer une nouvelle instance identique\n  public async clone(): Promise<Piece> {\n    return await createPiece(this.type, this.color);\n  }\n}\n","// src/utils/utils.ts\n\nimport { PieceColor, PieceType } from '../piece';\n\nexport let capturedWhite: string[] = [];\nexport let capturedBlack: string[] = [];\n\nexport function showMessage(message: string) {\n  const gameMessageElement = document.getElementById(\n    'gameMessage',\n  ) as HTMLDivElement;\n  gameMessageElement.textContent = message;\n  gameMessageElement.style.display = 'block'; // Afficher le message\n}\n\nexport function getPieceSymbol(piece: PieceType, color: PieceColor): string {\n  switch (piece) {\n    case PieceType.PAWN:\n      return color === PieceColor.WHITE ? '♙' : '♟';\n    case PieceType.ROOK:\n      return color === PieceColor.WHITE ? '♖' : '♜';\n    case PieceType.KNIGHT:\n      return color === PieceColor.WHITE ? '♘' : '♞';\n    case PieceType.BISHOP:\n      return color === PieceColor.WHITE ? '♗' : '♝';\n    case PieceType.QUEEN:\n      return color === PieceColor.WHITE ? '♕' : '♛';\n    case PieceType.KING:\n      return color === PieceColor.WHITE ? '♔' : '♚';\n    default:\n      return '';\n  }\n}\n\nexport function updateCapturedPieces(piece: PieceType, color: PieceColor) {\n  const pieceSymbol = getPieceSymbol(piece, color);\n\n  if (color === PieceColor.WHITE) {\n    capturedWhite.push(pieceSymbol);\n  } else {\n    capturedBlack.push(pieceSymbol);\n  }\n\n  updateCapturedPiecesDOM();\n}\n\nexport function updateCapturedPiecesDOM() {\n  const capturedWhiteElement = document.getElementById(\n    'capturedWhite',\n  ) as HTMLDivElement;\n  const capturedBlackElement = document.getElementById(\n    'capturedBlack',\n  ) as HTMLDivElement;\n\n  if (capturedWhiteElement) {\n    capturedWhiteElement.textContent = capturedWhite.join(' ');\n  }\n  if (capturedBlackElement) {\n    capturedBlackElement.textContent = capturedBlack.join(' ');\n  }\n}\n","// src/board.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from './piece';\nimport { King } from './pieces/king';\nimport { updateCapturedPieces } from './utils/utils';\nimport { createPiece } from './utils/pieceFactory';\n\ntype BoardSquare = Piece | null;\n\nexport class Board implements BoardInterface {\n  private grid: (Piece | null)[][];\n  private enPassantTarget: { x: number; y: number } | null = null;\n  private halfMoveCount: number = 0; // Compteur pour la règle des 50 coups\n\n  constructor() {\n    this.grid = [];\n  }\n\n  public async init(): Promise<void> {\n    this.grid = await this.initializeBoard();\n  }\n\n  private async initializeBoard(): Promise<(Piece | null)[][]> {\n    const board: (Piece | null)[][] = Array(8)\n      .fill(null)\n      .map(() => Array(8).fill(null));\n\n    // Ajouter les pièces blanches\n    board[0] = [\n      await createPiece(PieceType.ROOK, PieceColor.WHITE),\n      await createPiece(PieceType.KNIGHT, PieceColor.WHITE),\n      await createPiece(PieceType.BISHOP, PieceColor.WHITE),\n      await createPiece(PieceType.QUEEN, PieceColor.WHITE),\n      await createPiece(PieceType.KING, PieceColor.WHITE),\n      await createPiece(PieceType.BISHOP, PieceColor.WHITE),\n      await createPiece(PieceType.KNIGHT, PieceColor.WHITE),\n      await createPiece(PieceType.ROOK, PieceColor.WHITE),\n    ];\n    board[1] = await Promise.all(\n      Array(8)\n        .fill(null)\n        .map(() => createPiece(PieceType.PAWN, PieceColor.WHITE)),\n    );\n\n    // Ajouter les pièces noires\n    board[7] = [\n      await createPiece(PieceType.ROOK, PieceColor.BLACK),\n      await createPiece(PieceType.KNIGHT, PieceColor.BLACK),\n      await createPiece(PieceType.BISHOP, PieceColor.BLACK),\n      await createPiece(PieceType.QUEEN, PieceColor.BLACK),\n      await createPiece(PieceType.KING, PieceColor.BLACK),\n      await createPiece(PieceType.BISHOP, PieceColor.BLACK),\n      await createPiece(PieceType.KNIGHT, PieceColor.BLACK),\n      await createPiece(PieceType.ROOK, PieceColor.BLACK),\n    ];\n    board[6] = await Promise.all(\n      Array(8)\n        .fill(null)\n        .map(() => createPiece(PieceType.PAWN, PieceColor.BLACK)),\n    );\n\n    return board;\n  }\n\n  // Méthode générale pour vérifier les limites\n  public isWithinBounds(x: number, y: number): boolean {\n    return x >= 0 && x < 8 && y >= 0 && y < 8;\n  }\n\n  public getPiece(x: number, y: number): BoardSquare {\n    return this.grid[y][x];\n  }\n\n  public getValidMoves(x: number, y: number): { x: number; y: number }[] {\n    let piece = null;\n    if (this.isWithinBounds(x, y)) piece = this.getPiece(x, y);\n    if (!piece) return [];\n\n    const validMoves: { x: number; y: number }[] = [];\n\n    for (let toY = 0; toY < 8; toY++) {\n      for (let toX = 0; toX < 8; toX++) {\n        if (piece.isValidMove(x, y, toX, toY, this)) {\n          validMoves.push({ x: toX, y: toY });\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  public getKingInCheck(): { x: number; y: number } | null {\n    if (this.isKingInCheck(PieceColor.WHITE)) {\n      return this.findKing(PieceColor.WHITE);\n    } else if (this.isKingInCheck(PieceColor.BLACK)) {\n      return this.findKing(PieceColor.BLACK);\n    }\n    return null;\n  }\n\n  public movePiece(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (\n      !this.isWithinBounds(fromX, fromY) ||\n      !this.isWithinBounds(toX, toY) ||\n      ['__proto__', 'constructor', 'prototype'].includes(fromY.toString()) ||\n      ['__proto__', 'constructor', 'prototype'].includes(toY.toString())\n    ) {\n      return false; // Mouvement invalide en dehors des limites ou clé interdite\n    }\n\n    const piece = this.getPiece(fromX, fromY);\n    if (piece && piece.isValidMove(fromX, fromY, toX, toY, this)) {\n      const targetPiece = this.getPiece(toX, toY);\n\n      // Empêche de capturer le roi ennemi\n      if (targetPiece && targetPiece.type === PieceType.KING) {\n        return false;\n      }\n\n      // Gestion du roque\n      if (Piece.isKing(piece) && Math.abs(toX - fromX) === 2) {\n        if (this.isCastlingValid(piece, fromX, fromY, toX)) {\n          this.handleCastling(toX, fromY);\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      // Gestion de la prise en passant\n      if (\n        piece?.type === PieceType.PAWN &&\n        this.isEnPassantMove(fromX, fromY, toX, toY)\n      ) {\n        this.captureEnPassant(fromX, fromY, toX, toY); // Capture le pion en passant\n      }\n\n      // Sauvegarde l'état avant de simuler le mouvement\n      this.grid[toY][toX] = piece;\n      this.grid[fromY][fromX] = null;\n\n      // Vérifie si le mouvement met le roi du joueur en échec\n      if (this.isKingInCheck(piece.color)) {\n        // Annule le mouvement si le roi est en échec\n        this.grid[fromY][fromX] = piece;\n        this.grid[toY][toX] = targetPiece;\n        return false;\n      }\n\n      // Mise à jour de l'état après un mouvement valide\n      if ('hasMoved' in piece) {\n        (piece as any).hasMoved = true;\n      }\n      this.updateEnPassantTarget(fromX, fromY, toX, toY, piece);\n\n      // Réinitialise le compteur pour la règle des 50 coups si un pion bouge ou une capture a lieu\n      this.halfMoveCount =\n        piece.type === PieceType.PAWN || targetPiece\n          ? 0\n          : this.halfMoveCount + 1;\n\n      // Vérifie si le mouvement met l'adversaire en échec et mat\n      const opponentColor =\n        piece.color === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n      if (this.isCheckmate(opponentColor)) {\n        return true; // Partie terminée\n      }\n\n      return true;\n    }\n\n    return false; // Mouvement invalide\n  }\n\n  private isCastlingValid(\n    king: King,\n    fromX: number,\n    fromY: number,\n    toX: number,\n  ): boolean {\n    const direction = toX > fromX ? 1 : -1;\n    const rookX = toX > fromX ? 7 : 0;\n    const rook = this.getPiece(rookX, fromY);\n\n    if (!(rook?.type === PieceType.ROOK) || rook.hasMoved || king.hasMoved)\n      return false;\n\n    // Vérifie que les cases entre le roi et la tour sont libres\n    for (let x = fromX + direction; x !== toX; x += direction) {\n      if (\n        this.getPiece(x, fromY) ||\n        this.isSquareUnderAttack(x, fromY, king.color)\n      ) {\n        return false;\n      }\n    }\n\n    return (\n      !this.isSquareUnderAttack(fromX, fromY, king.color) &&\n      !this.isSquareUnderAttack(toX, fromY, king.color)\n    );\n  }\n\n  private handleCastling(kingX: number, kingY: number): void {\n    // Déplacement pour le petit roque (roi se déplace vers la droite)\n    if (kingX === 6) {\n      const rook = this.getPiece(7, kingY);\n      if (rook?.type === PieceType.ROOK) {\n        this.movePiece(7, kingY, 5, kingY);\n      }\n    }\n    // Déplacement pour le grand roque (roi se déplace vers la gauche)\n    else if (kingX === 2) {\n      const rook = this.getPiece(0, kingY);\n      if (rook?.type === PieceType.ROOK) {\n        this.movePiece(0, kingY, 3, kingY);\n      }\n    }\n  }\n\n  public updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    if (\n      piece?.type === PieceType.PAWN &&\n      Math.abs(toY - fromY) === 2 &&\n      fromX === toX\n    ) {\n      // Si le pion avance de deux cases, configure la cible pour la prise en passant\n      this.enPassantTarget = { x: toX, y: (fromY + toY) / 2 };\n    } else {\n      this.enPassantTarget = null;\n    }\n  }\n\n  public captureEnPassant(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): { capturedWhite: PieceType[]; capturedBlack: PieceType[] } | null {\n    const piece = this.getPiece(fromX, fromY);\n\n    if (\n      this.isEnPassantMove(fromX, fromY, toX, toY) &&\n      piece?.type === PieceType.PAWN\n    ) {\n      const direction = piece.color === PieceColor.WHITE ? -1 : 1;\n      const capturedPawnY = toY + direction;\n      const capturedPawn = this.getPiece(toX, capturedPawnY);\n\n      if (capturedPawn && capturedPawn.type === PieceType.PAWN) {\n        this.grid[capturedPawnY][toX] = null;\n\n        // Déclare explicitement le type de captureData pour éviter l'erreur\n        const captureData: {\n          capturedWhite: PieceType[];\n          capturedBlack: PieceType[];\n        } = {\n          capturedWhite: [],\n          capturedBlack: [],\n        };\n\n        if (capturedPawn.color === PieceColor.WHITE) {\n          captureData.capturedWhite.push(capturedPawn.type);\n        } else {\n          captureData.capturedBlack.push(capturedPawn.type);\n        }\n\n        // Appelle updateCapturedPieces pour mettre à jour le DOM\n        updateCapturedPieces(capturedPawn.type, capturedPawn.color);\n\n        return captureData;\n      }\n    }\n    return null;\n  }\n\n  public isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (!this.enPassantTarget) return false;\n\n    // Vérifie que le mouvement cible la bonne case pour la prise en passant\n    const piece = this.getPiece(fromX, fromY);\n    return (\n      piece?.type === PieceType.PAWN &&\n      toX === this.enPassantTarget.x &&\n      toY === this.enPassantTarget.y &&\n      Math.abs(fromX - toX) === 1 &&\n      Math.abs(fromY - toY) === 1\n    );\n  }\n\n  public async promotePawn(\n    x: number,\n    y: number,\n    pieceType: string,\n  ): Promise<void> {\n    const color = this.getPiece(x, y)?.color;\n\n    if (!color) return;\n\n    switch (pieceType) {\n      case 'queen':\n        this.grid[y][x] = await createPiece(PieceType.QUEEN, color);\n        break;\n      case 'rook':\n        this.grid[y][x] = await createPiece(PieceType.ROOK, color);\n        break;\n      case 'bishop':\n        this.grid[y][x] = await createPiece(PieceType.BISHOP, color);\n        break;\n      case 'knight':\n        this.grid[y][x] = await createPiece(PieceType.KNIGHT, color);\n        break;\n    }\n  }\n\n  public isKingInCheck(color: PieceColor): boolean {\n    const kingPosition = this.findKing(color);\n    if (!kingPosition) {\n      return false;\n    }\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(x, y, kingPosition.x, kingPosition.y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  public isCheckmate(color: PieceColor): boolean {\n    if (!this.isKingInCheck(color)) {\n      return false; // Pas de mat si le roi n'est pas en échec\n    }\n\n    // Parcourt chaque pièce de la couleur donnée pour trouver un mouvement légal\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          const moves = this.getValidMoves(x, y);\n\n          for (const move of moves) {\n            // Simule le mouvement\n            const originalPiece = this.getPiece(move.x, move.y);\n            this.grid[move.y][move.x] = piece;\n            this.grid[y][x] = null;\n\n            const kingSafe = !this.isKingInCheck(color);\n\n            // Annule le mouvement simulé\n            this.grid[y][x] = piece;\n            this.grid[move.y][move.x] = originalPiece;\n\n            if (kingSafe) {\n              return false; // Un mouvement légal existe pour sortir de l'échec\n            }\n          }\n        }\n      }\n    }\n\n    return true; // Aucun mouvement possible, échec et mat\n  }\n\n  public isStalemate(color: PieceColor): boolean {\n    // Pat uniquement si le roi n'est pas en échec et qu'il n'y a aucun coup légal disponible\n    if (this.isKingInCheck(color)) return false;\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          for (let toY = 0; toY < 8; toY++) {\n            for (let toX = 0; toX < 8; toX++) {\n              if (piece.isValidMove(x, y, toX, toY, this)) {\n                // Simuler le mouvement pour vérifier l'échec potentiel\n                const originalPiece = this.getPiece(toX, toY);\n                this.grid[toY][toX] = piece;\n                this.grid[y][x] = null;\n\n                const isKingSafe = !this.isKingInCheck(color);\n\n                // Annuler le mouvement simulé\n                this.grid[y][x] = piece;\n                this.grid[toY][toX] = originalPiece;\n\n                if (isKingSafe) return false; // Mouvement valide trouvé, pas de pat\n              }\n            }\n          }\n        }\n      }\n    }\n    return true; // Aucun coup légal trouvé, pat détecté\n  }\n\n  private findKing(color: PieceColor): { x: number; y: number } | null {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece?.type === PieceType.KING && piece.color === color) {\n          return { x, y };\n        }\n      }\n    }\n    return null;\n  }\n\n  public isKing(x: number, y: number): boolean {\n    const piece = this.getPiece(x, y);\n    return piece?.type === PieceType.KING;\n  }\n\n  public isSquareUnderAttack(x: number, y: number, color: PieceColor): boolean {\n    for (let fromY = 0; fromY < 8; fromY++) {\n      for (let fromX = 0; fromX < 8; fromX++) {\n        const piece = this.getPiece(fromX, fromY);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(fromX, fromY, x, y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Vérifie le matériel insuffisant pour un échec et mat\n  public isInsufficientMaterial(): boolean {\n    const pieces = this.grid.flat().filter((piece) => piece !== null);\n\n    // Cas les plus courants de matériel insuffisant\n    if (pieces.length <= 2) return true; // Seulement les rois sur le plateau\n    return (\n      pieces.length === 3 &&\n      pieces.some(\n        (piece) =>\n          piece?.type === PieceType.BISHOP || piece?.type === PieceType.KNIGHT,\n      )\n    );\n  }\n\n  // Vérifie si la règle des 50 coups est remplie\n  public isFiftyMoveRule(): boolean {\n    return this.halfMoveCount >= 50;\n  }\n\n  public setPiece(x: number, y: number, piece: Piece | null): void {\n    this.grid[y][x] = piece;\n  }\n\n  // Vérifie si un mouvement est valide\n  public isMoveValid(\n    fromRow: number,\n    fromCol: number,\n    toRow: number,\n    toCol: number,\n  ): boolean {\n    const piece = this.getPiece(fromRow, fromCol);\n\n    // Si aucune pièce n'est présente à l'emplacement source, le mouvement est invalide\n    if (!piece) {\n      return false;\n    }\n\n    // Si la destination est en dehors de l'échiquier, mouvement invalide\n    if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) {\n      return false;\n    }\n\n    // Vérifie si la pièce peut se déplacer à cette destination en utilisant la logique de mouvement de la pièce\n    if (!piece.isValidMove(fromRow, fromCol, toRow, toCol, this)) {\n      return false;\n    }\n\n    // Vérifie s'il y a une pièce à la destination et si elle est de la même couleur\n    const destinationPiece = this.getPiece(toRow, toCol);\n    return !(destinationPiece && destinationPiece.color === piece.color);\n  }\n\n  public isCapture(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    const piece = this.isWithinBounds(fromX, fromY)\n      ? this.getPiece(fromX, fromY)\n      : null;\n    const targetPiece = this.isWithinBounds(toX, toY)\n      ? this.getPiece(toX, toY)\n      : null;\n\n    // Vérifie qu'il y a une pièce à la position cible et qu'elle est d'une couleur opposée\n    return (\n      piece !== null &&\n      targetPiece !== null &&\n      piece.color !== targetPiece.color\n    );\n  }\n\n  public static async fromData(data: any): Promise<Board> {\n    const board = new Board();\n    await board.init();\n    board.grid = await Promise.all(\n      data.grid.map(async (row: any[]) =>\n        Promise.all(\n          row.map(async (pieceData) =>\n            pieceData ? await Piece.fromData(pieceData) : null,\n          ),\n        ),\n      ),\n    );\n    return board;\n  }\n\n  public toData(): any {\n    return {\n      grid: this.grid.map((row) =>\n        row.map((piece) => (piece ? piece.toData() : null)),\n      ),\n    };\n  }\n\n  public isAdjacentToAnotherKing(\n    x: number,\n    y: number,\n    color: PieceColor,\n  ): boolean {\n    const kingPositions = [\n      { dx: -1, dy: -1 },\n      { dx: -1, dy: 0 },\n      { dx: -1, dy: 1 },\n      { dx: 0, dy: -1 },\n      { dx: 0, dy: 1 },\n      { dx: 1, dy: -1 },\n      { dx: 1, dy: 0 },\n      { dx: 1, dy: 1 },\n    ];\n\n    for (const { dx, dy } of kingPositions) {\n      const nx = x + dx;\n      const ny = y + dy;\n      const piece = this.isWithinBounds(nx, ny) ? this.getPiece(nx, ny) : null;\n      if (piece?.type === PieceType.KING && piece.color !== color) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public clone(): Board {\n    const clonedBoard = new Board();\n    clonedBoard.grid = this.grid.map((row) =>\n      row.map((piece) =>\n        piece\n          ? Object.create(\n              Object.getPrototypeOf(piece),\n              Object.getOwnPropertyDescriptors(piece),\n            )\n          : null,\n      ),\n    );\n    clonedBoard.enPassantTarget = this.enPassantTarget\n      ? { ...this.enPassantTarget }\n      : null;\n    clonedBoard.halfMoveCount = this.halfMoveCount;\n    return clonedBoard;\n  }\n\n  public getPieceCount(): number {\n    return this.grid.flat().filter((piece) => piece !== null).length;\n  }\n\n  public isGameOver(): boolean {\n    // Vérifie l'échec et mat pour chaque couleur\n    if (\n      this.isCheckmate(PieceColor.WHITE) ||\n      this.isCheckmate(PieceColor.BLACK)\n    ) {\n      return true;\n    }\n\n    // Vérifie le pat pour chaque couleur\n    if (\n      this.isStalemate(PieceColor.WHITE) ||\n      this.isStalemate(PieceColor.BLACK)\n    ) {\n      return true;\n    }\n\n    // Vérifie le matériel insuffisant pour chaque couleur\n    if (this.isInsufficientMaterial()) {\n      return true;\n    }\n\n    // Vérifie si la règle des 50 coups est atteinte\n    return this.isFiftyMoveRule();\n  }\n\n  public getWinner(): PieceColor | null {\n    // Si c'est un échec et mat pour les Noirs, Blancs gagnent\n    if (this.isCheckmate(PieceColor.BLACK)) {\n      return PieceColor.WHITE;\n    }\n\n    // Si c'est un échec et mat pour les Blancs, Noirs gagnent\n    if (this.isCheckmate(PieceColor.WHITE)) {\n      return PieceColor.BLACK;\n    }\n\n    // Si c'est un pat, une égalité par matériel insuffisant, ou la règle des 50 coups, la partie est nulle\n    if (\n      this.isStalemate(PieceColor.WHITE) ||\n      this.isStalemate(PieceColor.BLACK) ||\n      this.isInsufficientMaterial() ||\n      this.isFiftyMoveRule()\n    ) {\n      return null;\n    }\n\n    return null; // Retourne null si le jeu n'est pas encore terminé\n  }\n\n  public getPieces(): Piece[] {\n    return this.grid.flat().filter((piece): piece is Piece => piece !== null);\n  }\n}\n","// game.ts\nimport { Board } from './board';\nimport { updateCapturedPieces } from './utils/utils';\nimport { PieceColor, PieceType } from './piece';\n\nexport class Game {\n  private readonly board: Board;\n  private aiWorker: Worker;\n\n  constructor() {\n    this.board = new Board();\n    this.aiWorker = new Worker(new URL('./ai.worker.ts', import.meta.url), {\n      type: 'module',\n    });\n  }\n\n  public async getBoard(): Board {\n    await this.board.init();\n    return this.board;\n  }\n\n  public makeAIMove(): Promise<void> {\n    return new Promise((resolve) => {\n      this.aiWorker.onmessage = (event) => {\n        const { bestMove, captureData } = event.data;\n\n        if (bestMove) {\n          const wasMoved = this.board.movePiece(\n            bestMove.fromX,\n            bestMove.fromY,\n            bestMove.toX,\n            bestMove.toY,\n          );\n\n          if (wasMoved && captureData) {\n            captureData.capturedWhite.forEach((piece: PieceType) =>\n              updateCapturedPieces(piece, PieceColor.WHITE),\n            );\n            captureData.capturedBlack.forEach((piece: PieceType) =>\n              updateCapturedPieces(piece, PieceColor.BLACK),\n            );\n          }\n        }\n        resolve(); // Résout la promesse une fois le coup de l’IA joué\n      };\n\n      const boardData = this.board.toData();\n      this.aiWorker.postMessage({ boardData });\n    });\n  }\n}\n","// src/canvas-renderer.ts\nimport { Board } from './board';\nimport { Piece, PieceColor } from './piece';\n\nexport class CanvasRenderer {\n  private canvas: HTMLCanvasElement;\n  private context: CanvasRenderingContext2D;\n  private readonly tileSize: number;\n  private draggingPiece: Piece | null = null;\n  private startX: number | null = null;\n  private startY: number | null = null;\n  private highlightedMoves: { x: number; y: number }[] = [];\n  private kingInCheckPosition: { x: number; y: number } | null = null;\n\n  constructor(\n    private board: Board,\n    canvasId: string,\n    private moveHandler: (\n      fromX: number,\n      fromY: number,\n      toX: number,\n      toY: number,\n    ) => boolean, // Utilisation d'un retour booléen pour vérifier si le mouvement est valide\n  ) {\n    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    this.context = this.canvas.getContext('2d')!;\n    this.tileSize = this.canvas.width / 8;\n\n    // Définir le curseur par défaut\n    this.canvas.style.cursor = 'default';\n\n    // Ajouter des écouteurs pour gérer les événements de glisser-déposer\n    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n  }\n\n  // Animation pour déplacer une pièce\n  public animateMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    const frames = 10;\n    let currentFrame = 0;\n\n    const startX = fromX * this.tileSize;\n    const startY = fromY * this.tileSize;\n    const deltaX = ((toX - fromX) * this.tileSize) / frames;\n    const deltaY = ((toY - fromY) * this.tileSize) / frames;\n\n    const animate = () => {\n      if (currentFrame <= frames) {\n        // Redessine l'échiquier pour effacer l'ancienne position de la pièce\n        this.drawBoard();\n\n        this.context.fillStyle =\n          piece.color === PieceColor.WHITE ? 'white' : 'black';\n        this.context.font = '48px Arial';\n        this.context.textAlign = 'center';\n        this.context.textBaseline = 'middle';\n\n        // Dessine la pièce en mouvement\n        this.context.fillText(\n          this.getPieceText(piece),\n          startX + deltaX * currentFrame + this.tileSize / 2,\n          startY + deltaY * currentFrame + this.tileSize / 2,\n        );\n\n        currentFrame++;\n        requestAnimationFrame(animate);\n      } else {\n        // Redessiner l'échiquier à la fin de l'animation pour afficher la pièce à la position finale\n        this.drawBoard();\n      }\n    };\n\n    animate();\n  }\n\n  // Surligne les mouvements valides pour une pièce sélectionnée\n  highlightValidMoves(moves: { x: number; y: number }[]): void {\n    this.context.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Couleur de surlignage (vert translucide)\n    moves.forEach((move) => {\n      this.context.fillRect(\n        move.x * this.tileSize,\n        move.y * this.tileSize,\n        this.tileSize,\n        this.tileSize,\n      );\n    });\n  }\n\n  // Dessiner l'échiquier et les pièces\n  public drawBoard(): void {\n    // Obtenir la position du roi en échec si elle existe\n    const kingInCheck = this.board.getKingInCheck();\n    this.kingInCheckPosition = kingInCheck\n      ? { x: kingInCheck.x, y: kingInCheck.y }\n      : null;\n\n    // Dessiner le plateau\n    this.drawTiles();\n    this.drawPieces();\n  }\n\n  // Dessiner les cases de l'échiquier\n  private drawTiles(): void {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const isDarkTile = (x + y) % 2 === 1;\n        let tileColor = isDarkTile ? '#769656' : '#eeeed2';\n\n        // Si la case contient le roi en échec, change la couleur\n        if (\n          this.kingInCheckPosition &&\n          this.kingInCheckPosition.x === x &&\n          this.kingInCheckPosition.y === y\n        ) {\n          tileColor = '#ff6347'; // Par exemple, une couleur rouge pour indiquer l'échec\n        }\n\n        this.context.fillStyle = tileColor;\n        this.context.fillRect(\n          x * this.tileSize,\n          y * this.tileSize,\n          this.tileSize,\n          this.tileSize,\n        );\n      }\n    }\n  }\n\n  // Dessiner toutes les pièces sur l'échiquier\n  private drawPieces(): void {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.board.getPiece(x, y);\n        if (piece) {\n          this.drawPiece(piece, x, y);\n        }\n      }\n    }\n  }\n\n  // Dessiner une pièce spécifique\n  private drawPiece(piece: Piece, x: number, y: number): void {\n    this.context.fillStyle = piece.color === 'white' ? 'white' : 'black';\n    this.context.font = '48px Arial';\n    this.context.textAlign = 'center';\n    this.context.textBaseline = 'middle';\n    const pieceText = this.getPieceText(piece);\n    this.context.fillText(\n      pieceText,\n      x * this.tileSize + this.tileSize / 2,\n      y * this.tileSize + this.tileSize / 2,\n    );\n  }\n\n  // Convertir le type de pièce en texte pour affichage\n  private getPieceText(piece: Piece): string {\n    switch (piece.type) {\n      case 'pawn':\n        return piece.color === 'white' ? '♙' : '♟';\n      case 'rook':\n        return piece.color === 'white' ? '♖' : '♜';\n      case 'knight':\n        return piece.color === 'white' ? '♘' : '♞';\n      case 'bishop':\n        return piece.color === 'white' ? '♗' : '♝';\n      case 'queen':\n        return piece.color === 'white' ? '♕' : '♛';\n      case 'king':\n        return piece.color === 'white' ? '♔' : '♚';\n      default:\n        return '';\n    }\n  }\n\n  // Gérer le début du glissement\n  private handleMouseDown(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    const piece = this.board.getPiece(x, y);\n    if (piece) {\n      this.draggingPiece = piece;\n      this.startX = x;\n      this.startY = y;\n      this.canvas.style.cursor = 'grabbing'; // Change le curseur pendant le drag\n\n      // Obtenez les mouvements légaux pour la pièce sélectionnée\n      this.highlightedMoves = this.board.getValidMoves(x, y);\n\n      // Redessinez le plateau avec les cases surlignées\n      this.drawBoard();\n      this.highlightValidMoves(this.highlightedMoves); // Surligne les mouvements valides\n    }\n  }\n\n  // Gérer le mouvement pendant le glissement\n  private handleMouseMove(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    // Changer le curseur lorsque la souris survole une pièce\n    let piece = null;\n    if (this.board.isWithinBounds(x, y)) piece = this.board.getPiece(x, y);\n    if (piece && !this.draggingPiece) {\n      this.canvas.style.cursor = 'pointer';\n    } else if (!this.draggingPiece) {\n      this.canvas.style.cursor = 'default';\n    }\n\n    if (!this.draggingPiece) return;\n\n    // Dessiner l'échiquier et les pièces\n    this.drawBoard();\n\n    // Assurez-vous que les mouvements valides restent visibles pendant le glissement\n    this.highlightValidMoves(this.highlightedMoves);\n\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n\n    // Dessiner la pièce en mouvement\n    this.context.fillStyle =\n      this.draggingPiece.color === 'white' ? 'white' : 'black';\n    this.context.font = '48px Arial';\n    this.context.textAlign = 'center';\n    this.context.textBaseline = 'middle';\n    const pieceText = this.getPieceText(this.draggingPiece);\n    this.context.fillText(pieceText, mouseX, mouseY);\n  }\n\n  // Gérer la fin du glissement\n  private handleMouseUp(event: MouseEvent): void {\n    if (!this.draggingPiece || this.startX === null || this.startY === null)\n      return;\n\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    // Utilise la fonction de rappel `moveHandler` pour déplacer la pièce\n    const moveSuccessful = this.moveHandler(this.startX, this.startY, x, y);\n\n    // Réinitialise l'état de glissement\n    this.draggingPiece = null;\n    this.startX = null;\n    this.startY = null;\n    this.canvas.style.cursor = 'default'; // Rétablir le curseur par défaut\n\n    // Efface les coups surlignés\n    this.highlightedMoves = [];\n\n    // Redessine le plateau après la fin du glissement\n    this.drawBoard();\n\n    // Si le mouvement est réussi, met à jour le tour\n    if (moveSuccessful) {\n      this.drawBoard();\n    }\n  }\n}\n","// src/timer.ts\nexport class Timer {\n  private intervalId: number | null = null;\n  private currentTime: number;\n  private readonly onTimeUpdate: (timeLeft: number) => void;\n  public isRunning: boolean = false;\n\n  constructor(\n    private initialTime: number,\n    onTimeUpdate: (timeLeft: number) => void,\n  ) {\n    this.currentTime = initialTime;\n    this.onTimeUpdate = onTimeUpdate;\n  }\n\n  // Démarrer le compte à rebours\n  public start(): void {\n    if (this.isRunning) return;\n\n    this.isRunning = true;\n    this.intervalId = window.setInterval(() => {\n      this.currentTime--;\n      this.onTimeUpdate(this.currentTime);\n\n      if (this.currentTime <= 0) {\n        this.currentTime = 0;\n        this.stop();\n        // Appel de la fonction onTimeUpdate une dernière fois pour garantir l'affichage du temps écoulé\n        this.onTimeUpdate(this.currentTime);\n      }\n    }, 1000);\n  }\n\n  // Arrêter le compte à rebours\n  public stop(): void {\n    if (!this.isRunning) {\n      return;\n    }\n\n    if (this.intervalId !== null) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    this.isRunning = false;\n  }\n\n  // Réinitialiser le temps\n  public reset(time: number): void {\n    this.stop();\n    this.currentTime = time;\n    this.onTimeUpdate(this.currentTime); // Appel immédiat pour la mise à jour du temps\n    this.start();\n  }\n}\n","// src/index.ts\nimport { Game } from './game';\nimport { CanvasRenderer } from './canvas-renderer';\nimport { Timer } from './timer';\nimport { PieceColor, PieceType } from './piece';\nimport {\n  getPieceSymbol,\n  showMessage,\n  updateCapturedPieces,\n} from './utils/utils';\n\nconst game = new Game();\nconst board = await game.getBoard();\nconst moveHistoryElement = document.getElementById(\n  'moveHistory',\n) as HTMLUListElement;\nconst currentTurnElement = document.getElementById(\n  'currentTurn',\n) as HTMLDivElement;\nconst timerElement = document.getElementById('timer') as HTMLDivElement;\nconst passTurnButton = document.getElementById(\n  'passTurnButton',\n) as HTMLButtonElement;\nconst gameMessageElement = document.getElementById(\n  'gameMessage',\n) as HTMLDivElement;\nconst replayButton = document.getElementById(\n  'replayButton',\n) as HTMLButtonElement;\n\nlet currentPlayer: PieceColor = PieceColor.WHITE; // Les blancs commencent toujours\nlet gameState: 'playing' | 'waiting' = 'playing'; // Ajout de l'état pour la proposition de nullité\nlet hasMoved: boolean = false; // Indique si un mouvement a déjà été effectué dans ce tour\nlet moveHistory: {\n  fromX: number;\n  fromY: number;\n  toX: number;\n  toY: number;\n  pieceType: PieceType;\n}[][] = [[]]; // Historique des mouvements par tour\nlet isGameEnded = false;\nlet isAITurn = false;\n\n// Initialiser le timer avec 60 secondes pour chaque joueur\nlet whiteTimer = new Timer(60, (timeLeft) =>\n  updateTimerDisplay(timeLeft, PieceColor.WHITE),\n);\nlet blackTimer = new Timer(60, (timeLeft) =>\n  updateTimerDisplay(timeLeft, PieceColor.BLACK),\n);\n\n// Fonction pour mettre à jour l'affichage du timer\nexport function updateTimerDisplay(timeLeft: number, color: PieceColor) {\n  if (color === currentPlayer) {\n    timerElement.textContent = `Temps restant: ${timeLeft}s`;\n    if (timeLeft <= 0 && !isGameEnded) {\n      endGame(\n        `${currentPlayer === PieceColor.WHITE ? 'Noir' : 'Blanc'} gagne par temps écoulé !`,\n      );\n    }\n  }\n}\n\n// Démarrer le jeu et dessiner le plateau\nconst renderer = new CanvasRenderer(board, 'chessBoard', handleMove);\nrenderer.drawBoard();\nwhiteTimer.start();\n\nexport function endGame(message: string) {\n  showMessage(message);\n  isGameEnded = true;\n  replayButton.style.display = 'block';\n  if (whiteTimer.isRunning) whiteTimer.stop();\n  if (blackTimer.isRunning) blackTimer.stop();\n}\n\n// Fonction pour effacer le message d'erreur\nfunction clearMessage() {\n  gameMessageElement.textContent = '';\n  gameMessageElement.style.display = 'none';\n}\n\n// Fonction pour mettre à jour le tour et l'affichage\nasync function updateTurn() {\n  clearMessage();\n  currentPlayer =\n    currentPlayer === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n  currentTurnElement.textContent = `Tour actuel: ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`;\n  hasMoved = false;\n\n  // Gestion du bouton \"Passer son tour\"\n  passTurnButton.disabled = currentPlayer === PieceColor.BLACK;\n\n  // Gestion des timers\n  if (currentPlayer === PieceColor.WHITE) {\n    if (blackTimer.isRunning) blackTimer.stop();\n    whiteTimer.reset(60);\n  } else {\n    if (whiteTimer.isRunning) whiteTimer.stop();\n    blackTimer.reset(60);\n  }\n\n  if (\n    board.isKingInCheck(PieceColor.BLACK) ||\n    board.isKingInCheck(PieceColor.WHITE)\n  ) {\n    if (board.isCheckmate(PieceColor.BLACK)) {\n      endGame('Échec et Mat ! Blanc gagne !');\n    }\n\n    if (board.isCheckmate(PieceColor.WHITE)) {\n      endGame('Échec et Mat ! Noir gagne !');\n    }\n  }\n\n  // Vérifie les conditions de nullité\n  if (board.isStalemate(currentPlayer)) {\n    endGame('Pat ! La partie est nulle.');\n  }\n\n  if (board.isInsufficientMaterial()) {\n    endGame('Matériel insuffisant pour continuer, partie nulle !');\n  }\n\n  if (board.isFiftyMoveRule()) {\n    endGame('Règle des 50 coups, partie nulle !');\n  }\n\n  // Seul \"playing\" permet de jouer\n  if (gameState === 'playing') {\n    gameState = 'playing';\n  }\n\n  // Crée un nouveau tour dans l'historique des mouvements\n  moveHistory.push([]);\n\n  // Si c'est au tour de l'IA, faire jouer l'IA automatiquement\n  if (currentPlayer === PieceColor.BLACK) {\n    await triggerAIMove();\n  }\n}\n\nasync function triggerAIMove() {\n  isAITurn = true;\n  await game.makeAIMove();\n  renderer.drawBoard();\n  isAITurn = false;\n  await updateTurn(); // Revenir au tour du joueur après le coup de l'IA\n}\n\n// Ajouter un mouvement à l'historique\nfunction addMoveToHistory(\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n  pieceType: PieceType,\n) {\n  const moveText = `${getPieceSymbol(pieceType, PieceColor.WHITE)} de (${fromX}, ${fromY}) à (${toX}, ${toY})`;\n  const listItem = document.createElement('li');\n  listItem.textContent = moveText;\n  moveHistoryElement.appendChild(listItem);\n\n  // Ajoutez le mouvement au tour actuel\n  moveHistory[moveHistory.length - 1].push({\n    fromX,\n    fromY,\n    toX,\n    toY,\n    pieceType,\n  });\n}\n\n// Fonction pour gérer un mouvement sur le plateau\nexport function handleMove(\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n): boolean {\n  if (gameState === 'waiting' || hasMoved || isGameEnded) {\n    showMessage('Veuillez attendre le prochain tour !');\n    return false;\n  }\n\n  const piece = board.getPiece(fromX, fromY);\n  const targetPiece = board.getPiece(toX, toY); // Ajout pour vérifier la cible\n\n  if (!piece || piece.color !== currentPlayer) {\n    if (!isAITurn) {\n      // Affiche le message uniquement si ce n'est pas le tour de l'IA\n      showMessage(\n        `C'est le tour de ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`,\n      );\n    }\n    return false;\n  }\n\n  if (piece.isValidMove(fromX, fromY, toX, toY, board)) {\n    if (board.movePiece(fromX, fromY, toX, toY)) {\n      hasMoved = true; // Empêche les actions supplémentaires\n\n      // Enregistrement de la capture si une pièce est prise\n      if (targetPiece) {\n        updateCapturedPieces(targetPiece.type, targetPiece.color);\n      }\n\n      addMoveToHistory(fromX, fromY, toX, toY, piece.type);\n      renderer.animateMove(fromX, fromY, toX, toY, piece);\n      updateTurn();\n      return true;\n    }\n    showMessage('Mouvement invalide !');\n  }\n  return false;\n}\n\n// Gérer le clic sur \"Passer son tour\"\nif (passTurnButton) {\n  passTurnButton.addEventListener('click', async (event) => {\n    event.preventDefault();\n    if (\n      gameState === 'playing' &&\n      currentPlayer === PieceColor.WHITE &&\n      !board.isKingInCheck(PieceColor.WHITE)\n    ) {\n      showMessage(\n        `Tour passé pour ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`,\n      );\n      await updateTurn();\n    }\n  });\n}\n\n// Gérer le clic sur \"Rejouer\"\nif (replayButton) {\n  replayButton.addEventListener('click', () => {\n    location.reload();\n  });\n}\nexport { Game };\n","// src/pieces/pawn.ts\nimport { Piece, PieceColor, PieceType, BoardInterface } from '../piece';\n\nexport class Pawn extends Piece {\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.PAWN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const direction = this.color === PieceColor.WHITE ? 1 : -1;\n    const startRow = this.color === PieceColor.WHITE ? 1 : 6;\n    const distanceY = (toY - fromY) * direction;\n    const distanceX = Math.abs(toX - fromX);\n\n    if (distanceX === 0 && distanceY === 1 && !board.getPiece(toX, toY)) {\n      if (\n        ((this.color === PieceColor.WHITE && toY === 7) ||\n          (this.color === PieceColor.BLACK && toY === 0)) &&\n        board.getPiece(fromX, fromY)?.type === PieceType.PAWN\n      ) {\n        this.handlePromotion(toX, toY, board);\n      }\n      return true;\n    }\n\n    if (\n      distanceX === 0 &&\n      distanceY === 2 &&\n      fromY === startRow &&\n      !board.getPiece(toX, toY) &&\n      !board.getPiece(fromX, fromY + direction)\n    ) {\n      board.updateEnPassantTarget(fromX, fromY, toX, toY, this);\n      return true;\n    }\n\n    if (distanceX === 1 && distanceY === 1) {\n      if (board.getPiece(toX, toY) && this.canCapture(toX, toY, board)) {\n        if (\n          (this.color === PieceColor.WHITE && toY === 7) ||\n          (this.color === PieceColor.BLACK &&\n            toY === 0 &&\n            board.getPiece(fromX, fromY)?.type === PieceType.PAWN)\n        ) {\n          this.handlePromotion(toX, toY, board);\n        }\n        return true;\n      }\n\n      if (board.isEnPassantMove(fromX, fromY, toX, toY)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  handlePromotion(toX: number, toY: number, board: BoardInterface): void {\n    const promotionDialog = document.getElementById(\n      'promotionDialog',\n    ) as HTMLDivElement;\n\n    if (promotionDialog) {\n      promotionDialog.style.display = 'block';\n\n      // Définir la fonction de promotion en capturant le contexte (x, y)\n      window.promote = (pieceType: string) => {\n        promotionDialog.style.display = 'none';\n        board.promotePawn(toX, toY, pieceType);\n      };\n    }\n  }\n}\n","// src/pieces/rook.ts\n\nimport { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\nimport { createPiece } from '../utils/pieceFactory';\n\nexport class Rook extends Piece {\n  public readonly type: PieceType = PieceType.ROOK;\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.ROOK);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const isStraightMove = fromX === toX || fromY === toY;\n    if (!isStraightMove) {\n      return false;\n    }\n\n    const isPathClear = this.isPathClear(fromX, fromY, toX, toY, board);\n    if (!isPathClear) {\n      return false;\n    }\n\n    return this.canCapture(toX, toY, board);\n  }\n\n  public toData(): any {\n    return {\n      ...super.toData(),\n      hasMoved: this.hasMoved,\n    };\n  }\n\n  // Ajuste le type de retour pour inclure Promise<Rook>\n  static async fromData(data: any): Promise<Rook> {\n    const rook = await createPiece(PieceType.ROOK, data.color);\n    rook.hasMoved = data.hasMoved;\n    return rook;\n  }\n}\n","// src/pieces/knight.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\n\nexport class Knight extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.KNIGHT);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    // Le Cavalier se déplace en L : 2 cases dans une direction puis 1 case perpendiculairement\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n    return (\n      ((dx === 2 && dy === 1) || (dx === 1 && dy === 2)) &&\n      this.canCapture(toX, toY, board)\n    );\n  }\n}\n","// src/pieces/bishop.ts\nimport { Piece, PieceColor, PieceType, BoardInterface } from '../piece';\n\nexport class Bishop extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.BISHOP);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    // Le fou se déplace en diagonale\n    if (Math.abs(toX - fromX) === Math.abs(toY - fromY)) {\n      // Vérifie que la trajectoire est dégagée\n      if (this.isPathClear(fromX, fromY, toX, toY, board)) {\n        // Vérifie si la cible est vide ou contient une pièce ennemie\n        return this.canCapture(toX, toY, board);\n      }\n    }\n    return false;\n  }\n}\n","// src/pieces/queen.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\n\nexport class Queen extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.QUEEN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    // La reine peut se déplacer en ligne droite ou en diagonale\n    if (\n      fromX === toX || // Déplacement en colonne\n      fromY === toY || // Déplacement en ligne\n      Math.abs(toX - fromX) === Math.abs(toY - fromY) // Déplacement en diagonale\n    ) {\n      // Vérifie que la trajectoire est dégagée\n      if (this.isPathClear(fromX, fromY, toX, toY, board)) {\n        // Vérifie si la cible est vide ou contient une pièce ennemie\n        return this.canCapture(toX, toY, board);\n      }\n    }\n\n    return false;\n  }\n}\n","import { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\n\nexport class King extends Piece {\n  public hasMoved: boolean = false;\n  public readonly type: PieceType = PieceType.KING;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.KING);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n\n    // Mouvement classique du roi\n    if (dx <= 1 && dy <= 1) {\n      return (\n        this.canCapture(toX, toY, board) &&\n        !board.isAdjacentToAnotherKing(toX, toY, this.color)\n      );\n    }\n\n    // Roque : si roi et tour n'ont pas bougé, la voie est libre et non attaquée\n    if (!this.hasMoved && dy === 0 && dx === 2) {\n      const direction = toX > fromX ? 1 : -1;\n      const rookX = toX > fromX ? 7 : 0;\n      const rook = board.getPiece(rookX, fromY);\n\n      if (rook && rook?.type === PieceType.ROOK && !rook.hasMoved) {\n        for (let x = fromX + direction; x !== toX; x += direction) {\n          if (\n            board.getPiece(x, fromY) ||\n            board.isSquareUnderAttack(x, fromY, this.color)\n          ) {\n            return false;\n          }\n        }\n        return (\n          !board.isSquareUnderAttack(toX, fromY, this.color) &&\n          !board.isAdjacentToAnotherKing(toX, toY, this.color)\n        );\n      }\n    }\n\n    return false;\n  }\n}\n"],"file":"bundle.js"}