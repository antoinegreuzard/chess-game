{"version":3,"file":"ai.worker-BgG0FHGC.js","sources":["../src/utils/pieceFactory.ts","../src/piece.ts","../src/utils/utils.ts","../src/board.ts","../src/ai/evaluator.ts","../src/ai/endgameTablebase.ts","../src/ai/openingBook.ts","../src/ai/gamesAnalyzer.ts","../src/ai/contextualMoveDatabase.ts","../src/ai.ts","../src/pieces/pawn.ts","../src/ai.worker.ts"],"sourcesContent":["import { PieceColor, PieceType } from '../piece';\n\nexport async function createPiece(type: PieceType, color: PieceColor) {\n  switch (type) {\n    case PieceType.PAWN:\n      const { Pawn } = await import('../pieces/pawn');\n      return new Pawn(color);\n    case PieceType.ROOK:\n      const { Rook } = await import('../pieces/rook');\n      return new Rook(color);\n    case PieceType.KNIGHT:\n      const { Knight } = await import('../pieces/knight');\n      return new Knight(color);\n    case PieceType.BISHOP:\n      const { Bishop } = await import('../pieces/bishop');\n      return new Bishop(color);\n    case PieceType.QUEEN:\n      const { Queen } = await import('../pieces/queen');\n      return new Queen(color);\n    case PieceType.KING:\n      const { King } = await import('../pieces/king');\n      return new King(color);\n    default:\n      throw new Error(`Type de pièce inconnu : ${type}`);\n  }\n}\n","// src/piece.ts\nimport { createPiece } from './utils/pieceFactory';\nimport { King } from './pieces/king';\n\nexport enum PieceColor {\n  WHITE = 'white',\n  BLACK = 'black',\n}\n\nexport enum PieceType {\n  PAWN = 'pawn',\n  ROOK = 'rook',\n  KNIGHT = 'knight',\n  BISHOP = 'bishop',\n  QUEEN = 'queen',\n  KING = 'king',\n}\n\nexport interface BoardInterface {\n  getPiece(x: number, y: number): Piece | null;\n\n  updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void;\n\n  isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean;\n\n  promotePawn(\n    x: number,\n    y: number,\n    pieceType: PieceType | string,\n  ): Promise<void>;\n\n  isSquareUnderAttack(x: number, y: number, color: PieceColor): boolean;\n\n  isKing(x: number, y: number): boolean;\n\n  isAdjacentToAnotherKing(x: number, y: number, color: PieceColor): boolean;\n\n  getPlayerColor(): PieceColor;\n\n  captureEnPassantIfValid(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): void;\n}\n\nexport abstract class Piece {\n  public hasMoved: boolean = false;\n\n  protected constructor(\n    public color: PieceColor,\n    public type: PieceType,\n  ) {}\n\n  abstract isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean;\n\n  public isPathClear(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const dx = Math.sign(toX - fromX);\n    const dy = Math.sign(toY - fromY);\n\n    let x = fromX + dx;\n    let y = fromY + dy;\n    while (x !== toX || y !== toY) {\n      if (board.getPiece(x, y) !== null) return false;\n      x += dx;\n      y += dy;\n    }\n    return true;\n  }\n\n  static isKing(piece: Piece): piece is King {\n    return piece.type === PieceType.KING;\n  }\n\n  public canCapture(toX: number, toY: number, board: BoardInterface): boolean {\n    const targetPiece = board.getPiece(toX, toY);\n    return !targetPiece || targetPiece.color !== this.color;\n  }\n\n  // Sérialisation des données de la pièce\n  public toData(): any {\n    return {\n      color: this.color,\n      type: this.type,\n    };\n  }\n\n  static async fromData(data: any): Promise<Piece> {\n    return await createPiece(data.type, data.color);\n  }\n\n  // Nouvelle méthode pour vérifier les menaces sans règles spécifiques du roi\n  public isThreatenedMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n    return dx <= 1 && dy <= 1;\n  }\n}\n","// src/utils/utils.ts\n\nimport { PieceColor, PieceType } from '../piece';\n\nexport let capturedWhite: string[] = [];\nexport let capturedBlack: string[] = [];\n\nexport function showMessage(message: string) {\n  const gameMessageElement = document.getElementById(\n    'gameMessage',\n  ) as HTMLDivElement;\n  if (gameMessageElement) {\n    gameMessageElement.textContent = message;\n    gameMessageElement.style.display = 'block'; // Afficher le message\n  }\n}\n\nexport function getPieceSymbol(piece: PieceType, color: PieceColor): string {\n  switch (piece) {\n    case PieceType.PAWN:\n      return color === PieceColor.WHITE ? '♙' : '♟';\n    case PieceType.ROOK:\n      return color === PieceColor.WHITE ? '♖' : '♜';\n    case PieceType.KNIGHT:\n      return color === PieceColor.WHITE ? '♘' : '♞';\n    case PieceType.BISHOP:\n      return color === PieceColor.WHITE ? '♗' : '♝';\n    case PieceType.QUEEN:\n      return color === PieceColor.WHITE ? '♕' : '♛';\n    case PieceType.KING:\n      return color === PieceColor.WHITE ? '♔' : '♚';\n    default:\n      return '';\n  }\n}\n\nexport function updateCapturedPieces(piece: PieceType, color: PieceColor) {\n  const pieceSymbol = getPieceSymbol(piece, color);\n\n  if (color === PieceColor.WHITE) {\n    capturedWhite.push(pieceSymbol);\n  } else {\n    capturedBlack.push(pieceSymbol);\n  }\n\n  updateCapturedPiecesDOM();\n}\n\nexport function updateCapturedPiecesDOM(): void {\n  const capturedWhiteElement = document.getElementById(\n    'capturedWhite',\n  ) as HTMLDivElement;\n  const capturedBlackElement = document.getElementById(\n    'capturedBlack',\n  ) as HTMLDivElement;\n\n  if (capturedWhiteElement) {\n    capturedWhiteElement.textContent = capturedWhite.join(' ');\n  }\n  if (capturedBlackElement) {\n    capturedBlackElement.textContent = capturedBlack.join(' ');\n  }\n}\n","// src/board.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from './piece';\nimport { King } from './pieces/king';\nimport { updateCapturedPieces } from './utils/utils';\nimport { createPiece } from './utils/pieceFactory';\n\ntype BoardSquare = Piece | null;\n\nexport class Board implements BoardInterface {\n  private grid: (Piece | null)[][];\n  private enPassantTarget: { x: number; y: number } | null = null;\n  private halfMoveCount: number = 0; // Compteur pour la règle des 50 coups\n  private currentPlayer: PieceColor = PieceColor.WHITE;\n\n  constructor() {\n    this.grid = Array(8)\n      .fill(null)\n      .map(() => Array(8).fill(null));\n  }\n\n  public async init(): Promise<void> {\n    this.grid = await this.initializeBoard();\n  }\n\n  private async initializeBoard(): Promise<(Piece | null)[][]> {\n    const board: (Piece | null)[][] = Array(8)\n      .fill(null)\n      .map(() => Array(8).fill(null));\n\n    // Ajouter les pièces blanches\n    board[0] = [\n      await createPiece(PieceType.ROOK, PieceColor.WHITE),\n      await createPiece(PieceType.KNIGHT, PieceColor.WHITE),\n      await createPiece(PieceType.BISHOP, PieceColor.WHITE),\n      await createPiece(PieceType.QUEEN, PieceColor.WHITE),\n      await createPiece(PieceType.KING, PieceColor.WHITE),\n      await createPiece(PieceType.BISHOP, PieceColor.WHITE),\n      await createPiece(PieceType.KNIGHT, PieceColor.WHITE),\n      await createPiece(PieceType.ROOK, PieceColor.WHITE),\n    ];\n    board[1] = await Promise.all(\n      Array(8)\n        .fill(null)\n        .map(() => createPiece(PieceType.PAWN, PieceColor.WHITE)),\n    );\n\n    // Ajouter les pièces noires\n    board[7] = [\n      await createPiece(PieceType.ROOK, PieceColor.BLACK),\n      await createPiece(PieceType.KNIGHT, PieceColor.BLACK),\n      await createPiece(PieceType.BISHOP, PieceColor.BLACK),\n      await createPiece(PieceType.QUEEN, PieceColor.BLACK),\n      await createPiece(PieceType.KING, PieceColor.BLACK),\n      await createPiece(PieceType.BISHOP, PieceColor.BLACK),\n      await createPiece(PieceType.KNIGHT, PieceColor.BLACK),\n      await createPiece(PieceType.ROOK, PieceColor.BLACK),\n    ];\n    board[6] = await Promise.all(\n      Array(8)\n        .fill(null)\n        .map(() => createPiece(PieceType.PAWN, PieceColor.BLACK)),\n    );\n\n    return board;\n  }\n\n  // Méthode générale pour vérifier les limites\n  public isWithinBounds(x: number, y: number): boolean {\n    return x >= 0 && x < 8 && y >= 0 && y < 8;\n  }\n\n  public getPiece(x: number, y: number): BoardSquare {\n    return this.grid[y][x];\n  }\n\n  public getValidMoves(x: number, y: number): { x: number; y: number }[] {\n    let piece = null;\n    if (this.isWithinBounds(x, y)) piece = this.getPiece(x, y);\n    if (!piece) return [];\n\n    const validMoves: { x: number; y: number }[] = [];\n\n    for (let toY = 0; toY < 8; toY++) {\n      for (let toX = 0; toX < 8; toX++) {\n        if (piece.isValidMove(x, y, toX, toY, this)) {\n          validMoves.push({ x: toX, y: toY });\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  public captureEnPassantIfValid(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): void {\n    if (this.isEnPassantMove(fromX, fromY, toX, toY)) {\n      const movingPawn = this.getPiece(fromX, fromY);\n      if (!movingPawn) return;\n\n      // Détermine la position du pion capturé en fonction de la couleur\n      const capturedPawnY =\n        toY + (movingPawn.color === PieceColor.WHITE ? -1 : 1);\n\n      if (this.grid[capturedPawnY][toX]) {\n        this.grid[capturedPawnY][toX] = null;\n      }\n    }\n  }\n\n  public getKingInCheck(): { x: number; y: number } | null {\n    if (this.isKingInCheck(PieceColor.WHITE)) {\n      return this.findKing(PieceColor.WHITE);\n    } else if (this.isKingInCheck(PieceColor.BLACK)) {\n      return this.findKing(PieceColor.BLACK);\n    }\n    return null;\n  }\n\n  public movePiece(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    isSimulation: boolean = true,\n  ): boolean {\n    if (\n      !this.isWithinBounds(fromX, fromY) ||\n      !this.isWithinBounds(toX, toY) ||\n      ['__proto__', 'constructor', 'prototype'].includes(fromY.toString()) ||\n      ['__proto__', 'constructor', 'prototype'].includes(toY.toString())\n    ) {\n      return false; // Mouvement invalide en dehors des limites ou clé interdite\n    }\n\n    const piece = this.getPiece(fromX, fromY);\n    if (piece && piece.isValidMove(fromX, fromY, toX, toY, this)) {\n      const targetPiece = this.getPiece(toX, toY);\n\n      // Empêche de capturer le roi ennemi\n      if (targetPiece && targetPiece.type === PieceType.KING) {\n        return false;\n      }\n\n      // Gestion du roque pour le roi\n      if (piece.type === PieceType.KING && Math.abs(toX - fromX) === 2) {\n        if (this.isCastlingValid(piece, fromX, fromY, toX)) {\n          this.handleCastling(toX, fromY);\n          piece.hasMoved = true; // Met à jour le statut de mouvement du roi\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      // Gestion de la prise en passant\n      if (\n        piece?.type === PieceType.PAWN &&\n        this.isEnPassantMove(fromX, fromY, toX, toY)\n      ) {\n        this.captureEnPassant(fromX, fromY, toX, toY); // Capture le pion en passant\n      }\n\n      // Sauvegarde l'état avant de simuler le mouvement\n      this.grid[toY][toX] = piece;\n      this.grid[fromY][fromX] = null;\n      if (!isSimulation) {\n        piece.hasMoved = true;\n      }\n\n      // Vérifie si le mouvement met le roi du joueur en échec\n      if (this.isKingInCheck(piece.color)) {\n        // Annule le mouvement si le roi est en échec\n        this.grid[fromY][fromX] = piece;\n        this.grid[toY][toX] = targetPiece;\n        return false;\n      }\n\n      // Mise à jour de `hasMoved` pour les rois et tours\n      if (piece.type === PieceType.KING || piece.type === PieceType.ROOK) {\n        piece.hasMoved = true;\n      }\n\n      // Mise à jour de l'état après un mouvement valide\n      this.updateEnPassantTarget(fromX, fromY, toX, toY, piece);\n\n      // Réinitialise le compteur pour la règle des 50 coups si un pion bouge ou une capture a lieu\n      this.halfMoveCount =\n        piece.type === PieceType.PAWN || targetPiece\n          ? 0\n          : this.halfMoveCount + 1;\n\n      // Vérifie si le mouvement met l'adversaire en échec et mat\n      const opponentColor =\n        piece.color === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n      if (this.isCheckmate(opponentColor)) {\n        return true; // Partie terminée\n      }\n\n      return true;\n    }\n\n    return false; // Mouvement invalide\n  }\n\n  private isCastlingValid(\n    king: King,\n    fromX: number,\n    fromY: number,\n    toX: number,\n  ): boolean {\n    const direction = toX > fromX ? 1 : -1;\n    const rookX = toX > fromX ? 7 : 0;\n    const rook = this.getPiece(rookX, fromY);\n\n    // Vérification des conditions de roque : roi et tour n'ont pas bougé, et la tour est présente\n    if (!(rook?.type === PieceType.ROOK) || rook.hasMoved || king.hasMoved)\n      return false;\n\n    // Vérifie que les cases entre le roi et la tour sont libres et non attaquées\n    for (let x = fromX + direction; x !== toX + direction; x += direction) {\n      if (\n        this.getPiece(x, fromY) ||\n        this.isSquareUnderAttack(x, fromY, king.color)\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private handleCastling(kingX: number, kingY: number): void {\n    // Petit roque (roi vers la droite)\n    if (kingX === 6) {\n      const rook = this.getPiece(7, kingY);\n      const king = this.getPiece(4, kingY);\n      if (\n        rook?.type === PieceType.ROOK &&\n        !rook.hasMoved &&\n        king?.type === PieceType.KING &&\n        !king.hasMoved\n      ) {\n        // Déplace la tour et le roi pour le petit roque\n        this.setPiece(5, kingY, rook); // Déplace la tour\n        this.setPiece(7, kingY, null); // Enlève la tour de sa position initiale\n        this.setPiece(6, kingY, king); // Déplace le roi vers sa nouvelle position\n        this.setPiece(4, kingY, null); // Enlève le roi de sa position initiale\n\n        // Marque le roi et la tour comme ayant bougé\n        king.hasMoved = true;\n        rook.hasMoved = true;\n      }\n    }\n    // Grand roque (roi vers la gauche)\n    else if (kingX === 2) {\n      const rook = this.getPiece(0, kingY);\n      const king = this.getPiece(4, kingY);\n      if (\n        rook?.type === PieceType.ROOK &&\n        !rook.hasMoved &&\n        king?.type === PieceType.KING &&\n        !king.hasMoved\n      ) {\n        // Déplace la tour et le roi pour le grand roque\n        this.setPiece(3, kingY, rook); // Déplace la tour\n        this.setPiece(0, kingY, null); // Enlève la tour de sa position initiale\n        this.setPiece(2, kingY, king); // Déplace le roi vers sa nouvelle position\n        this.setPiece(4, kingY, null); // Enlève le roi de sa position initiale\n\n        // Marque le roi et la tour comme ayant bougé\n        king.hasMoved = true;\n        rook.hasMoved = true;\n      }\n    }\n  }\n\n  public updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    // Vérifie que la pièce est un pion et qu'il avance de deux cases\n    if (\n      piece?.type === PieceType.PAWN &&\n      Math.abs(toY - fromY) === 2 &&\n      fromX === toX\n    ) {\n      // Si le pion avance de deux cases, configure `enPassantTarget`\n      // pour permettre une prise en passant lors du tour suivant\n      this.enPassantTarget = { x: toX, y: (fromY + toY) / 2 };\n    } else {\n      // Réinitialise `enPassantTarget` si aucune condition de prise en passant n'est remplie\n      this.enPassantTarget = null;\n    }\n  }\n\n  public captureEnPassant(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): { capturedWhite: PieceType[]; capturedBlack: PieceType[] } | null {\n    const piece = this.getPiece(fromX, fromY);\n\n    if (\n      this.isEnPassantMove(fromX, fromY, toX, toY) &&\n      piece?.type === PieceType.PAWN\n    ) {\n      const direction = piece.color === PieceColor.WHITE ? -1 : 1;\n      const capturedPawnY = toY + direction;\n      const capturedPawn = this.getPiece(toX, capturedPawnY);\n\n      if (capturedPawn && capturedPawn.type === PieceType.PAWN) {\n        // Supprime le pion capturé de la grille\n        this.grid[capturedPawnY][toX] = null;\n\n        // Initialise les données de capture\n        const captureData: {\n          capturedWhite: PieceType[];\n          capturedBlack: PieceType[];\n        } = {\n          capturedWhite: [],\n          capturedBlack: [],\n        };\n\n        // Met à jour les données de capture selon la couleur du pion capturé\n        if (capturedPawn.color === PieceColor.WHITE) {\n          captureData.capturedWhite.push(capturedPawn.type);\n        } else {\n          captureData.capturedBlack.push(capturedPawn.type);\n        }\n\n        // Appelle updateCapturedPieces pour mettre à jour l'interface\n        updateCapturedPieces(capturedPawn.type, capturedPawn.color);\n\n        return captureData;\n      }\n    }\n    return null;\n  }\n\n  public isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (!this.enPassantTarget) return false;\n\n    // Vérifie que le mouvement cible la bonne case pour la prise en passant\n    const piece = this.getPiece(fromX, fromY);\n    return (\n      piece?.type === PieceType.PAWN &&\n      toX === this.enPassantTarget.x &&\n      toY === this.enPassantTarget.y &&\n      Math.abs(fromX - toX) === 1 &&\n      Math.abs(fromY - toY) === 1\n    );\n  }\n\n  public async promotePawn(\n    x: number,\n    y: number,\n    pieceType: string,\n  ): Promise<void> {\n    const color = this.getPiece(x, y)?.color;\n\n    if (!color) return;\n\n    switch (pieceType) {\n      case 'queen':\n        this.grid[y][x] = await createPiece(PieceType.QUEEN, color);\n        break;\n      case 'rook':\n        this.grid[y][x] = await createPiece(PieceType.ROOK, color);\n        break;\n      case 'bishop':\n        this.grid[y][x] = await createPiece(PieceType.BISHOP, color);\n        break;\n      case 'knight':\n        this.grid[y][x] = await createPiece(PieceType.KNIGHT, color);\n        break;\n    }\n  }\n\n  public isKingInCheck(color: PieceColor): boolean {\n    const kingPosition = this.findKing(color);\n    if (!kingPosition) {\n      return false;\n    }\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(x, y, kingPosition.x, kingPosition.y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  public isCheckmate(color: PieceColor): boolean {\n    // Vérifie si le roi de la couleur donnée est en échec\n    const kingInCheck = this.isKingInCheck(color);\n\n    // Si le roi n'est pas en échec, ce n'est pas un échec et mat\n    if (!kingInCheck) {\n      return false;\n    }\n\n    // Parcourt chaque pièce de la couleur donnée pour trouver un mouvement légal\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          const moves = this.getValidMoves(x, y);\n\n          for (const move of moves) {\n            // Simule le mouvement\n            const originalPiece = this.getPiece(move.x, move.y);\n            this.grid[move.y][move.x] = piece;\n            this.grid[y][x] = null;\n\n            const kingSafe = !this.isKingInCheck(color);\n\n            // Annule le mouvement simulé\n            this.grid[y][x] = piece;\n            this.grid[move.y][move.x] = originalPiece;\n\n            if (kingSafe) {\n              return false; // Un mouvement légal existe pour sortir de l'échec\n            }\n          }\n        }\n      }\n    }\n\n    return true; // Aucun mouvement possible, échec et mat\n  }\n\n  public isStalemate(color: PieceColor): boolean {\n    // Pat uniquement si le roi n'est pas en échec et qu'il n'y a aucun coup légal disponible\n    if (this.isKingInCheck(color)) return false;\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          for (let toY = 0; toY < 8; toY++) {\n            for (let toX = 0; toX < 8; toX++) {\n              if (piece.isValidMove(x, y, toX, toY, this)) {\n                // Simuler le mouvement pour vérifier l'échec potentiel\n                const originalPiece = this.getPiece(toX, toY);\n                this.grid[toY][toX] = piece;\n                this.grid[y][x] = null;\n\n                const isKingSafe = !this.isKingInCheck(color);\n\n                // Annuler le mouvement simulé\n                this.grid[y][x] = piece;\n                this.grid[toY][toX] = originalPiece;\n\n                if (isKingSafe) return false; // Mouvement valide trouvé, pas de pat\n              }\n            }\n          }\n        }\n      }\n    }\n    return true; // Aucun coup légal trouvé, pat détecté\n  }\n\n  findKing(color: PieceColor): { x: number; y: number } | null {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece?.type === PieceType.KING && piece.color === color) {\n          return { x, y };\n        }\n      }\n    }\n    return null;\n  }\n\n  public isKing(x: number, y: number): boolean {\n    const piece = this.getPiece(x, y);\n    return piece?.type === PieceType.KING;\n  }\n\n  public isSquareUnderAttack(x: number, y: number, color: PieceColor): boolean {\n    for (let fromY = 0; fromY < 8; fromY++) {\n      for (let fromX = 0; fromX < 8; fromX++) {\n        const piece = this.getPiece(fromX, fromY);\n        if (piece && piece.color !== color) {\n          // Utilise `isThreatenedMove` pour éviter la récursion infinie\n          if (piece.type === PieceType.KING) {\n            if (piece.isThreatenedMove(fromX, fromY, x, y)) {\n              return true;\n            }\n          } else if (piece.isValidMove(fromX, fromY, x, y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Vérifie le matériel insuffisant pour un échec et mat\n  public isInsufficientMaterial(): boolean {\n    const pieces = this.grid.flat().filter((piece) => piece !== null);\n\n    // Cas les plus courants de matériel insuffisant\n    if (pieces.length <= 2) return true; // Seulement les rois sur le plateau\n    return (\n      pieces.length === 3 &&\n      pieces.some(\n        (piece) =>\n          piece?.type === PieceType.BISHOP || piece?.type === PieceType.KNIGHT,\n      )\n    );\n  }\n\n  // Vérifie si la règle des 50 coups est remplie\n  public isFiftyMoveRule(): boolean {\n    return this.halfMoveCount >= 50;\n  }\n\n  public setPiece(x: number, y: number, piece: Piece | null): void {\n    this.grid[y][x] = piece;\n  }\n\n  // Vérifie si un mouvement est valide\n  public isMoveValid(\n    fromRow: number,\n    fromCol: number,\n    toRow: number,\n    toCol: number,\n  ): boolean {\n    const piece = this.getPiece(fromRow, fromCol);\n\n    // Si aucune pièce n'est présente à l'emplacement source, le mouvement est invalide\n    if (!piece) {\n      return false;\n    }\n\n    // Si la destination est en dehors de l'échiquier, mouvement invalide\n    if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) {\n      return false;\n    }\n\n    // Vérifie si la pièce peut se déplacer à cette destination en utilisant la logique de mouvement de la pièce\n    if (!piece.isValidMove(fromRow, fromCol, toRow, toCol, this)) {\n      return false;\n    }\n\n    // Vérifie s'il y a une pièce à la destination et si elle est de la même couleur\n    const destinationPiece = this.getPiece(toRow, toCol);\n    return !(destinationPiece && destinationPiece.color === piece.color);\n  }\n\n  public isCapture(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    const piece = this.isWithinBounds(fromX, fromY)\n      ? this.getPiece(fromX, fromY)\n      : null;\n    const targetPiece = this.isWithinBounds(toX, toY)\n      ? this.getPiece(toX, toY)\n      : null;\n\n    // Vérifie qu'il y a une pièce à la position cible et qu'elle est d'une couleur opposée\n    return (\n      piece !== null &&\n      targetPiece !== null &&\n      piece.color !== targetPiece.color\n    );\n  }\n\n  public static async fromData(data: any): Promise<Board> {\n    const board = new Board();\n    await board.init();\n    board.grid = await Promise.all(\n      data.grid.map(async (row: any[]) =>\n        Promise.all(\n          row.map(async (pieceData) =>\n            pieceData ? await Piece.fromData(pieceData) : null,\n          ),\n        ),\n      ),\n    );\n    return board;\n  }\n\n  public toData(): any {\n    return {\n      grid: this.grid.map((row) =>\n        row.map((piece) => (piece ? piece.toData() : null)),\n      ),\n    };\n  }\n\n  public isAdjacentToAnotherKing(\n    x: number,\n    y: number,\n    color: PieceColor,\n  ): boolean {\n    const kingPositions = [\n      { dx: -1, dy: -1 },\n      { dx: -1, dy: 0 },\n      { dx: -1, dy: 1 },\n      { dx: 0, dy: -1 },\n      { dx: 0, dy: 1 },\n      { dx: 1, dy: -1 },\n      { dx: 1, dy: 0 },\n      { dx: 1, dy: 1 },\n    ];\n\n    for (const { dx, dy } of kingPositions) {\n      const nx = x + dx;\n      const ny = y + dy;\n      const piece = this.isWithinBounds(nx, ny) ? this.getPiece(nx, ny) : null;\n      if (piece?.type === PieceType.KING && piece.color !== color) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public getPieceCount(): number {\n    return this.grid.flat().filter((piece) => piece !== null).length;\n  }\n\n  public setPlayerColor(color: PieceColor): void {\n    this.currentPlayer = color;\n  }\n\n  public getPlayerColor(): PieceColor {\n    return this.currentPlayer;\n  }\n\n  public getCurrentMovesHash(): string {\n    let hash = '';\n\n    for (let y = 0; y < 8; y++) {\n      let emptyCount = 0;\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece) {\n          // If there were empty squares, add their count to the hash\n          if (emptyCount > 0) {\n            hash += emptyCount.toString();\n            emptyCount = 0;\n          }\n          // Use standard FEN notation for pieces\n          const pieceChar = this.getPieceSymbol(piece);\n          hash += pieceChar;\n        } else {\n          // Count empty squares\n          emptyCount++;\n        }\n      }\n      // Add any remaining empty squares in the row\n      if (emptyCount > 0) hash += emptyCount.toString();\n      // Add row separator, except for the last row\n      if (y < 7) hash += '/';\n    }\n\n    // Append the current player's turn\n    hash += ` ${this.currentPlayer === PieceColor.WHITE ? 'w' : 'b'}`;\n\n    return hash;\n  }\n\n  private getPieceSymbol(piece: Piece): string {\n    const symbolMap: { [key in PieceType]: string } = {\n      [PieceType.PAWN]: 'p',\n      [PieceType.ROOK]: 'r',\n      [PieceType.KNIGHT]: 'n', // Use 'n' for knight to avoid confusion with king\n      [PieceType.BISHOP]: 'b',\n      [PieceType.QUEEN]: 'q',\n      [PieceType.KING]: 'k',\n    };\n    // Return the symbol in uppercase for White, lowercase for Black\n    return piece.color === PieceColor.WHITE\n      ? symbolMap[piece.type].toUpperCase()\n      : symbolMap[piece.type];\n  }\n\n  // Méthode toString pour représenter le plateau et état de jeu actuel\n  public toString(): string {\n    let boardString = '';\n\n    // Inclure chaque pièce et sa position sur le plateau\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece) {\n          boardString += `${piece.color[0]}${piece.type[0]}`;\n        } else {\n          boardString += '__'; // Place vide pour chaque case\n        }\n      }\n    }\n\n    // Ajouter l'état d'en passant, demi-coups, et joueur actuel\n    boardString += this.enPassantTarget\n      ? `e${this.enPassantTarget.x}${this.enPassantTarget.y}`\n      : 'e--';\n    boardString += `h${this.halfMoveCount}`;\n    boardString += `p${this.currentPlayer[0]}`;\n\n    return boardString;\n  }\n}\n","// src/evaluator.ts\nimport { Board } from '../board';\nimport { PieceColor, PieceType } from '../piece';\n\n// Valeurs des pièces (évaluation de base)\nexport const pieceValues: { [key in PieceType]: number } = {\n  [PieceType.PAWN]: 1,\n  [PieceType.KNIGHT]: 3,\n  [PieceType.BISHOP]: 3.25,\n  [PieceType.ROOK]: 5,\n  [PieceType.QUEEN]: 9,\n  [PieceType.KING]: 0,\n};\n\n// Tables de positions pour améliorer l'évaluation\nconst pieceSquareTables: { [key in PieceType]: number[][] } = {\n  [PieceType.PAWN]: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n    [0.1, 0.1, 0.2, 0.3, 0.3, 0.2, 0.1, 0.1],\n    [0.05, 0.05, 0.1, 0.25, 0.25, 0.1, 0.05, 0.05],\n    [0, 0, 0, 0.2, 0.2, 0, 0, 0],\n    [0.05, -0.05, -0.1, 0, 0, -0.1, -0.05, 0.05],\n    [0.05, 0.1, 0.1, -0.2, -0.2, 0.1, 0.1, 0.05],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n  ],\n  [PieceType.KNIGHT]: [\n    [-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5],\n    [-0.4, -0.2, 0, 0, 0, 0, -0.2, -0.4],\n    [-0.3, 0, 0.1, 0.15, 0.15, 0.1, 0, -0.3],\n    [-0.3, 0.05, 0.15, 0.2, 0.2, 0.15, 0.05, -0.3],\n    [-0.3, 0, 0.15, 0.2, 0.2, 0.15, 0, -0.3],\n    [-0.3, 0.05, 0.1, 0.15, 0.15, 0.1, 0.05, -0.3],\n    [-0.4, -0.2, 0, 0.05, 0.05, 0, -0.2, -0.4],\n    [-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5],\n  ],\n  [PieceType.BISHOP]: [\n    [-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2],\n    [-0.1, 0, 0, 0, 0, 0, 0, -0.1],\n    [-0.1, 0, 0.05, 0.1, 0.1, 0.05, 0, -0.1],\n    [-0.1, 0.05, 0.05, 0.1, 0.1, 0.05, 0.05, -0.1],\n    [-0.1, 0, 0.1, 0.1, 0.1, 0.1, 0, -0.1],\n    [-0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, -0.1],\n    [-0.1, 0.05, 0, 0, 0, 0, 0.05, -0.1],\n    [-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2],\n  ],\n  [PieceType.ROOK]: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [0, 0, 0, 0.05, 0.05, 0, 0, 0],\n  ],\n  [PieceType.QUEEN]: [\n    [-0.2, -0.1, -0.1, -0.05, -0.05, -0.1, -0.1, -0.2],\n    [-0.1, 0, 0, 0, 0, 0, 0, -0.1],\n    [-0.1, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.1],\n    [-0.05, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.05],\n    [0, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.05],\n    [-0.1, 0.05, 0.05, 0.05, 0.05, 0.05, 0, -0.1],\n    [-0.1, 0, 0.05, 0, 0, 0, 0, -0.1],\n    [-0.2, -0.1, -0.1, -0.05, -0.05, -0.1, -0.1, -0.2],\n  ],\n  [PieceType.KING]: [\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.2, -0.3, -0.3, -0.4, -0.4, -0.3, -0.3, -0.2],\n    [-0.1, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.1],\n    [0.2, 0.2, 0, 0, 0, 0, 0.2, 0.2],\n    [0.2, 0.3, 0, 0, 0, 0, 0.3, 0.2],\n  ],\n};\n\n// Bonus pour le contrôle du centre du plateau (cases centrales plus précieuses)\nexport const centerControlBonus: { [key: string]: number } = {\n  '3,3': 0.5,\n  '3,4': 0.5,\n  '4,3': 0.5,\n  '4,4': 0.5, // Cases centrales\n  '2,3': 0.25,\n  '2,4': 0.25,\n  '3,2': 0.25,\n  '4,2': 0.25,\n  '4,5': 0.25,\n  '3,5': 0.25,\n  '5,3': 0.25,\n  '5,4': 0.25, // Cases autour\n};\n\nexport function evaluateKingSafety(board: Board, color: PieceColor): number {\n  const kingPosition = board.findKing(color);\n  return kingPosition &&\n    board.isSquareUnderAttack(kingPosition.x, kingPosition.y, color)\n    ? -0.5\n    : 0;\n}\n\nfunction getPieceSquareValue(\n  type: PieceType,\n  x: number,\n  y: number,\n  flipBoard: boolean,\n  board: Board,\n  color: PieceColor,\n): number {\n  const table = pieceSquareTables[type];\n  if (!table) return 0;\n\n  // Empêcher les pions isolés de recevoir un bonus de position\n  if (type === PieceType.PAWN) {\n    const isIsolated = checkIsolatedPawns(board, x, y, color) > 0;\n    return isIsolated ? 0 : flipBoard ? table[7 - y][7 - x] : table[y][x];\n  }\n\n  // Retourne la valeur de position pour les autres pièces\n  return flipBoard ? table[7 - y][7 - x] : table[y][x];\n}\n\n// Fonction d'évaluation principale\nexport function evaluateBoard(\n  board: Board,\n  color: PieceColor,\n  flipBoard: boolean = false,\n): number {\n  let score = 0;\n\n  for (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n      const piece = board.getPiece(x, y);\n      const positionKey = `${x},${y}`;\n      if (!piece) continue;\n\n      // Applique la valeur de base et la table de position\n      let pieceScore = pieceValues[piece.type];\n      pieceScore += getPieceSquareValue(\n        piece.type,\n        x,\n        y,\n        flipBoard,\n        board,\n        piece.color,\n      );\n\n      // Ajoute le bonus pour le contrôle du centre\n      if (\n        piece.type === PieceType.PAWN &&\n        checkIsolatedPawns(board, x, y, piece.color) === 0\n      ) {\n        if (centerControlBonus[positionKey]) {\n          pieceScore += centerControlBonus[positionKey];\n        }\n      }\n\n      // Évalue la structure de pions\n      if (piece.type === PieceType.PAWN) {\n        pieceScore += evaluatePawnStructure(board, x, y, piece.color);\n        pieceScore += evaluatePawnChains(board, x, y, piece.color); // Bonus pour chaînes de pions\n        pieceScore += evaluateAdvancedPawnStructure(board, x, y, piece.color); // Heuristique avancée pour structure de pions\n      }\n\n      // Évalue le contrôle des cases clés\n      pieceScore += evaluateKeySquareControl(board, x, y, piece.color);\n\n      // Évalue la sécurité du roi\n      if (piece.type === PieceType.KING) {\n        pieceScore += evaluateKingSafetyAdvanced(board, x, y, piece.color);\n      }\n\n      score += piece.color === color ? pieceScore : -pieceScore;\n    }\n  }\n\n  return parseFloat(score.toFixed(2));\n}\n\nfunction evaluateKeySquareControl(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  let score = 0;\n\n  // Bonus pour contrôler les cases devant les rois\n  const opponentKingPos = board.findKing(\n    color === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE,\n  );\n  if (opponentKingPos) {\n    const dx = Math.abs(opponentKingPos.x - x);\n    const dy = Math.abs(opponentKingPos.y - y);\n    if ((dx <= 1 && dy <= 1) || (dx === 0 && dy <= 2)) {\n      score += 0.5; // Contrôle de la zone proche du roi adverse\n    }\n  }\n\n  const piece = board.getPiece(x, y);\n  if (piece && pieceValues[piece.type] > 3) {\n    if (x === 3 || x === 4 || y === 3 || y === 4) {\n      score += 0.25;\n    }\n  }\n\n  return score;\n}\n\nfunction evaluateKingSafetyAdvanced(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  let score = 0;\n\n  // Facteurs additionnels pour la sécurité du roi\n  const directionOffsets = [\n    { dx: -1, dy: 0 },\n    { dx: 1, dy: 0 },\n    { dx: 0, dy: -1 },\n    { dx: 0, dy: 1 },\n    { dx: -1, dy: -1 },\n    { dx: 1, dy: 1 },\n    { dx: -1, dy: 1 },\n    { dx: 1, dy: -1 },\n  ];\n\n  for (const { dx, dy } of directionOffsets) {\n    const newX = x + dx;\n    const newY = y + dy;\n    if (!board.isWithinBounds(newX, newY)) continue;\n\n    const adjPiece = board.getPiece(newX, newY);\n    if (adjPiece && adjPiece.color !== color) {\n      const distanceFactor = Math.abs(newX - x) + Math.abs(newY - y);\n\n      // Ajoute un malus si le roi est entouré par des pièces ennemies puissantes\n      if (\n        adjPiece.type === PieceType.ROOK ||\n        adjPiece.type === PieceType.QUEEN\n      ) {\n        score -= 0.5 / distanceFactor;\n      }\n    }\n  }\n\n  return score;\n}\n\nfunction evaluateAdvancedPawnStructure(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  let score = 0;\n\n  // Bonus pour pions connectés (même rangée ou colonne) sans obstruction\n  const leftPawn = x > 0 ? board.getPiece(x - 1, y) : null;\n  const rightPawn = x < 7 ? board.getPiece(x + 1, y) : null;\n\n  if (\n    (leftPawn &&\n      leftPawn.color === color &&\n      leftPawn.type === PieceType.PAWN) ||\n    (rightPawn &&\n      rightPawn.color === color &&\n      rightPawn.type === PieceType.PAWN)\n  ) {\n    score += 0.3;\n  }\n\n  return score;\n}\n\n// Fonction pour évaluer les chaînes de pions\nfunction evaluatePawnChains(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  const direction = color === PieceColor.WHITE ? -1 : 1;\n  let score = 0;\n\n  // Vérifie les pions sur les diagonales avant (chaînes protégées)\n  const leftDiagonal = board.getPiece(x - 1, y + direction);\n  const rightDiagonal = board.getPiece(x + 1, y + direction);\n\n  if (\n    (leftDiagonal &&\n      leftDiagonal.color === color &&\n      leftDiagonal.type === PieceType.PAWN) ||\n    (rightDiagonal &&\n      rightDiagonal.color === color &&\n      rightDiagonal.type === PieceType.PAWN)\n  ) {\n    score += 0.5; // Bonus pour les pions protégés dans une chaîne\n  }\n\n  return score;\n}\n\nfunction evaluatePawnStructure(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  let score = 0;\n\n  const isPassed = isPassedPawn(board, x, y, color);\n  const doubledPenalty = checkDoubledPawns(board, x, y, color) * 0.25;\n  const isolatedPenalty = checkIsolatedPawns(board, x, y, color) * 4.0;\n\n  if (isPassed) {\n    score += 4.5; // Bonus pour pion passé\n  }\n\n  score -= doubledPenalty + isolatedPenalty;\n\n  return score;\n}\n\nfunction checkDoubledPawns(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  for (let i = 0; i < 8; i++) {\n    if (\n      i !== y &&\n      board.getPiece(x, i)?.type === PieceType.PAWN &&\n      board.getPiece(x, i)?.color === color\n    ) {\n      return 0.5;\n    }\n  }\n  return 0;\n}\n\nfunction checkIsolatedPawns(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  const leftColumn = x - 1 >= 0 ? board.getPiece(x - 1, y) : null;\n  const rightColumn = x + 1 < 8 ? board.getPiece(x + 1, y) : null;\n\n  const hasAdjacentSameColorPawns =\n    (leftColumn &&\n      leftColumn.type === PieceType.PAWN &&\n      leftColumn.color === color) ||\n    (rightColumn &&\n      rightColumn.type === PieceType.PAWN &&\n      rightColumn.color === color);\n\n  return hasAdjacentSameColorPawns ? 0 : 1.5; // Retourne une pénalité si le pion est isolé\n}\n\nfunction isPassedPawn(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): boolean {\n  const direction = color === PieceColor.WHITE ? 1 : -1;\n\n  // Vérifie s'il y a des pions adverses devant le pion sur la même colonne\n  for (let i = y + direction; i >= 0 && i < 8; i += direction) {\n    const pieceInFront = board.getPiece(x, i);\n    if (\n      pieceInFront &&\n      pieceInFront.type === PieceType.PAWN &&\n      pieceInFront.color !== color\n    ) {\n      return false;\n    }\n  }\n\n  // Vérifie les colonnes adjacentes pour s'assurer qu'il n'y a pas de pions adverses bloquant\n  const adjacentColumns = [x - 1, x + 1];\n  for (const col of adjacentColumns) {\n    if (col >= 0 && col < 8) {\n      for (let i = y + direction; i >= 0 && i < 8; i += direction) {\n        const adjacentPiece = board.getPiece(col, i);\n        if (\n          adjacentPiece &&\n          adjacentPiece.type === PieceType.PAWN &&\n          adjacentPiece.color !== color\n        ) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n","// ai/endgameTablebase.ts\n\nexport class EndgameTablebase {\n  private static endgames: {\n    [key: string]: { fromX: number; fromY: number; toX: number; toY: number };\n  } = {\n    kqkEndgame: { fromX: 7, fromY: 1, toX: 6, toY: 1 }, // Roi + Dame contre Roi\n    krkEndgame: { fromX: 7, fromY: 0, toX: 5, toY: 0 }, // Roi + Tour contre Roi\n    kbbkEndgame: { fromX: 5, fromY: 3, toX: 3, toY: 1 }, // Roi + 2 Fous contre Roi\n    kbnkEndgame: { fromX: 2, fromY: 6, toX: 4, toY: 4 }, // Roi + Fou + Cavalier contre Roi\n    kpEndgame: { fromX: 6, fromY: 5, toX: 6, toY: 6 }, // Roi + Pion contre Roi\n    kppkEndgame: { fromX: 5, fromY: 2, toX: 5, toY: 3 }, // Roi + 2 Pions contre Roi\n    krkpEndgame: { fromX: 6, fromY: 0, toX: 6, toY: 1 }, // Roi + Tour contre Roi + Pion\n    kqkrEndgame: { fromX: 7, fromY: 2, toX: 6, toY: 2 }, // Roi + Dame contre Roi + Tour\n    kbkpEndgame: { fromX: 3, fromY: 3, toX: 4, toY: 2 }, // Roi + Fou contre Roi + Pion\n    krrkEndgame: { fromX: 7, fromY: 4, toX: 5, toY: 4 }, // Roi + 2 Tours contre Roi\n  };\n\n  static getEndgameMove(\n    positionKey: string,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    return this.endgames[positionKey] || null;\n  }\n}\n","export class OpeningBook {\n  private static openings: {\n    [key: string]: { fromX: number; fromY: number; toX: number; toY: number }[];\n  } = {\n    'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w': [\n      { fromX: 1, fromY: 7, toX: 3, toY: 7 }, // King's pawn opening (1. e4)\n      { fromX: 6, fromY: 7, toX: 5, toY: 5 }, // Queen's pawn opening (1. d4)\n    ],\n    'rnbqkbnr/pppppppp/8/8/8/8/PPP1PPPP/RNBQKBNR w': [\n      { fromX: 2, fromY: 7, toX: 4, toY: 7 }, // English opening (1. c4)\n      { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // Queen's gambit (1. d4 d5 2. c4)\n    ],\n    'rnbqkbnr/pppppp1p/8/8/8/8/PPPP1PPP/RNBQKBNR w': [\n      { fromX: 4, fromY: 7, toX: 4, toY: 5 }, // Sicilian defense (1. e4 c5)\n    ],\n    'rnbqkbnr/ppp1pppp/8/8/8/8/PPP1PPPP/RNBQKBNR w': [\n      { fromX: 5, fromY: 6, toX: 4, toY: 4 }, // French defense (1. e4 e6)\n    ],\n    'rnbqkbnr/pppppppp/8/8/8/8/PP1PPPPP/RNBQKBNR w': [\n      { fromX: 4, fromY: 7, toX: 4, toY: 5 }, // Alekhine's defense (1. e4 Nf6)\n    ],\n    'rnbqkbnr/pppppppp/8/8/8/8/PPPP1PPP/RNBQKBNR w': [\n      { fromX: 6, fromY: 6, toX: 6, toY: 4 }, // Modern defense (1. e4 g6)\n    ],\n  };\n\n  static getOpeningMove(\n    positionKey: string,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    const moves = this.openings[positionKey];\n    if (moves && moves.length > 0) {\n      // Select a random move from the list for variety\n      return moves[Math.floor(Math.random() * moves.length)];\n    }\n    return null;\n  }\n}\n","export class GamesAnalyzer {\n  private gamePatterns: Map<\n    string,\n    { move: string; successRate: number; games: number }[]\n  > = new Map();\n\n  async loadGamesData() {\n    const response = await fetch('/chess-game/games.json');\n    const gamesData: { Moves: string[]; Result: string }[] =\n      await response.json();\n    this.loadGames(gamesData);\n  }\n\n  private loadGames(gamesData: { Moves: string[]; Result: string }[]) {\n    gamesData.forEach((game) => {\n      const moves = game.Moves;\n      const result = game.Result;\n\n      let currentPosition = ''; // Initial key for board state\n      moves.forEach((move) => {\n        if (!this.gamePatterns.has(currentPosition)) {\n          this.gamePatterns.set(currentPosition, []);\n        }\n\n        const moveData = this.gamePatterns.get(currentPosition);\n        const success = result === '1-0' ? 1 : result === '0-1' ? 0 : 0.5;\n        const existingMove = moveData!.find((data) => data.move === move);\n\n        if (existingMove) {\n          existingMove.successRate =\n            (existingMove.successRate * existingMove.games + success) /\n            (existingMove.games + 1);\n          existingMove.games += 1;\n        } else {\n          moveData!.push({ move, successRate: success, games: 1 });\n        }\n\n        // Update current position by appending the move\n        currentPosition += move + ' ';\n      });\n    });\n  }\n\n  getBestMove(position: string): string | null {\n    const movesData = this.gamePatterns.get(position);\n    if (!movesData || movesData.length === 0) return null;\n\n    movesData.sort((a, b) => b.successRate - a.successRate);\n    return movesData[0].move;\n  }\n}\n","// src/ai/contextualMoveDatabase.ts\nexport class ContextualMoveDatabase {\n  private moveData: Map<\n    string,\n    {\n      move: { fromX: number; fromY: number; toX: number; toY: number };\n      count: number;\n    }[]\n  > = new Map();\n\n  // Ajoute un mouvement dans la base de données pour la clé de position\n  public recordMove(\n    positionKey: string,\n    move: { fromX: number; fromY: number; toX: number; toY: number },\n  ): void {\n    const moves = this.moveData.get(positionKey) || [];\n    const existingMove = moves.find(\n      (m) =>\n        m.move.fromX === move.fromX &&\n        m.move.fromY === move.fromY &&\n        m.move.toX === move.toX &&\n        m.move.toY === move.toY,\n    );\n\n    if (existingMove) {\n      existingMove.count++;\n    } else {\n      moves.push({ move, count: 1 });\n    }\n\n    this.moveData.set(positionKey, moves);\n  }\n\n  // Récupère les mouvements triés par fréquence pour une clé de position donnée\n  public getMovesByFrequency(positionKey: string): {\n    move: { fromX: number; fromY: number; toX: number; toY: number };\n    count: number;\n  }[] {\n    return (this.moveData.get(positionKey) || []).sort(\n      (a, b) => b.count - a.count,\n    );\n  }\n}\n","// src/ai.ts\nimport { Board } from './board';\nimport { Piece, PieceColor, PieceType } from './piece';\nimport {\n  centerControlBonus,\n  evaluateBoard,\n  evaluateKingSafety,\n  pieceValues,\n} from './ai/evaluator';\nimport { EndgameTablebase } from './ai/endgameTablebase';\nimport { OpeningBook } from './ai/openingBook';\nimport { GamesAnalyzer } from './ai/gamesAnalyzer';\nimport { ContextualMoveDatabase } from './ai/contextualMoveDatabase';\n\n// Classe AI utilisant l'algorithme Minimax avec Alpha-Beta Pruning et Transposition Table\nexport class AI {\n  private readonly transpositionTable: Map<\n    string,\n    { value: number; depth: number }\n  >; // Table de transposition avec profondeur\n  private readonly maxTime: number;\n  private startTime: number;\n  private readonly killerMoves: Map<\n    number,\n    {\n      move: { fromX: number; fromY: number; toX: number; toY: number };\n      score: number;\n    }[]\n  >;\n  private moveHistory: {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n  }[] = [];\n  private readonly historicalMoveScores: Map<string, number> = new Map();\n  private gamesAnalyzer: GamesAnalyzer;\n  private gamesLoaded: boolean = false;\n  private contextualMoveDatabase: ContextualMoveDatabase;\n\n  constructor(\n    private readonly color: PieceColor,\n    maxTime: number = 60000,\n  ) {\n    this.transpositionTable = new Map();\n    this.maxTime = maxTime;\n    this.killerMoves = new Map();\n    this.startTime = 0;\n    this.gamesAnalyzer = new GamesAnalyzer();\n    this.contextualMoveDatabase = new ContextualMoveDatabase();\n  }\n\n  async loadGamesData() {\n    await this.gamesAnalyzer.loadGamesData();\n    this.gamesLoaded = true;\n  }\n\n  private recordMoveInContextualDatabase(\n    positionKey: string,\n    move: { fromX: number; fromY: number; toX: number; toY: number },\n  ): void {\n    this.contextualMoveDatabase.recordMove(positionKey, move);\n  }\n\n  public makeMove(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    if (!this.gamesLoaded) {\n      throw new Error('Games data not loaded. Call loadGamesData() first.');\n    }\n\n    this.startTime = Date.now();\n    this.maxTime = Math.floor(Math.random() * (50000 - 5000 + 1)) + 5000;\n\n    const openingMove = this.getOpeningMove(board);\n    if (\n      openingMove &&\n      typeof openingMove === 'object' &&\n      'fromX' in openingMove &&\n      'fromY' in openingMove &&\n      'toX' in openingMove &&\n      'toY' in openingMove\n    ) {\n      this.moveHistory.push(openingMove);\n      this.recordMoveInContextualDatabase(\n        this.getPositionKey(board),\n        openingMove,\n      ); // Enregistrement du mouvement\n      return openingMove;\n    }\n\n    const endgameMove = this.useEndgameTablebase(board);\n    if (\n      endgameMove &&\n      typeof endgameMove === 'object' &&\n      'fromX' in endgameMove &&\n      'fromY' in endgameMove &&\n      'toX' in endgameMove &&\n      'toY' in endgameMove\n    ) {\n      this.moveHistory.push(endgameMove);\n      this.recordMoveInContextualDatabase(\n        this.getPositionKey(board),\n        endgameMove,\n      ); // Enregistrement du mouvement\n      return endgameMove;\n    }\n\n    const positionKey = this.getPositionKey(board);\n    const analyzedMove = this.getAnalyzedMove(positionKey);\n    if (\n      analyzedMove &&\n      typeof analyzedMove === 'object' &&\n      'fromX' in analyzedMove &&\n      'fromY' in analyzedMove &&\n      'toX' in analyzedMove &&\n      'toY' in analyzedMove\n    ) {\n      this.moveHistory.push(analyzedMove);\n      this.recordMoveInContextualDatabase(positionKey, analyzedMove); // Enregistrement du mouvement\n      return analyzedMove;\n    }\n\n    const bestMove = this.getBestMoveUsingMinimax(board);\n    if (\n      bestMove &&\n      typeof bestMove === 'object' &&\n      'fromX' in bestMove &&\n      'fromY' in bestMove &&\n      'toX' in bestMove &&\n      'toY' in bestMove\n    ) {\n      this.moveHistory.push(bestMove);\n      this.recordMoveInContextualDatabase(positionKey, bestMove); // Enregistrement du mouvement\n      return bestMove;\n    }\n\n    return null;\n  }\n\n  private getOpeningMove(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    const boardHash = board.getCurrentMovesHash();\n    const openingMove = OpeningBook.getOpeningMove(boardHash);\n\n    return openingMove ? this.flipMoveIfBlack(openingMove) : null;\n  }\n\n  private flipMoveIfBlack(move: {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n  }): { fromX: number; fromY: number; toX: number; toY: number } {\n    if (this.color === PieceColor.BLACK) {\n      return {\n        fromX: 7 - move.fromX,\n        fromY: 7 - move.fromY,\n        toX: 7 - move.toX,\n        toY: 7 - move.toY,\n      };\n    }\n    return move;\n  }\n\n  private minimax(\n    board: Board,\n    depth: number,\n    alpha: number,\n    beta: number,\n    isMaximizing: boolean,\n    multiCutThreshold: number = 2,\n    multiCutDepth: number = 3,\n    probCutFactor: number = 0.9,\n    aspirationDelta: number = 25,\n  ): number {\n    const phase = this.determineGamePhase(board);\n    const boardKey = `${board.toString()}|${depth}|${phase}`;\n\n    if (Date.now() - this.startTime > this.maxTime) {\n      return this.evaluatePositionWithKingSafety(board, this.color);\n    }\n\n    // Vérification de la table de transposition\n    if (this.transpositionTable.has(boardKey)) {\n      const { value, depth: storedDepth } =\n        this.transpositionTable.get(boardKey)!;\n      if (storedDepth >= depth) return value;\n    }\n\n    // Condition de fin de recherche\n    if (\n      depth === 0 ||\n      board.isCheckmate(this.color) ||\n      board.isCheckmate(this.getOpponentColor())\n    ) {\n      const evaluation = this.quiescenceSearch(board, alpha, beta, phase);\n      this.transpositionTable.set(boardKey, { value: evaluation, depth });\n      return evaluation;\n    }\n\n    // Aspiration Window\n    let evalGuess = this.evaluatePositionWithKingSafety(board, this.color);\n    let localAlpha = evalGuess - aspirationDelta;\n    let localBeta = evalGuess + aspirationDelta;\n    let result: number;\n\n    while (true) {\n      result = this.alphaBetaWithAspirationWindow(\n        board,\n        depth,\n        localAlpha,\n        localBeta,\n        isMaximizing,\n        multiCutThreshold,\n        multiCutDepth,\n        probCutFactor,\n      );\n\n      // Si le résultat est hors de la fenêtre, on l'élargit et on recommence\n      if (result <= localAlpha) {\n        localAlpha -= aspirationDelta; // Elargir en dessous\n      } else if (result >= localBeta) {\n        localBeta += aspirationDelta; // Elargir au-dessus\n      } else {\n        break; // Si le résultat est dans la fenêtre, on le garde\n      }\n    }\n\n    this.transpositionTable.set(boardKey, { value: result, depth });\n    return result;\n  }\n\n  private alphaBetaWithAspirationWindow(\n    board: Board,\n    depth: number,\n    alpha: number,\n    beta: number,\n    isMaximizing: boolean,\n    multiCutThreshold: number,\n    multiCutDepth: number,\n    probCutFactor: number,\n  ): number {\n    if (Date.now() - this.startTime > this.maxTime) return alpha;\n\n    let bestEval = isMaximizing ? -Infinity : Infinity;\n    let moves = this.getAllValidMoves(board);\n    moves = this.sortMoves(moves, board, depth, this.determineGamePhase(board));\n\n    let cutCount = 0;\n\n    for (const move of moves) {\n      const fromPiece = board.getPiece(move.fromX, move.fromY);\n      const toPiece = board.getPiece(move.toX, move.toY);\n\n      board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n      let evaluation: number;\n\n      // Multi-Cut Pruning combiné avec ProbCut\n      if (depth >= multiCutDepth && cutCount < multiCutThreshold) {\n        evaluation = -this.minimax(\n          board,\n          depth - multiCutDepth,\n          -beta,\n          -alpha,\n          !isMaximizing,\n          multiCutThreshold,\n          multiCutDepth,\n          probCutFactor,\n        );\n        if (evaluation <= alpha) {\n          cutCount++;\n          board.setPiece(move.fromX, move.fromY, fromPiece);\n          board.setPiece(move.toX, move.toY, toPiece);\n          continue;\n        }\n      }\n\n      evaluation = this.minimax(\n        board,\n        depth - 1,\n        alpha,\n        beta,\n        !isMaximizing,\n        multiCutThreshold,\n        multiCutDepth,\n        probCutFactor,\n      );\n\n      board.setPiece(move.fromX, move.fromY, fromPiece);\n      board.setPiece(move.toX, move.toY, toPiece);\n\n      if (isMaximizing) {\n        if (evaluation > bestEval) {\n          bestEval = evaluation;\n          this.updateHistoricalMoveScore(move);\n          this.addKillerMove(depth, move);\n        }\n        alpha = Math.max(alpha, evaluation);\n      } else {\n        if (evaluation < bestEval) {\n          bestEval = evaluation;\n          this.updateHistoricalMoveScore(move);\n          this.addKillerMove(depth, move);\n        }\n        beta = Math.min(beta, evaluation);\n      }\n\n      if (beta <= alpha) break;\n    }\n\n    return bestEval;\n  }\n\n  private determineGamePhase(board: Board): 'opening' | 'midgame' | 'endgame' {\n    const pieceCount = board.getPieceCount();\n    if (pieceCount > 24) return 'opening';\n    if (pieceCount > 12) return 'midgame';\n    return 'endgame';\n  }\n\n  private addKillerMove(\n    depth: number,\n    move: { fromX: number; fromY: number; toX: number; toY: number },\n  ) {\n    const killers = this.killerMoves.get(depth) ?? [];\n    const moveKey = `${move.fromX},${move.fromY},${move.toX},${move.toY}`;\n\n    // Augmenter le score des killer moves pour ce mouvement\n    let existingMove = killers.find(\n      (k) =>\n        `${k.move.fromX},${k.move.fromY},${k.move.toX},${k.move.toY}` ===\n        moveKey,\n    );\n    if (existingMove) {\n      existingMove.score += 10;\n    } else {\n      killers.push({ move, score: 10 });\n    }\n\n    // Trier par score et limiter le nombre de killer moves par profondeur\n    this.killerMoves.set(\n      depth,\n      killers.sort((a, b) => b.score - a.score).slice(0, 2),\n    );\n  }\n\n  private updateHistoricalMoveScore(move: {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n  }) {\n    const moveKey = `${move.fromX},${move.fromY},${move.toX},${move.toY}`;\n    const currentScore = this.historicalMoveScores.get(moveKey) || 0;\n    this.historicalMoveScores.set(moveKey, currentScore + 1);\n  }\n\n  private quiescenceSearch(\n    board: Board,\n    alpha: number,\n    beta: number,\n    phase: 'opening' | 'midgame' | 'endgame',\n    depth: number = 0,\n  ): number {\n    const maxQuiescenceDepth = this.getAdaptiveQuiescenceDepth(board);\n    if (depth >= maxQuiescenceDepth) {\n      return evaluateBoard(board, this.color);\n    }\n\n    const standPat = evaluateBoard(board, this.color);\n    if (standPat >= beta) return beta;\n    if (alpha < standPat) alpha = standPat;\n\n    const moves = this.getAllValidMoves(board).filter((move) =>\n      board.isCapture(move.fromX, move.fromY, move.toX, move.toY),\n    );\n\n    for (const move of moves) {\n      const fromPiece = board.getPiece(move.fromX, move.fromY);\n      const toPiece = board.getPiece(move.toX, move.toY);\n\n      board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n      let score = -this.quiescenceSearch(\n        board,\n        -beta,\n        -alpha,\n        phase,\n        depth + 1,\n      );\n\n      // En fin de partie, accorder plus d'importance aux captures critiques\n      if (phase === 'endgame' && this.isCriticalMove(fromPiece!, move, board)) {\n        score += 20;\n      }\n\n      board.setPiece(move.fromX, move.fromY, fromPiece);\n      board.setPiece(move.toX, move.toY, toPiece);\n\n      if (score >= beta) return beta;\n      if (score > alpha) alpha = score;\n    }\n\n    return alpha;\n  }\n\n  private getOpponentColor(): PieceColor {\n    return this.color === PieceColor.WHITE\n      ? PieceColor.BLACK\n      : PieceColor.WHITE;\n  }\n\n  private getAllValidMoves(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number }[] {\n    const validMoves = [];\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = board.getPiece(x, y);\n        if (piece && piece.color === this.color) {\n          const moves = board.getValidMoves(x, y);\n          for (const move of moves) {\n            if (board.isMoveValid(x, y, move.x, move.y)) {\n              const originalPiece = board.getPiece(move.x, move.y);\n              board.setPiece(move.x, move.y, piece);\n              board.setPiece(x, y, null);\n\n              const kingSafe = !board.isKingInCheck(this.color);\n\n              board.setPiece(x, y, piece);\n              board.setPiece(move.x, move.y, originalPiece);\n\n              if (kingSafe) {\n                validMoves.push({\n                  fromX: x,\n                  fromY: y,\n                  toX: move.x,\n                  toY: move.y,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n    return validMoves;\n  }\n\n  private sortMoves(\n    moves: { fromX: number; fromY: number; toX: number; toY: number }[],\n    board: Board,\n    depth: number,\n    phase: 'opening' | 'midgame' | 'endgame',\n  ): { fromX: number; fromY: number; toX: number; toY: number }[] {\n    const positionKey = this.getPositionKey(board);\n    const contextualMoves =\n      this.contextualMoveDatabase.getMovesByFrequency(positionKey);\n\n    return moves.sort((a, b) => {\n      const pieceA = board.getPiece(a.toX, a.toY);\n      const pieceB = board.getPiece(b.toX, b.toY);\n\n      const valueA = pieceA ? pieceValues[pieceA.type] : 0;\n      const valueB = pieceB ? pieceValues[pieceB.type] : 0;\n\n      // Prioriser les mouvements contextuels basés sur les données\n      const moveAContextScore = contextualMoves.findIndex(\n        (m) =>\n          m.move.fromX === a.fromX &&\n          m.move.fromY === a.fromY &&\n          m.move.toX === a.toX &&\n          m.move.toY === a.toY,\n      );\n      const moveBContextScore = contextualMoves.findIndex(\n        (m) =>\n          m.move.fromX === b.fromX &&\n          m.move.fromY === b.fromY &&\n          m.move.toX === b.toX &&\n          m.move.toY === b.toY,\n      );\n\n      // Prioriser les mouvements qui apparaissent plus fréquemment\n      if (moveAContextScore !== -1 || moveBContextScore !== -1) {\n        return (\n          (moveAContextScore !== -1 ? moveAContextScore : Infinity) -\n          (moveBContextScore !== -1 ? moveBContextScore : Infinity)\n        );\n      }\n\n      if (phase === 'opening') {\n        const centerControlA = centerControlBonus[`${a.toX},${a.toY}`] || 0;\n        const centerControlB = centerControlBonus[`${b.toX},${b.toY}`] || 0;\n        if (centerControlA !== centerControlB)\n          return centerControlB - centerControlA;\n      } else if (phase === 'endgame') {\n        if (pieceA && pieceA.type === PieceType.PAWN && a.toY === 7) return -1;\n        if (pieceB && pieceB.type === PieceType.PAWN && b.toY === 7) return 1;\n      }\n\n      if (valueA !== valueB) return valueB - valueA;\n\n      const killerMovesAtDepth = this.killerMoves.get(depth);\n      if (\n        killerMovesAtDepth &&\n        killerMovesAtDepth.some(\n          (km) =>\n            km.move.fromX === a.fromX &&\n            km.move.fromY === a.fromY &&\n            km.move.toX === a.toX &&\n            km.move.toY === a.toY,\n        )\n      ) {\n        return -1;\n      }\n\n      const scoreA =\n        this.historicalMoveScores.get(\n          `${a.fromX},${a.fromY},${a.toX},${a.toY}`,\n        ) || 0;\n      const scoreB =\n        this.historicalMoveScores.get(\n          `${b.fromX},${b.fromY},${b.toX},${b.toY}`,\n        ) || 0;\n\n      return scoreB - scoreA;\n    });\n  }\n\n  private getAdaptiveQuiescenceDepth(board: Board): number {\n    const pieceCount = board.getPieceCount();\n    if (pieceCount <= 6) return 7;\n    if (pieceCount <= 12) return 5;\n    return 3;\n  }\n\n  private evaluatePositionWithKingSafety(\n    board: Board,\n    color: PieceColor,\n  ): number {\n    let score = evaluateBoard(board, color);\n    const kingSafety = evaluateKingSafety(board, color);\n    score += kingSafety;\n    return score;\n  }\n\n  private useEndgameTablebase(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    if (board.getPieceCount() <= 5) {\n      const positionKey = board.getCurrentMovesHash();\n      const endgameMove = EndgameTablebase.getEndgameMove(positionKey);\n      return endgameMove ? this.flipMoveIfBlack(endgameMove) : null;\n    }\n    return null;\n  }\n\n  // Fonction pour identifier les mouvements critiques\n  private isCriticalMove(\n    piece: Piece,\n    move: { fromX: number; fromY: number; toX: number; toY: number },\n    board: Board,\n  ): boolean {\n    const targetPiece = board.getPiece(move.toX, move.toY);\n    return <boolean>(\n      (targetPiece &&\n        targetPiece.color !== piece.color &&\n        targetPiece.type !== PieceType.PAWN)\n    );\n  }\n\n  private getPositionKey(board: Board): string {\n    return board.getCurrentMovesHash();\n  }\n\n  private convertMoveToCoords(move: string): {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n  } {\n    const [fromX, fromY, toX, toY] = move.match(/\\d+/g)!.map(Number);\n    return { fromX, fromY, toX, toY };\n  }\n\n  private getAnalyzedMove(\n    position: string,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    const bestMove = this.gamesAnalyzer.getBestMove(position);\n    return bestMove ? this.convertMoveToCoords(bestMove) : null;\n  }\n\n  private getBestMoveUsingMinimax(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    let bestMove = null;\n    let bestValue = -Infinity;\n    const maxDepth = 16;\n    const phase = this.determineGamePhase(board);\n    const THRESHOLD_VALUE = 600;\n\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      if (Date.now() - this.startTime > this.maxTime) break;\n\n      let moves = this.getAllValidMoves(board);\n      moves = this.sortMoves(moves, board, depth, phase);\n\n      for (const move of moves) {\n        if (Date.now() - this.startTime > this.maxTime) return bestMove;\n\n        const piece = board.getPiece(move.fromX, move.fromY);\n        if (!piece) continue;\n        const originalPiece = board.getPiece(move.toX, move.toY);\n\n        board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n        const isCritical =\n          board.isKingInCheck(this.color) ||\n          this.isCriticalMove(piece, move, board);\n        const adjustedDepth = isCritical ? depth + 1 : depth;\n\n        // Fenêtre nulle pour les mouvements de type \"killer\"\n        const boardValue = this.minimax(\n          board,\n          adjustedDepth - 1,\n          -bestValue,\n          -Infinity,\n          false,\n        );\n\n        board.setPiece(move.fromX, move.fromY, piece);\n        board.setPiece(move.toX, move.toY, originalPiece);\n\n        if (-boardValue > bestValue) {\n          bestValue = -boardValue;\n          bestMove = move;\n\n          if (bestValue >= THRESHOLD_VALUE) return bestMove;\n        }\n\n        if (Date.now() - this.startTime > this.maxTime) {\n          return bestMove;\n        }\n      }\n\n      if (Date.now() - this.startTime > this.maxTime) {\n        break;\n      }\n    }\n\n    return bestMove;\n  }\n}\n","// src/pieces/pawn.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\n\nexport class Pawn extends Piece {\n  public hasMoved: boolean = false;\n  private _toX: number | null = null;\n  private _toY: number | null = null;\n  private _board: BoardInterface | null = null;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.PAWN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    if (toX < 0 || toX >= 8 || toY < 0 || toY >= 8) {\n      return false;\n    }\n\n    const playerColor = board.getPlayerColor();\n    const direction = this.color === PieceColor.WHITE ? 1 : -1;\n    const startRow = this.color === PieceColor.WHITE ? 1 : 6;\n    const distanceY = (toY - fromY) * direction;\n    const distanceX = Math.abs(toX - fromX);\n\n    const promotionRow = playerColor === PieceColor.WHITE ? 7 : 0;\n\n    if (distanceX === 0 && distanceY === 1 && !board.getPiece(toX, toY)) {\n      // Vérifie la rangée de promotion et déclenche la promotion uniquement à cette rangée\n      if (toY === promotionRow) {\n        return this.handlePromotion(toX, toY, board);\n      }\n      return true;\n    }\n\n    if (distanceX === 1 && distanceY === 1) {\n      if (board.getPiece(toX, toY) && this.canCapture(toX, toY, board)) {\n        if (toY === promotionRow) {\n          return this.handlePromotion(toX, toY, board);\n        }\n        return true;\n      }\n\n      // Capture en passant\n      if (board.isEnPassantMove(fromX, fromY, toX, toY)) {\n        board.captureEnPassantIfValid(fromX, fromY, toX, toY);\n        return true;\n      }\n    }\n\n    if (\n      distanceX === 0 &&\n      distanceY === 2 &&\n      fromY === startRow &&\n      !board.getPiece(toX, toY) &&\n      !board.getPiece(fromX, fromY + direction)\n    ) {\n      board.updateEnPassantTarget(fromX, fromY, toX, toY, this);\n      this.hasMoved = true; // Marque que le pion a bougé\n      return true;\n    }\n\n    return false;\n  }\n\n  handlePromotion(toX: number, toY: number, board: BoardInterface): boolean {\n    this._toX = toX;\n    this._toY = toY;\n    this._board = board;\n    return true;\n  }\n}\n","// ai.worker.ts\nimport { Board } from './board';\nimport { AI } from './ai';\nimport { PieceColor, PieceType } from './piece';\nimport { Pawn } from './pieces/pawn';\n\nlet ai: AI;\n\nself.onmessage = async (event) => {\n  const { boardData, aiColor } = event.data;\n\n  // Initialisez `ai` ici, après avoir reçu `aiColor`\n  ai = new AI(aiColor);\n\n  // Charge les données JSON avant de continuer\n  await ai.loadGamesData();\n\n  const board = await Board.fromData(boardData);\n  const bestMove = ai.makeMove(board);\n\n  // Définit explicitement le type de captureData\n  let captureData: {\n    capturedWhite: PieceType[];\n    capturedBlack: PieceType[];\n  } | null = null;\n\n  // Vérifie si une capture est effectuée\n  if (\n    bestMove &&\n    board.isCapture(bestMove.fromX, bestMove.fromY, bestMove.toX, bestMove.toY)\n  ) {\n    const targetPiece = board.getPiece(bestMove.toX, bestMove.toY);\n    if (targetPiece) {\n      captureData = {\n        capturedWhite: [],\n        capturedBlack: [],\n      };\n      if (targetPiece.color === PieceColor.WHITE) {\n        captureData.capturedWhite.push(targetPiece.type);\n      } else {\n        captureData.capturedBlack.push(targetPiece.type);\n      }\n    }\n  }\n\n  // Vérifie si une promotion est nécessaire pour un pion\n  let promotionRequired = false;\n  if (\n    bestMove &&\n    board.getPiece(bestMove.fromX, bestMove.fromY)?.type === PieceType.PAWN\n  ) {\n    const piece = board.getPiece(bestMove.fromX, bestMove.fromY);\n    if (piece instanceof Pawn) {\n      const promotionRow = aiColor === PieceColor.WHITE ? 7 : 0;\n      // Vérifie si la pièce est un pion\n      if (bestMove.toY === promotionRow) {\n        promotionRequired = piece.handlePromotion(\n          bestMove.toX,\n          bestMove.toY,\n          board,\n        );\n      }\n    }\n  }\n\n  self.postMessage({ bestMove, captureData, promotionRequired });\n};\n"],"names":["createPiece","type","color","PieceType","Pawn","pawn","Rook","Knight","Bishop","Queen","King","PieceColor","Piece","fromX","fromY","toX","toY","board","dx","dy","x","y","piece","targetPiece","data","capturedWhite","capturedBlack","getPieceSymbol","updateCapturedPieces","pieceSymbol","updateCapturedPiecesDOM","capturedWhiteElement","capturedBlackElement","Board","validMoves","movingPawn","capturedPawnY","isSimulation","opponentColor","king","direction","rookX","rook","kingX","kingY","capturedPawn","captureData","pieceType","kingPosition","moves","move","originalPiece","kingSafe","isKingSafe","pieces","fromRow","fromCol","toRow","toCol","destinationPiece","row","pieceData","kingPositions","nx","ny","hash","emptyCount","pieceChar","symbolMap","boardString","pieceValues","pieceSquareTables","centerControlBonus","evaluateKingSafety","getPieceSquareValue","flipBoard","table","checkIsolatedPawns","evaluateBoard","score","positionKey","pieceScore","evaluatePawnStructure","evaluatePawnChains","evaluateAdvancedPawnStructure","evaluateKeySquareControl","evaluateKingSafetyAdvanced","opponentKingPos","directionOffsets","newX","newY","adjPiece","distanceFactor","leftPawn","rightPawn","leftDiagonal","rightDiagonal","isPassed","isPassedPawn","doubledPenalty","checkDoubledPawns","isolatedPenalty","i","leftColumn","rightColumn","pieceInFront","adjacentColumns","col","adjacentPiece","EndgameTablebase","OpeningBook","GamesAnalyzer","gamesData","game","result","currentPosition","moveData","success","existingMove","position","movesData","a","b","ContextualMoveDatabase","m","AI","maxTime","openingMove","endgameMove","analyzedMove","bestMove","boardHash","depth","alpha","beta","isMaximizing","multiCutThreshold","multiCutDepth","probCutFactor","aspirationDelta","phase","boardKey","value","storedDepth","evaluation","evalGuess","localAlpha","localBeta","bestEval","cutCount","fromPiece","toPiece","pieceCount","killers","moveKey","k","currentScore","maxQuiescenceDepth","standPat","contextualMoves","pieceA","pieceB","valueA","valueB","moveAContextScore","moveBContextScore","centerControlA","centerControlB","killerMovesAtDepth","km","scoreA","kingSafety","bestValue","maxDepth","THRESHOLD_VALUE","adjustedDepth","boardValue","playerColor","startRow","distanceY","distanceX","promotionRow","ai","event","boardData","aiColor","promotionRequired"],"mappings":"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"}