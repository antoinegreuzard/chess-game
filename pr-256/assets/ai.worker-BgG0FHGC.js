async function P(u,e){switch(u){case a.PAWN:const{Pawn:t}=await Promise.resolve().then(function(){return J});return new t(e);case a.ROOK:const{Rook:i}=await import("./rook-GBxe4k91.js");return new i(e);case a.KNIGHT:const{Knight:s}=await import("./knight-B6iUi-uy.js");return new s(e);case a.BISHOP:const{Bishop:n}=await import("./bishop-De69I4ga.js");return new n(e);case a.QUEEN:const{Queen:o}=await import("./queen-CjP6BtYr.js");return new o(e);case a.KING:const{King:r}=await import("./king-CrMt0FOe.js");return new r(e);default:throw new Error(`Type de pièce inconnu : ${u}`)}}var f=(u=>(u.WHITE="white",u.BLACK="black",u))(f||{}),a=(u=>(u.PAWN="pawn",u.ROOK="rook",u.KNIGHT="knight",u.BISHOP="bishop",u.QUEEN="queen",u.KING="king",u))(a||{});class N{constructor(e,t){this.color=e,this.type=t}hasMoved=!1;isPathClear(e,t,i,s,n){const o=Math.sign(i-e),r=Math.sign(s-t);let c=e+o,l=t+r;for(;c!==i||l!==s;){if(n.getPiece(c,l)!==null)return!1;c+=o,l+=r}return!0}static isKing(e){return e.type==="king"}canCapture(e,t,i){const s=i.getPiece(e,t);return!s||s.color!==this.color}toData(){return{color:this.color,type:this.type}}static async fromData(e){return await P(e.type,e.color)}isThreatenedMove(e,t,i,s){const n=Math.abs(i-e),o=Math.abs(s-t);return n<=1&&o<=1}}let B=[],k=[];function X(u,e){switch(u){case a.PAWN:return e===f.WHITE?"♙":"♟";case a.ROOK:return e===f.WHITE?"♖":"♜";case a.KNIGHT:return e===f.WHITE?"♘":"♞";case a.BISHOP:return e===f.WHITE?"♗":"♝";case a.QUEEN:return e===f.WHITE?"♕":"♛";case a.KING:return e===f.WHITE?"♔":"♚";default:return""}}function Y(u,e){const t=X(u,e);e===f.WHITE?B.push(t):k.push(t),S()}function S(){const u=document.getElementById("capturedWhite"),e=document.getElementById("capturedBlack");u&&(u.textContent=B.join(" ")),e&&(e.textContent=k.join(" "))}class W{grid;enPassantTarget=null;halfMoveCount=0;currentPlayer=f.WHITE;constructor(){this.grid=Array(8).fill(null).map(()=>Array(8).fill(null))}async init(){this.grid=await this.initializeBoard()}async initializeBoard(){const e=Array(8).fill(null).map(()=>Array(8).fill(null));return e[0]=[await P(a.ROOK,f.WHITE),await P(a.KNIGHT,f.WHITE),await P(a.BISHOP,f.WHITE),await P(a.QUEEN,f.WHITE),await P(a.KING,f.WHITE),await P(a.BISHOP,f.WHITE),await P(a.KNIGHT,f.WHITE),await P(a.ROOK,f.WHITE)],e[1]=await Promise.all(Array(8).fill(null).map(()=>P(a.PAWN,f.WHITE))),e[7]=[await P(a.ROOK,f.BLACK),await P(a.KNIGHT,f.BLACK),await P(a.BISHOP,f.BLACK),await P(a.QUEEN,f.BLACK),await P(a.KING,f.BLACK),await P(a.BISHOP,f.BLACK),await P(a.KNIGHT,f.BLACK),await P(a.ROOK,f.BLACK)],e[6]=await Promise.all(Array(8).fill(null).map(()=>P(a.PAWN,f.BLACK))),e}isWithinBounds(e,t){return e>=0&&e<8&&t>=0&&t<8}getPiece(e,t){return this.grid[t][e]}getValidMoves(e,t){let i=null;if(this.isWithinBounds(e,t)&&(i=this.getPiece(e,t)),!i)return[];const s=[];for(let n=0;n<8;n++)for(let o=0;o<8;o++)i.isValidMove(e,t,o,n,this)&&s.push({x:o,y:n});return s}captureEnPassantIfValid(e,t,i,s){if(this.isEnPassantMove(e,t,i,s)){const n=this.getPiece(e,t);if(!n)return;const o=s+(n.color===f.WHITE?-1:1);this.grid[o][i]&&(this.grid[o][i]=null)}}getKingInCheck(){return this.isKingInCheck(f.WHITE)?this.findKing(f.WHITE):this.isKingInCheck(f.BLACK)?this.findKing(f.BLACK):null}movePiece(e,t,i,s,n=!0){if(!this.isWithinBounds(e,t)||!this.isWithinBounds(i,s)||["__proto__","constructor","prototype"].includes(t.toString())||["__proto__","constructor","prototype"].includes(s.toString()))return!1;const o=this.getPiece(e,t);if(o&&o.isValidMove(e,t,i,s,this)){const r=this.getPiece(i,s);if(r&&r.type===a.KING)return!1;if(o.type===a.KING&&Math.abs(i-e)===2)return this.isCastlingValid(o,e,t,i)?(this.handleCastling(i,t),o.hasMoved=!0,!0):!1;if(o?.type===a.PAWN&&this.isEnPassantMove(e,t,i,s)&&this.captureEnPassant(e,t,i,s),this.grid[s][i]=o,this.grid[t][e]=null,n||(o.hasMoved=!0),this.isKingInCheck(o.color))return this.grid[t][e]=o,this.grid[s][i]=r,!1;(o.type===a.KING||o.type===a.ROOK)&&(o.hasMoved=!0),this.updateEnPassantTarget(e,t,i,s,o),this.halfMoveCount=o.type===a.PAWN||r?0:this.halfMoveCount+1;const c=o.color===f.WHITE?f.BLACK:f.WHITE;return this.isCheckmate(c),!0}return!1}isCastlingValid(e,t,i,s){const n=s>t?1:-1,o=s>t?7:0,r=this.getPiece(o,i);if(r?.type!==a.ROOK||r.hasMoved||e.hasMoved)return!1;for(let c=t+n;c!==s+n;c+=n)if(this.getPiece(c,i)||this.isSquareUnderAttack(c,i,e.color))return!1;return!0}handleCastling(e,t){if(e===6){const i=this.getPiece(7,t),s=this.getPiece(4,t);i?.type===a.ROOK&&!i.hasMoved&&s?.type===a.KING&&!s.hasMoved&&(this.setPiece(5,t,i),this.setPiece(7,t,null),this.setPiece(6,t,s),this.setPiece(4,t,null),s.hasMoved=!0,i.hasMoved=!0)}else if(e===2){const i=this.getPiece(0,t),s=this.getPiece(4,t);i?.type===a.ROOK&&!i.hasMoved&&s?.type===a.KING&&!s.hasMoved&&(this.setPiece(3,t,i),this.setPiece(0,t,null),this.setPiece(2,t,s),this.setPiece(4,t,null),s.hasMoved=!0,i.hasMoved=!0)}}updateEnPassantTarget(e,t,i,s,n){n?.type===a.PAWN&&Math.abs(s-t)===2&&e===i?this.enPassantTarget={x:i,y:(t+s)/2}:this.enPassantTarget=null}captureEnPassant(e,t,i,s){const n=this.getPiece(e,t);if(this.isEnPassantMove(e,t,i,s)&&n?.type===a.PAWN){const o=n.color===f.WHITE?-1:1,r=s+o,c=this.getPiece(i,r);if(c&&c.type===a.PAWN){this.grid[r][i]=null;const l={capturedWhite:[],capturedBlack:[]};return c.color===f.WHITE?l.capturedWhite.push(c.type):l.capturedBlack.push(c.type),Y(c.type,c.color),l}}return null}isEnPassantMove(e,t,i,s){return this.enPassantTarget?this.getPiece(e,t)?.type===a.PAWN&&i===this.enPassantTarget.x&&s===this.enPassantTarget.y&&Math.abs(e-i)===1&&Math.abs(t-s)===1:!1}async promotePawn(e,t,i){const s=this.getPiece(e,t)?.color;if(s)switch(i){case"queen":this.grid[t][e]=await P(a.QUEEN,s);break;case"rook":this.grid[t][e]=await P(a.ROOK,s);break;case"bishop":this.grid[t][e]=await P(a.BISHOP,s);break;case"knight":this.grid[t][e]=await P(a.KNIGHT,s);break}}isKingInCheck(e){const t=this.findKing(e);if(!t)return!1;for(let i=0;i<8;i++)for(let s=0;s<8;s++){const n=this.getPiece(s,i);if(n&&n.color!==e&&n.isValidMove(s,i,t.x,t.y,this))return!0}return!1}isCheckmate(e){if(!this.isKingInCheck(e))return!1;for(let i=0;i<8;i++)for(let s=0;s<8;s++){const n=this.getPiece(s,i);if(n&&n.color===e){const o=this.getValidMoves(s,i);for(const r of o){const c=this.getPiece(r.x,r.y);this.grid[r.y][r.x]=n,this.grid[i][s]=null;const l=!this.isKingInCheck(e);if(this.grid[i][s]=n,this.grid[r.y][r.x]=c,l)return!1}}}return!0}isStalemate(e){if(this.isKingInCheck(e))return!1;for(let t=0;t<8;t++)for(let i=0;i<8;i++){const s=this.getPiece(i,t);if(s&&s.color===e){for(let n=0;n<8;n++)for(let o=0;o<8;o++)if(s.isValidMove(i,t,o,n,this)){const r=this.getPiece(o,n);this.grid[n][o]=s,this.grid[t][i]=null;const c=!this.isKingInCheck(e);if(this.grid[t][i]=s,this.grid[n][o]=r,c)return!1}}}return!0}findKing(e){for(let t=0;t<8;t++)for(let i=0;i<8;i++){const s=this.getPiece(i,t);if(s&&s?.type===a.KING&&s.color===e)return{x:i,y:t}}return null}isKing(e,t){return this.getPiece(e,t)?.type===a.KING}isSquareUnderAttack(e,t,i){for(let s=0;s<8;s++)for(let n=0;n<8;n++){const o=this.getPiece(n,s);if(o&&o.color!==i){if(o.type===a.KING){if(o.isThreatenedMove(n,s,e,t))return!0}else if(o.isValidMove(n,s,e,t,this))return!0}}return!1}isInsufficientMaterial(){const e=this.grid.flat().filter(t=>t!==null);return e.length<=2?!0:e.length===3&&e.some(t=>t?.type===a.BISHOP||t?.type===a.KNIGHT)}isFiftyMoveRule(){return this.halfMoveCount>=50}setPiece(e,t,i){this.grid[t][e]=i}isMoveValid(e,t,i,s){const n=this.getPiece(e,t);if(!n||i<0||i>=8||s<0||s>=8||!n.isValidMove(e,t,i,s,this))return!1;const o=this.getPiece(i,s);return!(o&&o.color===n.color)}isCapture(e,t,i,s){const n=this.isWithinBounds(e,t)?this.getPiece(e,t):null,o=this.isWithinBounds(i,s)?this.getPiece(i,s):null;return n!==null&&o!==null&&n.color!==o.color}static async fromData(e){const t=new W;return await t.init(),t.grid=await Promise.all(e.grid.map(async i=>Promise.all(i.map(async s=>s?await N.fromData(s):null)))),t}toData(){return{grid:this.grid.map(e=>e.map(t=>t?t.toData():null))}}isAdjacentToAnotherKing(e,t,i){const s=[{dx:-1,dy:-1},{dx:-1,dy:0},{dx:-1,dy:1},{dx:0,dy:-1},{dx:0,dy:1},{dx:1,dy:-1},{dx:1,dy:0},{dx:1,dy:1}];for(const{dx:n,dy:o}of s){const r=e+n,c=t+o,l=this.isWithinBounds(r,c)?this.getPiece(r,c):null;if(l?.type===a.KING&&l.color!==i)return!0}return!1}getPieceCount(){return this.grid.flat().filter(e=>e!==null).length}setPlayerColor(e){this.currentPlayer=e}getPlayerColor(){return this.currentPlayer}getCurrentMovesHash(){let e="";for(let t=0;t<8;t++){let i=0;for(let s=0;s<8;s++){const n=this.getPiece(s,t);if(n){i>0&&(e+=i.toString(),i=0);const o=this.getPieceSymbol(n);e+=o}else i++}i>0&&(e+=i.toString()),t<7&&(e+="/")}return e+=` ${this.currentPlayer===f.WHITE?"w":"b"}`,e}getPieceSymbol(e){const t={[a.PAWN]:"p",[a.ROOK]:"r",[a.KNIGHT]:"n",[a.BISHOP]:"b",[a.QUEEN]:"q",[a.KING]:"k"};return e.color===f.WHITE?t[e.type].toUpperCase():t[e.type]}toString(){let e="";for(let t=0;t<8;t++)for(let i=0;i<8;i++){const s=this.getPiece(i,t);s?e+=`${s.color[0]}${s.type[0]}`:e+="__"}return e+=this.enPassantTarget?`e${this.enPassantTarget.x}${this.enPassantTarget.y}`:"e--",e+=`h${this.halfMoveCount}`,e+=`p${this.currentPlayer[0]}`,e}}const I={[a.PAWN]:1,[a.KNIGHT]:3,[a.BISHOP]:3.25,[a.ROOK]:5,[a.QUEEN]:9,[a.KING]:0},x={[a.PAWN]:[[0,0,0,0,0,0,0,0],[.5,.5,.5,.5,.5,.5,.5,.5],[.1,.1,.2,.3,.3,.2,.1,.1],[.05,.05,.1,.25,.25,.1,.05,.05],[0,0,0,.2,.2,0,0,0],[.05,-.05,-.1,0,0,-.1,-.05,.05],[.05,.1,.1,-.2,-.2,.1,.1,.05],[0,0,0,0,0,0,0,0]],[a.KNIGHT]:[[-.5,-.4,-.3,-.3,-.3,-.3,-.4,-.5],[-.4,-.2,0,0,0,0,-.2,-.4],[-.3,0,.1,.15,.15,.1,0,-.3],[-.3,.05,.15,.2,.2,.15,.05,-.3],[-.3,0,.15,.2,.2,.15,0,-.3],[-.3,.05,.1,.15,.15,.1,.05,-.3],[-.4,-.2,0,.05,.05,0,-.2,-.4],[-.5,-.4,-.3,-.3,-.3,-.3,-.4,-.5]],[a.BISHOP]:[[-.2,-.1,-.1,-.1,-.1,-.1,-.1,-.2],[-.1,0,0,0,0,0,0,-.1],[-.1,0,.05,.1,.1,.05,0,-.1],[-.1,.05,.05,.1,.1,.05,.05,-.1],[-.1,0,.1,.1,.1,.1,0,-.1],[-.1,.1,.1,.1,.1,.1,.1,-.1],[-.1,.05,0,0,0,0,.05,-.1],[-.2,-.1,-.1,-.1,-.1,-.1,-.1,-.2]],[a.ROOK]:[[0,0,0,0,0,0,0,0],[.05,.1,.1,.1,.1,.1,.1,.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[0,0,0,.05,.05,0,0,0]],[a.QUEEN]:[[-.2,-.1,-.1,-.05,-.05,-.1,-.1,-.2],[-.1,0,0,0,0,0,0,-.1],[-.1,0,.05,.05,.05,.05,0,-.1],[-.05,0,.05,.05,.05,.05,0,-.05],[0,0,.05,.05,.05,.05,0,-.05],[-.1,.05,.05,.05,.05,.05,0,-.1],[-.1,0,.05,0,0,0,0,-.1],[-.2,-.1,-.1,-.05,-.05,-.1,-.1,-.2]],[a.KING]:[[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.2,-.3,-.3,-.4,-.4,-.3,-.3,-.2],[-.1,-.2,-.2,-.2,-.2,-.2,-.2,-.1],[.2,.2,0,0,0,0,.2,.2],[.2,.3,0,0,0,0,.3,.2]]},K={"3,3":.5,"3,4":.5,"4,3":.5,"4,4":.5,"2,3":.25,"2,4":.25,"3,2":.25,"4,2":.25,"4,5":.25,"3,5":.25,"5,3":.25,"5,4":.25};function O(u,e){const t=u.findKing(e);return t&&u.isSquareUnderAttack(t.x,t.y,e)?-.5:0}function D(u,e,t,i,s,n){const o=x[u];return o?u===a.PAWN&&T(s,e,t,n)>0?0:i?o[7-t][7-e]:o[t][e]:0}function w(u,e,t=!1){let i=0;for(let s=0;s<8;s++)for(let n=0;n<8;n++){const o=u.getPiece(n,s),r=`${n},${s}`;if(!o)continue;let c=I[o.type];c+=D(o.type,n,s,t,u,o.color),o.type===a.PAWN&&T(u,n,s,o.color)===0&&K[r]&&(c+=K[r]),o.type===a.PAWN&&(c+=q(u,n,s,o.color),c+=V(u,n,s,o.color),c+=$(u,n,s,o.color)),c+=G(u,n,s,o.color),o.type===a.KING&&(c+=R(u,n,s,o.color)),i+=o.color===e?c:-c}return parseFloat(i.toFixed(2))}function G(u,e,t,i){let s=0;const n=u.findKing(i===f.WHITE?f.BLACK:f.WHITE);if(n){const r=Math.abs(n.x-e),c=Math.abs(n.y-t);(r<=1&&c<=1||r===0&&c<=2)&&(s+=.5)}const o=u.getPiece(e,t);return o&&I[o.type]>3&&(e===3||e===4||t===3||t===4)&&(s+=.25),s}function R(u,e,t,i){let s=0;const n=[{dx:-1,dy:0},{dx:1,dy:0},{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:-1},{dx:1,dy:1},{dx:-1,dy:1},{dx:1,dy:-1}];for(const{dx:o,dy:r}of n){const c=e+o,l=t+r;if(!u.isWithinBounds(c,l))continue;const g=u.getPiece(c,l);if(g&&g.color!==i){const p=Math.abs(c-e)+Math.abs(l-t);(g.type===a.ROOK||g.type===a.QUEEN)&&(s-=.5/p)}}return s}function $(u,e,t,i){let s=0;const n=e>0?u.getPiece(e-1,t):null,o=e<7?u.getPiece(e+1,t):null;return(n&&n.color===i&&n.type===a.PAWN||o&&o.color===i&&o.type===a.PAWN)&&(s+=.3),s}function V(u,e,t,i){const s=i===f.WHITE?-1:1;let n=0;const o=u.getPiece(e-1,t+s),r=u.getPiece(e+1,t+s);return(o&&o.color===i&&o.type===a.PAWN||r&&r.color===i&&r.type===a.PAWN)&&(n+=.5),n}function q(u,e,t,i){let s=0;const n=Q(u,e,t,i),o=L(u,e,t,i)*.25,r=T(u,e,t,i)*4;return n&&(s+=4.5),s-=o+r,s}function L(u,e,t,i){for(let s=0;s<8;s++)if(s!==t&&u.getPiece(e,s)?.type===a.PAWN&&u.getPiece(e,s)?.color===i)return .5;return 0}function T(u,e,t,i){const s=e-1>=0?u.getPiece(e-1,t):null,n=e+1<8?u.getPiece(e+1,t):null;return s&&s.type===a.PAWN&&s.color===i||n&&n.type===a.PAWN&&n.color===i?0:1.5}function Q(u,e,t,i){const s=i===f.WHITE?1:-1;for(let o=t+s;o>=0&&o<8;o+=s){const r=u.getPiece(e,o);if(r&&r.type===a.PAWN&&r.color!==i)return!1}const n=[e-1,e+1];for(const o of n)if(o>=0&&o<8)for(let r=t+s;r>=0&&r<8;r+=s){const c=u.getPiece(o,r);if(c&&c.type===a.PAWN&&c.color!==i)return!1}return!0}class _{static endgames={kqkEndgame:{fromX:7,fromY:1,toX:6,toY:1},krkEndgame:{fromX:7,fromY:0,toX:5,toY:0},kbbkEndgame:{fromX:5,fromY:3,toX:3,toY:1},kbnkEndgame:{fromX:2,fromY:6,toX:4,toY:4},kpEndgame:{fromX:6,fromY:5,toX:6,toY:6},kppkEndgame:{fromX:5,fromY:2,toX:5,toY:3},krkpEndgame:{fromX:6,fromY:0,toX:6,toY:1},kqkrEndgame:{fromX:7,fromY:2,toX:6,toY:2},kbkpEndgame:{fromX:3,fromY:3,toX:4,toY:2},krrkEndgame:{fromX:7,fromY:4,toX:5,toY:4}};static getEndgameMove(e){return this.endgames[e]||null}}class U{static openings={"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w":[{fromX:1,fromY:7,toX:3,toY:7},{fromX:6,fromY:7,toX:5,toY:5}],"rnbqkbnr/pppppppp/8/8/8/8/PPP1PPPP/RNBQKBNR w":[{fromX:2,fromY:7,toX:4,toY:7},{fromX:4,fromY:6,toX:4,toY:4}],"rnbqkbnr/pppppp1p/8/8/8/8/PPPP1PPP/RNBQKBNR w":[{fromX:4,fromY:7,toX:4,toY:5}],"rnbqkbnr/ppp1pppp/8/8/8/8/PPP1PPPP/RNBQKBNR w":[{fromX:5,fromY:6,toX:4,toY:4}],"rnbqkbnr/pppppppp/8/8/8/8/PP1PPPPP/RNBQKBNR w":[{fromX:4,fromY:7,toX:4,toY:5}],"rnbqkbnr/pppppppp/8/8/8/8/PPPP1PPP/RNBQKBNR w":[{fromX:6,fromY:6,toX:6,toY:4}]};static getOpeningMove(e){const t=this.openings[e];return t&&t.length>0?t[Math.floor(Math.random()*t.length)]:null}}class j{gamePatterns=new Map;async loadGamesData(){const t=await(await fetch("/chess-game/games.json")).json();this.loadGames(t)}loadGames(e){e.forEach(t=>{const i=t.Moves,s=t.Result;let n="";i.forEach(o=>{this.gamePatterns.has(n)||this.gamePatterns.set(n,[]);const r=this.gamePatterns.get(n),c=s==="1-0"?1:s==="0-1"?0:.5,l=r.find(g=>g.move===o);l?(l.successRate=(l.successRate*l.games+c)/(l.games+1),l.games+=1):r.push({move:o,successRate:c,games:1}),n+=o+" "})})}getBestMove(e){const t=this.gamePatterns.get(e);return!t||t.length===0?null:(t.sort((i,s)=>s.successRate-i.successRate),t[0].move)}}class z{moveData=new Map;recordMove(e,t){const i=this.moveData.get(e)||[],s=i.find(n=>n.move.fromX===t.fromX&&n.move.fromY===t.fromY&&n.move.toX===t.toX&&n.move.toY===t.toY);s?s.count++:i.push({move:t,count:1}),this.moveData.set(e,i)}getMovesByFrequency(e){return(this.moveData.get(e)||[]).sort((t,i)=>i.count-t.count)}}class F{constructor(e,t=6e4){this.color=e,this.transpositionTable=new Map,this.maxTime=t,this.killerMoves=new Map,this.startTime=0,this.gamesAnalyzer=new j,this.contextualMoveDatabase=new z}transpositionTable;maxTime;startTime;killerMoves;moveHistory=[];historicalMoveScores=new Map;gamesAnalyzer;gamesLoaded=!1;contextualMoveDatabase;async loadGamesData(){await this.gamesAnalyzer.loadGamesData(),this.gamesLoaded=!0}recordMoveInContextualDatabase(e,t){this.contextualMoveDatabase.recordMove(e,t)}makeMove(e){if(!this.gamesLoaded)throw new Error("Games data not loaded. Call loadGamesData() first.");this.startTime=Date.now(),this.maxTime=Math.floor(Math.random()*45001)+5e3;const t=this.getOpeningMove(e);if(t&&typeof t=="object"&&"fromX"in t&&"fromY"in t&&"toX"in t&&"toY"in t)return this.moveHistory.push(t),this.recordMoveInContextualDatabase(this.getPositionKey(e),t),t;const i=this.useEndgameTablebase(e);if(i&&typeof i=="object"&&"fromX"in i&&"fromY"in i&&"toX"in i&&"toY"in i)return this.moveHistory.push(i),this.recordMoveInContextualDatabase(this.getPositionKey(e),i),i;const s=this.getPositionKey(e),n=this.getAnalyzedMove(s);if(n&&typeof n=="object"&&"fromX"in n&&"fromY"in n&&"toX"in n&&"toY"in n)return this.moveHistory.push(n),this.recordMoveInContextualDatabase(s,n),n;const o=this.getBestMoveUsingMinimax(e);return o&&typeof o=="object"&&"fromX"in o&&"fromY"in o&&"toX"in o&&"toY"in o?(this.moveHistory.push(o),this.recordMoveInContextualDatabase(s,o),o):null}getOpeningMove(e){const t=e.getCurrentMovesHash(),i=U.getOpeningMove(t);return i?this.flipMoveIfBlack(i):null}flipMoveIfBlack(e){return this.color===f.BLACK?{fromX:7-e.fromX,fromY:7-e.fromY,toX:7-e.toX,toY:7-e.toY}:e}minimax(e,t,i,s,n,o=2,r=3,c=.9,l=25){const g=this.determineGamePhase(e),p=`${e.toString()}|${t}|${g}`;if(Date.now()-this.startTime>this.maxTime)return this.evaluatePositionWithKingSafety(e,this.color);if(this.transpositionTable.has(p)){const{value:M,depth:C}=this.transpositionTable.get(p);if(C>=t)return M}if(t===0||e.isCheckmate(this.color)||e.isCheckmate(this.getOpponentColor())){const M=this.quiescenceSearch(e,i,s,g);return this.transpositionTable.set(p,{value:M,depth:t}),M}let h=this.evaluatePositionWithKingSafety(e,this.color),y=h-l,v=h+l,m;for(;;)if(m=this.alphaBetaWithAspirationWindow(e,t,y,v,n,o,r,c),m<=y)y-=l;else if(m>=v)v+=l;else break;return this.transpositionTable.set(p,{value:m,depth:t}),m}alphaBetaWithAspirationWindow(e,t,i,s,n,o,r,c){if(Date.now()-this.startTime>this.maxTime)return i;let l=n?-1/0:1/0,g=this.getAllValidMoves(e);g=this.sortMoves(g,e,t,this.determineGamePhase(e));let p=0;for(const h of g){const y=e.getPiece(h.fromX,h.fromY),v=e.getPiece(h.toX,h.toY);e.movePiece(h.fromX,h.fromY,h.toX,h.toY);let m;if(t>=r&&p<o&&(m=-this.minimax(e,t-r,-s,-i,!n,o,r,c),m<=i)){p++,e.setPiece(h.fromX,h.fromY,y),e.setPiece(h.toX,h.toY,v);continue}if(m=this.minimax(e,t-1,i,s,!n,o,r,c),e.setPiece(h.fromX,h.fromY,y),e.setPiece(h.toX,h.toY,v),n?(m>l&&(l=m,this.updateHistoricalMoveScore(h),this.addKillerMove(t,h)),i=Math.max(i,m)):(m<l&&(l=m,this.updateHistoricalMoveScore(h),this.addKillerMove(t,h)),s=Math.min(s,m)),s<=i)break}return l}determineGamePhase(e){const t=e.getPieceCount();return t>24?"opening":t>12?"midgame":"endgame"}addKillerMove(e,t){const i=this.killerMoves.get(e)??[],s=`${t.fromX},${t.fromY},${t.toX},${t.toY}`;let n=i.find(o=>`${o.move.fromX},${o.move.fromY},${o.move.toX},${o.move.toY}`===s);n?n.score+=10:i.push({move:t,score:10}),this.killerMoves.set(e,i.sort((o,r)=>r.score-o.score).slice(0,2))}updateHistoricalMoveScore(e){const t=`${e.fromX},${e.fromY},${e.toX},${e.toY}`,i=this.historicalMoveScores.get(t)||0;this.historicalMoveScores.set(t,i+1)}quiescenceSearch(e,t,i,s,n=0){const o=this.getAdaptiveQuiescenceDepth(e);if(n>=o)return w(e,this.color);const r=w(e,this.color);if(r>=i)return i;t<r&&(t=r);const c=this.getAllValidMoves(e).filter(l=>e.isCapture(l.fromX,l.fromY,l.toX,l.toY));for(const l of c){const g=e.getPiece(l.fromX,l.fromY),p=e.getPiece(l.toX,l.toY);e.movePiece(l.fromX,l.fromY,l.toX,l.toY);let h=-this.quiescenceSearch(e,-i,-t,s,n+1);if(s==="endgame"&&this.isCriticalMove(g,l,e)&&(h+=20),e.setPiece(l.fromX,l.fromY,g),e.setPiece(l.toX,l.toY,p),h>=i)return i;h>t&&(t=h)}return t}getOpponentColor(){return this.color===f.WHITE?f.BLACK:f.WHITE}getAllValidMoves(e){const t=[];for(let i=0;i<8;i++)for(let s=0;s<8;s++){const n=e.getPiece(s,i);if(n&&n.color===this.color){const o=e.getValidMoves(s,i);for(const r of o)if(e.isMoveValid(s,i,r.x,r.y)){const c=e.getPiece(r.x,r.y);e.setPiece(r.x,r.y,n),e.setPiece(s,i,null);const l=!e.isKingInCheck(this.color);e.setPiece(s,i,n),e.setPiece(r.x,r.y,c),l&&t.push({fromX:s,fromY:i,toX:r.x,toY:r.y})}}}return t}sortMoves(e,t,i,s){const n=this.getPositionKey(t),o=this.contextualMoveDatabase.getMovesByFrequency(n);return e.sort((r,c)=>{const l=t.getPiece(r.toX,r.toY),g=t.getPiece(c.toX,c.toY),p=l?I[l.type]:0,h=g?I[g.type]:0,y=o.findIndex(d=>d.move.fromX===r.fromX&&d.move.fromY===r.fromY&&d.move.toX===r.toX&&d.move.toY===r.toY),v=o.findIndex(d=>d.move.fromX===c.fromX&&d.move.fromY===c.fromY&&d.move.toX===c.toX&&d.move.toY===c.toY);if(y!==-1||v!==-1)return(y!==-1?y:1/0)-(v!==-1?v:1/0);if(s==="opening"){const d=K[`${r.toX},${r.toY}`]||0,A=K[`${c.toX},${c.toY}`]||0;if(d!==A)return A-d}else if(s==="endgame"){if(l&&l.type===a.PAWN&&r.toY===7)return-1;if(g&&g.type===a.PAWN&&c.toY===7)return 1}if(p!==h)return h-p;const m=this.killerMoves.get(i);if(m&&m.some(d=>d.move.fromX===r.fromX&&d.move.fromY===r.fromY&&d.move.toX===r.toX&&d.move.toY===r.toY))return-1;const M=this.historicalMoveScores.get(`${r.fromX},${r.fromY},${r.toX},${r.toY}`)||0;return(this.historicalMoveScores.get(`${c.fromX},${c.fromY},${c.toX},${c.toY}`)||0)-M})}getAdaptiveQuiescenceDepth(e){const t=e.getPieceCount();return t<=6?7:t<=12?5:3}evaluatePositionWithKingSafety(e,t){let i=w(e,t);const s=O(e,t);return i+=s,i}useEndgameTablebase(e){if(e.getPieceCount()<=5){const t=e.getCurrentMovesHash(),i=_.getEndgameMove(t);return i?this.flipMoveIfBlack(i):null}return null}isCriticalMove(e,t,i){const s=i.getPiece(t.toX,t.toY);return s&&s.color!==e.color&&s.type!==a.PAWN}getPositionKey(e){return e.getCurrentMovesHash()}convertMoveToCoords(e){const[t,i,s,n]=e.match(/\d+/g).map(Number);return{fromX:t,fromY:i,toX:s,toY:n}}getAnalyzedMove(e){const t=this.gamesAnalyzer.getBestMove(e);return t?this.convertMoveToCoords(t):null}getBestMoveUsingMinimax(e){let t=null,i=-1/0;const s=16,n=this.determineGamePhase(e),o=600;for(let r=1;r<=s&&!(Date.now()-this.startTime>this.maxTime);r++){let c=this.getAllValidMoves(e);c=this.sortMoves(c,e,r,n);for(const l of c){if(Date.now()-this.startTime>this.maxTime)return t;const g=e.getPiece(l.fromX,l.fromY);if(!g)continue;const p=e.getPiece(l.toX,l.toY);e.movePiece(l.fromX,l.fromY,l.toX,l.toY);const y=e.isKingInCheck(this.color)||this.isCriticalMove(g,l,e)?r+1:r,v=this.minimax(e,y-1,-i,-1/0,!1);if(e.setPiece(l.fromX,l.fromY,g),e.setPiece(l.toX,l.toY,p),-v>i&&(i=-v,t=l,i>=o)||Date.now()-this.startTime>this.maxTime)return t}if(Date.now()-this.startTime>this.maxTime)break}return t}}class H extends N{hasMoved=!1;_toX=null;_toY=null;_board=null;constructor(e){super(e,a.PAWN)}isValidMove(e,t,i,s,n){if(i<0||i>=8||s<0||s>=8)return!1;const o=n.getPlayerColor(),r=this.color===f.WHITE?1:-1,c=this.color===f.WHITE?1:6,l=(s-t)*r,g=Math.abs(i-e),p=o===f.WHITE?7:0;if(g===0&&l===1&&!n.getPiece(i,s))return s===p?this.handlePromotion(i,s,n):!0;if(g===1&&l===1){if(n.getPiece(i,s)&&this.canCapture(i,s,n))return s===p?this.handlePromotion(i,s,n):!0;if(n.isEnPassantMove(e,t,i,s))return n.captureEnPassantIfValid(e,t,i,s),!0}return g===0&&l===2&&t===c&&!n.getPiece(i,s)&&!n.getPiece(e,t+r)?(n.updateEnPassantTarget(e,t,i,s,this),this.hasMoved=!0,!0):!1}handlePromotion(e,t,i){return this._toX=e,this._toY=t,this._board=i,!0}}var J=Object.freeze({__proto__:null,Pawn:H});let E;self.onmessage=async u=>{const{boardData:e,aiColor:t}=u.data;E=new F(t),await E.loadGamesData();const i=await W.fromData(e),s=E.makeMove(i);let n=null;if(s&&i.isCapture(s.fromX,s.fromY,s.toX,s.toY)){const r=i.getPiece(s.toX,s.toY);r&&(n={capturedWhite:[],capturedBlack:[]},r.color===f.WHITE?n.capturedWhite.push(r.type):n.capturedBlack.push(r.type))}let o=!1;if(s&&i.getPiece(s.fromX,s.fromY)?.type===a.PAWN){const r=i.getPiece(s.fromX,s.fromY);if(r instanceof H){const c=t===f.WHITE?7:0;s.toY===c&&(o=r.handlePromotion(s.toX,s.toY,i))}}self.postMessage({bestMove:s,captureData:n,promotionRequired:o})};export{N as P,a,P as c};
//# sourceMappingURL=ai.worker-BgG0FHGC.js.map
