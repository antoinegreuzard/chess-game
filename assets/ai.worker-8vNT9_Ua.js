async function g(l,e){switch(l){case r.PAWN:const{Pawn:i}=await Promise.resolve().then(function(){return b});return new i(e);case r.ROOK:const{Rook:t}=await import("./rook-D7gLKJZx.js");return new t(e);case r.KNIGHT:const{Knight:o}=await import("./knight-BmAxjYlX.js");return new o(e);case r.BISHOP:const{Bishop:s}=await import("./bishop-BEyPIpeg.js");return new s(e);case r.QUEEN:const{Queen:n}=await import("./queen-XKRVnh7M.js");return new n(e);case r.KING:const{King:c}=await import("./king-dSwQYTxh.js");return new c(e);default:throw new Error(`Type de pièce inconnu : ${l}`)}}var f=(l=>(l.WHITE="white",l.BLACK="black",l))(f||{}),r=(l=>(l.PAWN="pawn",l.ROOK="rook",l.KNIGHT="knight",l.BISHOP="bishop",l.QUEEN="queen",l.KING="king",l))(r||{});class E{constructor(e,i){this.color=e,this.type=i}hasMoved=!1;isPathClear(e,i,t,o,s){const n=Math.sign(t-e),c=Math.sign(o-i);let a=e+n,u=i+c;for(;a!==t||u!==o;){if(s.getPiece(a,u)!==null)return!1;a+=n,u+=c}return!0}static isKing(e){return e.type==="king"}canCapture(e,i,t){const o=t.getPiece(e,i);return!o||o.color!==this.color}toData(){return{color:this.color,type:this.type}}static async fromData(e){return await g(e.type,e.color)}}let w=[],N=[];function k(l,e){switch(l){case r.PAWN:return e===f.WHITE?"♙":"♟";case r.ROOK:return e===f.WHITE?"♖":"♜";case r.KNIGHT:return e===f.WHITE?"♘":"♞";case r.BISHOP:return e===f.WHITE?"♗":"♝";case r.QUEEN:return e===f.WHITE?"♕":"♛";case r.KING:return e===f.WHITE?"♔":"♚";default:return""}}function O(l,e){const i=k(l,e);e===f.WHITE?w.push(i):N.push(i),G()}function G(){const l=document.getElementById("capturedWhite"),e=document.getElementById("capturedBlack");l&&(l.textContent=w.join(" ")),e&&(e.textContent=N.join(" "))}class v{grid;enPassantTarget=null;halfMoveCount=0;currentPlayer=f.WHITE;constructor(){this.grid=[]}async init(){this.grid=await this.initializeBoard()}async initializeBoard(){const e=Array(8).fill(null).map(()=>Array(8).fill(null));return e[0]=[await g(r.ROOK,f.WHITE),await g(r.KNIGHT,f.WHITE),await g(r.BISHOP,f.WHITE),await g(r.KING,f.WHITE),await g(r.QUEEN,f.WHITE),await g(r.BISHOP,f.WHITE),await g(r.KNIGHT,f.WHITE),await g(r.ROOK,f.WHITE)],e[1]=await Promise.all(Array(8).fill(null).map(()=>g(r.PAWN,f.WHITE))),e[7]=[await g(r.ROOK,f.BLACK),await g(r.KNIGHT,f.BLACK),await g(r.BISHOP,f.BLACK),await g(r.KING,f.BLACK),await g(r.QUEEN,f.BLACK),await g(r.BISHOP,f.BLACK),await g(r.KNIGHT,f.BLACK),await g(r.ROOK,f.BLACK)],e[6]=await Promise.all(Array(8).fill(null).map(()=>g(r.PAWN,f.BLACK))),e}isWithinBounds(e,i){return e>=0&&e<8&&i>=0&&i<8}getPiece(e,i){return this.grid[i][e]}getValidMoves(e,i){let t=null;if(this.isWithinBounds(e,i)&&(t=this.getPiece(e,i)),!t)return[];const o=[];for(let s=0;s<8;s++)for(let n=0;n<8;n++)t.isValidMove(e,i,n,s,this)&&o.push({x:n,y:s});return o}getKingInCheck(){return this.isKingInCheck(f.WHITE)?this.findKing(f.WHITE):this.isKingInCheck(f.BLACK)?this.findKing(f.BLACK):null}movePiece(e,i,t,o){if(!this.isWithinBounds(e,i)||!this.isWithinBounds(t,o)||["__proto__","constructor","prototype"].includes(i.toString())||["__proto__","constructor","prototype"].includes(o.toString()))return!1;const s=this.getPiece(e,i);if(s&&s.isValidMove(e,i,t,o,this)){const n=this.getPiece(t,o);if(n&&n.type===r.KING)return!1;if(s?.type===r.KING&&Math.abs(t-e)===2)return this.isCastlingValid(s,e,i,t)?(this.handleCastling(t,i),s.hasMoved=!0,!0):!1;if(s?.type===r.PAWN&&this.isEnPassantMove(e,i,t,o)&&this.captureEnPassant(e,i,t,o),this.grid[o][t]=s,this.grid[i][e]=null,s.hasMoved=!0,this.isKingInCheck(s.color))return this.grid[i][e]=s,this.grid[o][t]=n,!1;"hasMoved"in s&&(s.hasMoved=!0),this.updateEnPassantTarget(e,i,t,o,s),this.halfMoveCount=s.type===r.PAWN||n?0:this.halfMoveCount+1;const c=s.color===f.WHITE?f.BLACK:f.WHITE;return this.isCheckmate(c),!0}return!1}isCastlingValid(e,i,t,o){const s=o>i?1:-1,n=o>i?7:0,c=this.getPiece(n,t);if(c?.type!==r.ROOK||c.hasMoved||e.hasMoved)return!1;for(let a=i+s;a!==o+s;a+=s)if(this.getPiece(a,t)||this.isSquareUnderAttack(a,t,e.color))return!1;return!0}handleCastling(e,i){if(e===6){const t=this.getPiece(7,i),o=this.getPiece(4,i);t?.type===r.ROOK&&!t.hasMoved&&o?.type===r.KING&&(this.setPiece(5,i,t),this.setPiece(7,i,null),this.setPiece(6,i,o),this.setPiece(4,i,null))}else if(e===2){const t=this.getPiece(0,i),o=this.getPiece(4,i);t?.type===r.ROOK&&!t.hasMoved&&o?.type===r.KING&&(this.setPiece(3,i,t),this.setPiece(0,i,null),this.setPiece(2,i,o),this.setPiece(4,i,null))}}updateEnPassantTarget(e,i,t,o,s){s?.type===r.PAWN&&Math.abs(o-i)===2&&e===t?this.enPassantTarget={x:t,y:(i+o)/2}:this.enPassantTarget=null}captureEnPassant(e,i,t,o){const s=this.getPiece(e,i);if(this.isEnPassantMove(e,i,t,o)&&s?.type===r.PAWN){const n=s.color===f.WHITE?-1:1,c=o+n,a=this.getPiece(t,c);if(a&&a.type===r.PAWN){this.grid[c][t]=null;const u={capturedWhite:[],capturedBlack:[]};return a.color===f.WHITE?u.capturedWhite.push(a.type):u.capturedBlack.push(a.type),O(a.type,a.color),u}}return null}isEnPassantMove(e,i,t,o){return this.enPassantTarget?this.getPiece(e,i)?.type===r.PAWN&&t===this.enPassantTarget.x&&o===this.enPassantTarget.y&&Math.abs(e-t)===1&&Math.abs(i-o)===1:!1}async promotePawn(e,i,t){const o=this.getPiece(e,i)?.color;if(o)switch(t){case"queen":this.grid[i][e]=await g(r.QUEEN,o);break;case"rook":this.grid[i][e]=await g(r.ROOK,o);break;case"bishop":this.grid[i][e]=await g(r.BISHOP,o);break;case"knight":this.grid[i][e]=await g(r.KNIGHT,o);break}}isKingInCheck(e){const i=this.findKing(e);if(!i)return!1;for(let t=0;t<8;t++)for(let o=0;o<8;o++){const s=this.getPiece(o,t);if(s&&s.color!==e&&s.isValidMove(o,t,i.x,i.y,this))return!0}return!1}isCheckmate(e){if(!this.isKingInCheck(e))return!1;for(let i=0;i<8;i++)for(let t=0;t<8;t++){const o=this.getPiece(t,i);if(o&&o.color===e){const s=this.getValidMoves(t,i);for(const n of s){const c=this.getPiece(n.x,n.y);this.grid[n.y][n.x]=o,this.grid[i][t]=null;const a=!this.isKingInCheck(e);if(this.grid[i][t]=o,this.grid[n.y][n.x]=c,a)return!1}}}return!0}isStalemate(e){if(this.isKingInCheck(e))return!1;for(let i=0;i<8;i++)for(let t=0;t<8;t++){const o=this.getPiece(t,i);if(o&&o.color===e){for(let s=0;s<8;s++)for(let n=0;n<8;n++)if(o.isValidMove(t,i,n,s,this)){const c=this.getPiece(n,s);this.grid[s][n]=o,this.grid[i][t]=null;const a=!this.isKingInCheck(e);if(this.grid[i][t]=o,this.grid[s][n]=c,a)return!1}}}return!0}findKing(e){for(let i=0;i<8;i++)for(let t=0;t<8;t++){const o=this.getPiece(t,i);if(o&&o?.type===r.KING&&o.color===e)return{x:t,y:i}}return null}isKing(e,i){return this.getPiece(e,i)?.type===r.KING}isSquareUnderAttack(e,i,t){for(let o=0;o<8;o++)for(let s=0;s<8;s++){const n=this.getPiece(s,o);if(n&&n.color!==t&&n.isValidMove(s,o,e,i,this))return!0}return!1}isInsufficientMaterial(){const e=this.grid.flat().filter(i=>i!==null);return e.length<=2?!0:e.length===3&&e.some(i=>i?.type===r.BISHOP||i?.type===r.KNIGHT)}isFiftyMoveRule(){return this.halfMoveCount>=50}setPiece(e,i,t){this.grid[i][e]=t}isMoveValid(e,i,t,o){const s=this.getPiece(e,i);if(!s||t<0||t>=8||o<0||o>=8||!s.isValidMove(e,i,t,o,this))return!1;const n=this.getPiece(t,o);return!(n&&n.color===s.color)}isCapture(e,i,t,o){const s=this.isWithinBounds(e,i)?this.getPiece(e,i):null,n=this.isWithinBounds(t,o)?this.getPiece(t,o):null;return s!==null&&n!==null&&s.color!==n.color}static async fromData(e){const i=new v;return await i.init(),i.grid=await Promise.all(e.grid.map(async t=>Promise.all(t.map(async o=>o?await E.fromData(o):null)))),i}toData(){return{grid:this.grid.map(e=>e.map(i=>i?i.toData():null))}}isAdjacentToAnotherKing(e,i,t){const o=[{dx:-1,dy:-1},{dx:-1,dy:0},{dx:-1,dy:1},{dx:0,dy:-1},{dx:0,dy:1},{dx:1,dy:-1},{dx:1,dy:0},{dx:1,dy:1}];for(const{dx:s,dy:n}of o){const c=e+s,a=i+n,u=this.isWithinBounds(c,a)?this.getPiece(c,a):null;if(u?.type===r.KING&&u.color!==t)return!0}return!1}clone(){const e=new v;return e.grid=this.grid.map(i=>i.map(t=>t?Object.create(Object.getPrototypeOf(t),Object.getOwnPropertyDescriptors(t)):null)),e.enPassantTarget=this.enPassantTarget?{...this.enPassantTarget}:null,e.halfMoveCount=this.halfMoveCount,e}getPieceCount(){return this.grid.flat().filter(e=>e!==null).length}isGameOver(){return this.isCheckmate(f.WHITE)||this.isCheckmate(f.BLACK)||this.isStalemate(f.WHITE)||this.isStalemate(f.BLACK)||this.isInsufficientMaterial()?!0:this.isFiftyMoveRule()}getWinner(){return this.isCheckmate(f.BLACK)?f.WHITE:this.isCheckmate(f.WHITE)?f.BLACK:(this.isStalemate(f.WHITE)||this.isStalemate(f.BLACK)||this.isInsufficientMaterial()||this.isFiftyMoveRule(),null)}getPieces(){return this.grid.flat().filter(e=>e!==null)}setPlayerColor(e){this.currentPlayer=e}getPlayerColor(){return this.currentPlayer}}const S={[r.PAWN]:1,[r.KNIGHT]:3,[r.BISHOP]:3.25,[r.ROOK]:5,[r.QUEEN]:9,[r.KING]:0},V={[r.PAWN]:[[0,0,0,0,0,0,0,0],[.5,.5,.5,.5,.5,.5,.5,.5],[.1,.1,.2,.3,.3,.2,.1,.1],[.05,.05,.1,.25,.25,.1,.05,.05],[0,0,0,.2,.2,0,0,0],[.05,-.05,-.1,0,0,-.1,-.05,.05],[.05,.1,.1,-.2,-.2,.1,.1,.05],[0,0,0,0,0,0,0,0]],[r.KNIGHT]:[[-.5,-.4,-.3,-.3,-.3,-.3,-.4,-.5],[-.4,-.2,0,0,0,0,-.2,-.4],[-.3,0,.1,.15,.15,.1,0,-.3],[-.3,.05,.15,.2,.2,.15,.05,-.3],[-.3,0,.15,.2,.2,.15,0,-.3],[-.3,.05,.1,.15,.15,.1,.05,-.3],[-.4,-.2,0,.05,.05,0,-.2,-.4],[-.5,-.4,-.3,-.3,-.3,-.3,-.4,-.5]],[r.BISHOP]:[[-.2,-.1,-.1,-.1,-.1,-.1,-.1,-.2],[-.1,0,0,0,0,0,0,-.1],[-.1,0,.05,.1,.1,.05,0,-.1],[-.1,.05,.05,.1,.1,.05,.05,-.1],[-.1,0,.1,.1,.1,.1,0,-.1],[-.1,.1,.1,.1,.1,.1,.1,-.1],[-.1,.05,0,0,0,0,.05,-.1],[-.2,-.1,-.1,-.1,-.1,-.1,-.1,-.2]],[r.ROOK]:[[0,0,0,0,0,0,0,0],[.05,.1,.1,.1,.1,.1,.1,.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[0,0,0,.05,.05,0,0,0]],[r.QUEEN]:[[-.2,-.1,-.1,-.05,-.05,-.1,-.1,-.2],[-.1,0,0,0,0,0,0,-.1],[-.1,0,.05,.05,.05,.05,0,-.1],[-.05,0,.05,.05,.05,.05,0,-.05],[0,0,.05,.05,.05,.05,0,-.05],[-.1,.05,.05,.05,.05,.05,0,-.1],[-.1,0,.05,0,0,0,0,-.1],[-.2,-.1,-.1,-.05,-.05,-.1,-.1,-.2]],[r.KING]:[[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.2,-.3,-.3,-.4,-.4,-.3,-.3,-.2],[-.1,-.2,-.2,-.2,-.2,-.2,-.2,-.1],[.2,.2,0,0,0,0,.2,.2],[.2,.3,0,0,0,0,.3,.2]]},K={"3,3":.5,"3,4":.5,"4,3":.5,"4,4":.5,"2,3":.25,"2,4":.25,"3,2":.25,"4,2":.25,"4,5":.25,"3,5":.25,"5,3":.25,"5,4":.25};function R(l,e,i,t){const o=V[l];return o?t?o[7-i][7-e]:o[i][e]:0}function Y(l,e,i=!1){let t=0;for(let o=0;o<8;o++)for(let s=0;s<8;s++){const n=l.getPiece(s,o);if(n){let c=S[n.type];c+=R(n.type,s,o,i);const a=`${s},${o}`;K[a]&&(c+=K[a]),n.type===r.PAWN&&(c+=T(l,s,o,n.color),C(l,s,o,n.color)&&(c+=1)),n.type===r.PAWN&&(c+=T(l,s,o,n.color),C(l,s,o,n.color)&&(c+=1)),n.type===r.KING&&_(l,s,o,n.color)&&(c-=.5),t+=n.color===e?c:-c}}return parseFloat(t.toFixed(2))}function T(l,e,i,t){let o=0;return o-=D(l,e,i,t)*1.5,o-=L(l,e,i,t)*1.5,o}function D(l,e,i,t){for(let o=0;o<8;o++)if(o!==i&&l.getPiece(e,o)?.type===r.PAWN&&l.getPiece(e,o)?.color===t)return .5;return 0}function L(l,e,i,t){const o=e-1>=0?l.getPiece(e-1,i):null,s=e+1<8?l.getPiece(e+1,i):null;return(!o||o.type!==r.PAWN||o.color!==t)&&(!s||s.type!==r.PAWN||s.color!==t)?1.5:0}function _(l,e,i,t){const o=l.getPiece(e,i);return o&&o.type===r.KING?[{dx:-1,dy:0},{dx:1,dy:0},{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:-1},{dx:1,dy:1},{dx:-1,dy:1},{dx:1,dy:-1}].some(({dx:n,dy:c})=>{const a=e+n,u=i+c;if(!l.isWithinBounds(a,u))return!1;const h=l.getPiece(a,u);return!h||h.color!==t||h.type!==r.PAWN}):!1}function C(l,e,i,t){const o=t===f.WHITE?-1:1;for(let n=i+o;n>=0&&n<8;n+=o){const c=l.getPiece(e,n);if(c&&c.type===r.PAWN&&c.color!==t)return!1}return[e-1,e+1].every(n=>{if(n<0||n>=8)return!0;for(let c=0;c<8;c++){const a=l.getPiece(n,c);if(a&&a.type===r.PAWN&&a.color===t)return!1}return!0})}function j(l,e){return e?{fromX:7-l.fromX,fromY:7-l.fromY,toX:7-l.toX,toY:7-l.toY}:l}function q(l,e,i=!1){const t=l.getPieces();let o=null;return t.length===3&&P(t,r.KING,e)&&P(t,r.ROOK,e)&&P(t,r.KING,d(e))?o=U(l,e):t.length===4&&P(t,r.KING,e)&&P(t,r.BISHOP,e)&&P(t,r.KNIGHT,e)&&P(t,r.KING,d(e))?o=$(l,e):t.length===4&&P(t,r.KING,e)&&P(t,r.BISHOP,e)&&t.filter(s=>s.type===r.BISHOP&&s.color===e).length===2&&P(t,r.KING,d(e))?o=Q(l,e):t.length===3&&P(t,r.KING,e)&&P(t,r.PAWN,e)&&P(t,r.KING,d(e))&&(o=F(l,e)),o?j(o,e===f.BLACK||i):null}function P(l,e,i){return l.some(t=>t.type===e&&t.color===i)}function d(l){return l===f.WHITE?f.BLACK:f.WHITE}function U(l,e){const i=y(l,r.KING,d(e)),t=y(l,r.ROOK,e);return!i||!t?null:i.x<4?{fromX:t.x,fromY:t.y,toX:i.x+1,toY:i.y}:{fromX:t.x,fromY:t.y,toX:i.x-1,toY:i.y}}function $(l,e){const i=y(l,r.KING,d(e)),t=y(l,r.KNIGHT,e),o=y(l,r.BISHOP,e);return!i||!t||!o?null:i.x<4?{fromX:t.x,fromY:t.y,toX:i.x+1,toY:i.y}:{fromX:o.x,fromY:o.y,toX:i.x-1,toY:i.y}}function Q(l,e){const i=y(l,r.KING,d(e)),t=z(l,r.BISHOP,e);return!i||t.length<2?null:{fromX:t[0].x,fromY:t[0].y,toX:i.x,toY:i.y>4?i.y-1:i.y+1}}function F(l,e){const i=y(l,r.KING,d(e)),t=y(l,r.PAWN,e);if(!i||!t)return null;const o=e===f.WHITE?1:-1;return{fromX:t.x,fromY:t.y,toX:t.x,toY:t.y+o}}function y(l,e,i){for(let t=0;t<8;t++)for(let o=0;o<8;o++){const s=l.getPiece(o,t);if(s&&s.type===e&&s.color===i)return{x:o,y:t}}return null}function z(l,e,i){const t=[];for(let o=0;o<8;o++)for(let s=0;s<8;s++){const n=l.getPiece(s,o);n&&n.type===e&&n.color===i&&t.push({x:s,y:o})}return t}const J={"e2e4 e7e5 g1f3 b8c6 f1b5":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:3},{fromX:6,fromY:7,toX:5,toY:5},{fromX:1,fromY:0,toX:2,toY:2},{fromX:5,fromY:7,toX:1,toY:5}],"e2e4 c7c5":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:2,fromY:1,toX:2,toY:3}],"e2e4 c7c5 g1f3 d7d6":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:2,fromY:1,toX:2,toY:3},{fromX:6,fromY:7,toX:5,toY:5},{fromX:3,fromY:1,toX:3,toY:2}],"d2d4 d7d5 c2c4":[{fromX:3,fromY:6,toX:3,toY:4},{fromX:3,fromY:1,toX:3,toY:3},{fromX:2,fromY:6,toX:2,toY:4}],"e2e4 c7c6":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:2,fromY:1,toX:2,toY:2}],"e2e4 c7c6 d2d4 d7d5":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:2,fromY:1,toX:2,toY:2},{fromX:3,fromY:6,toX:3,toY:4},{fromX:3,fromY:1,toX:3,toY:3}],"e2e4 e7e6":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:2}],"e2e4 e7e6 d2d4 d7d5":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:2},{fromX:3,fromY:6,toX:3,toY:4},{fromX:3,fromY:1,toX:3,toY:3}],"e2e4 e7e5 g1f3 b8c6 f1c4":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:3},{fromX:6,fromY:7,toX:5,toY:5},{fromX:1,fromY:0,toX:2,toY:2},{fromX:5,fromY:7,toX:2,toY:4}],"e2e4 g8f6":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:6,fromY:0,toX:5,toY:2}],"e2e4 d7d6":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:3,fromY:1,toX:3,toY:2}],"e2e4 e7e5 g1f3 b8c6 d2d4":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:3},{fromX:6,fromY:7,toX:5,toY:5},{fromX:1,fromY:0,toX:2,toY:2},{fromX:3,fromY:6,toX:3,toY:4}],"e2e4 e7e5 f2f4":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:3},{fromX:5,fromY:6,toX:5,toY:4}],c2c4:[{fromX:2,fromY:6,toX:2,toY:4}],"g1f3 d7d5":[{fromX:6,fromY:7,toX:5,toY:5},{fromX:3,fromY:1,toX:3,toY:3}]};class Z{constructor(e,i=5e3){this.color=e,this.transpositionTable=new Map,this.maxTime=i,this.killerMoves=new Map,this.startTime=0}openingMoves=J;transpositionTable;maxTime;startTime;killerMoves;makeMove(e){const i=this.getOpeningMove(e);if(i)return i;const t=this.useEndgameTablebase(e);if(t)return t;if(this.shouldUseMCTS(e))return this.mcts(e);let o=null,s=-1/0;const n=10;this.startTime=Date.now();for(let c=1;c<=n;c++){let a=this.getAllValidMoves(e);a=this.sortMoves(a,e,c);for(const u of a){const h=e.getPiece(u.fromX,u.fromY);if(!h)continue;const m=e.getPiece(u.toX,u.toY);e.movePiece(u.fromX,u.fromY,u.toX,u.toY);const X=e.isKingInCheck(this.color)||this.isCriticalMove(h,u,e)?c+1:c,I=this.minimax(e,X-1,-1/0,1/0,!1);if(e.setPiece(u.fromX,u.fromY,h),e.setPiece(u.toX,u.toY,m),I>s&&(s=I,o=u),Date.now()-this.startTime>this.maxTime)break}if(Date.now()-this.startTime>this.maxTime)break}return o}minimax(e,i,t,o,s){const n=e.toString();if(Date.now()-this.startTime>this.maxTime)return Y(e,this.color);if(this.transpositionTable.has(n))return this.transpositionTable.get(n);if(i>1&&!e.isKingInCheck(this.color)&&-this.minimax(e,i-2,-o,-t,!s)>=o)return o;if(i===0||e.isCheckmate(this.color)||e.isCheckmate(this.getOpponentColor())||Date.now()-this.startTime>this.maxTime){const c=this.quiescenceSearch(e,t,o);return this.transpositionTable.set(n,c),c}if(s){let c=-1/0,a=this.getAllValidMoves(e);a=this.sortMoves(a,e,i);for(const u of a){const h=e.getPiece(u.fromX,u.fromY),m=e.getPiece(u.toX,u.toY);e.movePiece(u.fromX,u.fromY,u.toX,u.toY);const p=this.minimax(e,i-1,t,o,!1);if(e.setPiece(u.fromX,u.fromY,h),e.setPiece(u.toX,u.toY,m),c=Math.max(c,p),t=Math.max(t,p),o<=t){this.addKillerMove(i,u);break}}return this.transpositionTable.set(n,c),c}else{let c=1/0,a=this.getAllValidMoves(e);a=this.sortMoves(a,e,i);for(let u=0;u<a.length;u++){const h=a[u],m=e.getPiece(h.fromX,h.fromY),p=e.getPiece(h.toX,h.toY),I=u>3&&i>2?i-1:i,A=e.isKingInCheck(this.getOpponentColor()),B=m&&m.type===r.PAWN&&(h.toY===0||h.toY===7),x=A||B?I+1:I;e.movePiece(h.fromX,h.fromY,h.toX,h.toY);const M=this.minimax(e,x-1,t,o,!0);if(e.setPiece(h.fromX,h.fromY,m),e.setPiece(h.toX,h.toY,p),c=Math.min(c,M),o=Math.min(o,M),o<=t){this.addKillerMove(i,h);break}}return this.transpositionTable.set(n,c),c}}addKillerMove(e,i){const t=this.killerMoves.get(e)||[],o=t.find(s=>s.move.fromX===i.fromX&&s.move.fromY===i.fromY);o?o.score+=1:t.push({move:i,score:1}),this.killerMoves.set(e,t.sort((s,n)=>n.score-s.score).slice(0,2))}quiescenceSearch(e,i,t,o=0){if(o>=5)return Y(e,this.color);const n=Y(e,this.color);if(n>=t)return t;i<n&&(i=n);const c=this.getAllValidMoves(e).filter(a=>e.isCapture(a.fromX,a.fromY,a.toX,a.toY));for(const a of c){const u=e.getPiece(a.fromX,a.fromY),h=e.getPiece(a.toX,a.toY);if(e.movePiece(a.fromX,a.fromY,a.toX,a.toY),!e.isKingInCheck(this.color)){const p=-this.quiescenceSearch(e,-t,-i,o+1);if(e.setPiece(a.fromX,a.fromY,u),e.setPiece(a.toX,a.toY,h),p>=t)return t;p>i&&(i=p)}else e.setPiece(a.fromX,a.fromY,u),e.setPiece(a.toX,a.toY,h)}return i}getOpponentColor(){return this.color===f.WHITE?f.BLACK:f.WHITE}getAllValidMoves(e){const i=[];for(let t=0;t<8;t++)for(let o=0;o<8;o++){const s=e.getPiece(o,t);if(s&&s.color===this.color){const n=e.getValidMoves(o,t);for(const c of n)if(e.isMoveValid(o,t,c.x,c.y)){const a=e.getPiece(c.x,c.y);e.setPiece(c.x,c.y,s),e.setPiece(o,t,null);const u=!e.isKingInCheck(this.color);e.setPiece(o,t,s),e.setPiece(c.x,c.y,a),u&&i.push({fromX:o,fromY:t,toX:c.x,toY:c.y})}}}return i}sortMoves(e,i,t){return e.sort((o,s)=>{const n=this.killerMoves.get(t);if(n&&n.some(m=>m.move.fromX===o.fromX&&m.move.fromY===o.fromY))return-1;const c=i.getPiece(o.toX,o.toY),a=i.getPiece(s.toX,s.toY);if(c&&!a)return-1;if(!c&&a)return 1;const u=K[`${o.toX},${o.toY}`]||0;return(K[`${s.toX},${s.toY}`]||0)-u})}mcts(e){const t=new Map,o=this.getAllValidMoves(e);for(let h=0;h<1e3;h++){const m=o[Math.floor(Math.random()*o.length)];if(!m||m.fromX===void 0||m.fromY===void 0||m.toX===void 0||m.toY===void 0)continue;const p=this.simulateRandomGame(e,m),X=`${m.fromX},${m.fromY},${m.toX},${m.toY}`;t.set(X,(t.get(X)||0)+p)}if(t.size===0)return null;const s=Array.from(t.entries()).reduce((h,m)=>m[1]>h[1]?m:h)[0],[n,c,a,u]=s.split(",").map(Number);return{fromX:n,fromY:c,toX:a,toY:u}}simulateRandomGame(e,i){if(!i||i.fromX===void 0||i.fromY===void 0||i.toX===void 0||i.toY===void 0)return console.error("Invalid move:",i),0;const t=e.clone();t.movePiece(i.fromX,i.fromY,i.toX,i.toY);let o=this.color,s=this.getAllValidMoves(t);for(;!t.isGameOver()&&s.length>0;){const n=s[Math.floor(Math.random()*s.length)];if(!n||n.fromX===void 0||n.fromY===void 0||n.toX===void 0||n.toY===void 0){console.error("Invalid random move:",n);break}t.movePiece(n.fromX,n.fromY,n.toX,n.toY),o=o===f.WHITE?f.BLACK:f.WHITE,s=this.getAllValidMoves(t)}return t.getWinner()===this.color?1:t.getWinner()===null?.5:0}shouldUseMCTS(e){return e.getPieceCount()<=10}useEndgameTablebase(e){return e.getPieceCount()<=4?q(e,this.color):null}isCriticalMove(e,i,t){const o=t.getPiece(i.toX,i.toY);return o&&o.color!==e.color&&o.type!==r.PAWN}getOpeningMove(e){const i=this.getBoardHash(e);if(this.openingMoves[i]){const t=this.openingMoves[i][0];return flipMove(t,this.color===f.BLACK)}return null}getBoardHash(e){let i="";for(let t=0;t<8;t++)for(let o=0;o<8;o++){const s=e.getPiece(o,t);if(s){const n=s.color===f.WHITE?s.type:s.type.toLowerCase();i+=n+o+t+" "}}return i.trim()}}class H extends E{hasMoved=!1;_toX=null;_toY=null;_board=null;constructor(e){super(e,r.PAWN)}isValidMove(e,i,t,o,s){const n=s.getPlayerColor(),c=this.color===f.WHITE?1:-1,a=this.color===f.WHITE?1:6,u=(o-i)*c,h=Math.abs(t-e),m=n===f.WHITE?7:0;if(h===0&&u===1&&!s.getPiece(t,o))return o===m?this.handlePromotion(t,o,s):!0;if(h===1&&u===1){if(s.getPiece(t,o)&&this.canCapture(t,o,s))return o===m?this.handlePromotion(t,o,s):!0;if(s.isEnPassantMove(e,i,t,o))return!0}return h===0&&u===2&&i===a&&!s.getPiece(t,o)&&!s.getPiece(e,i+c)?(s.updateEnPassantTarget(e,i,t,o,this),!0):!1}handlePromotion(e,i,t){return this._toX=e,this._toY=i,this._board=t,!0}}var b=Object.freeze({__proto__:null,Pawn:H});let W;self.onmessage=async l=>{const{boardData:e,aiColor:i}=l.data;W=new Z(i);const t=await v.fromData(e),o=W.makeMove(t);let s=null;if(o&&t.isCapture(o.fromX,o.fromY,o.toX,o.toY)){const c=t.getPiece(o.toX,o.toY);c&&(s={capturedWhite:[],capturedBlack:[]},c.color===f.WHITE?s.capturedWhite.push(c.type):s.capturedBlack.push(c.type))}let n=!1;if(o&&t.getPiece(o.fromX,o.fromY)?.type===r.PAWN){const c=t.getPiece(o.fromX,o.fromY);if(c instanceof H){const a=i===f.WHITE?7:0;o.toY===a&&(n=c.handlePromotion(o.toX,o.toY,t))}}self.postMessage({bestMove:o,captureData:s,promotionRequired:n})};export{E as P,r as a,g as c};
//# sourceMappingURL=ai.worker-8vNT9_Ua.js.map
