{"version":3,"file":"index-Cam73SYv.js","sources":["../../src/piece.ts","../../src/pieces/rook.ts","../../src/pieces/knight.ts","../../src/pieces/bishop.ts","../../src/pieces/queen.ts","../../src/pieces/king.ts","../../src/pieces/pawn.ts","../../src/utils.ts","../../src/board.ts","../../src/evaluator.ts","../../src/ai.ts","../../src/game.ts","../../src/canvas-renderer.ts","../../src/timer.ts","../../src/index.ts"],"sourcesContent":["// src/piece.ts\nimport { Board } from './board';\n\nexport enum PieceColor {\n  WHITE = 'white',\n  BLACK = 'black',\n}\n\nexport enum PieceType {\n  PAWN = 'pawn',\n  ROOK = 'rook',\n  KNIGHT = 'knight',\n  BISHOP = 'bishop',\n  QUEEN = 'queen',\n  KING = 'king',\n}\n\nexport abstract class Piece {\n  protected constructor(\n    public color: PieceColor,\n    public type: PieceType,\n  ) {}\n\n  // Mise à jour pour inclure le paramètre 'board'\n  abstract isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean;\n\n  // Vérifie si le chemin est dégagé pour certaines pièces\n  public isPathClear(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    const dx = Math.sign(toX - fromX); // Direction en X\n    const dy = Math.sign(toY - fromY); // Direction en Y\n\n    // Boucle sur toutes les cases intermédiaires jusqu'à la case cible exclue\n    let x = fromX + dx;\n    let y = fromY + dy;\n\n    while (x !== toX || y !== toY) {\n      if (board.getPiece(x, y) !== null) {\n        return false; // Le chemin est bloqué\n      }\n\n      // Avance dans la direction\n      x += dx;\n      y += dy;\n    }\n\n    return true; // Chemin dégagé\n  }\n\n  // Vérifie si une pièce peut capturer une autre\n  canCapture(toX: number, toY: number, board: Board): boolean {\n    const targetPiece = board.getPiece(toX, toY);\n    // La capture est valide si la case est vide ou si la pièce est d'une couleur opposée\n    return !targetPiece || targetPiece.color !== this.color;\n  }\n}\n","// src/pieces/rook.ts\nimport { Piece, PieceColor, PieceType } from '../piece';\nimport { Board } from '../board';\n\nexport class Rook extends Piece {\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.ROOK);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    // Vérifie si le mouvement est en ligne droite\n    const isStraightMove = fromX === toX || fromY === toY;\n    if (!isStraightMove) {\n      return false;\n    }\n\n    // Vérifie que le chemin est dégagé\n    const isPathClear = this.isPathClear(fromX, fromY, toX, toY, board);\n    if (!isPathClear) {\n      return false;\n    }\n\n    // Vérifie si la tour peut capturer la pièce cible\n    return this.canCapture(toX, toY, board);\n  }\n}\n","// src/pieces/knight.ts\nimport { Piece, PieceColor, PieceType } from '../piece';\nimport { Board } from '../board';\n\nexport class Knight extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.KNIGHT);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    // Le Cavalier se déplace en L : 2 cases dans une direction puis 1 case perpendiculairement\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n    return (\n      ((dx === 2 && dy === 1) || (dx === 1 && dy === 2)) &&\n      this.canCapture(toX, toY, board)\n    );\n  }\n}\n","// src/pieces/bishop.ts\nimport { Piece, PieceColor, PieceType } from '../piece';\nimport { Board } from '../board';\n\nexport class Bishop extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.BISHOP);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    // Le fou se déplace en diagonale\n    if (Math.abs(toX - fromX) === Math.abs(toY - fromY)) {\n      // Vérifie que la trajectoire est dégagée\n      if (this.isPathClear(fromX, fromY, toX, toY, board)) {\n        // Vérifie si la cible est vide ou contient une pièce ennemie\n        return this.canCapture(toX, toY, board);\n      }\n    }\n\n    return false;\n  }\n}\n","// src/pieces/queen.ts\nimport { Piece, PieceColor, PieceType } from '../piece';\nimport { Board } from '../board';\n\nexport class Queen extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.QUEEN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    // La reine peut se déplacer en ligne droite ou en diagonale\n    if (\n      fromX === toX || // Déplacement en colonne\n      fromY === toY || // Déplacement en ligne\n      Math.abs(toX - fromX) === Math.abs(toY - fromY) // Déplacement en diagonale\n    ) {\n      // Vérifie que la trajectoire est dégagée\n      if (this.isPathClear(fromX, fromY, toX, toY, board)) {\n        // Vérifie si la cible est vide ou contient une pièce ennemie\n        return this.canCapture(toX, toY, board);\n      }\n    }\n\n    return false;\n  }\n}\n","import { Piece, PieceColor, PieceType } from '../piece';\nimport { Board } from '../board';\nimport { Rook } from './rook';\n\nexport class King extends Piece {\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.KING);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n\n    // Vérification pour le mouvement classique du roi\n    if (dx <= 1 && dy <= 1) {\n      const targetPiece = board.getPiece(toX, toY);\n      return (\n        this.canCapture(toX, toY, board) &&\n        (!targetPiece || targetPiece.type !== PieceType.KING)\n      );\n    }\n\n    // Logique pour le roque (grand ou petit)\n    if (!this.hasMoved && dy === 0 && dx === 2) {\n      const direction = toX > fromX ? 1 : -1;\n      const rookX = toX > fromX ? 7 : 0;\n      const rook = board.getPiece(rookX, fromY);\n\n      if (rook && rook instanceof Rook && !rook.hasMoved) {\n        // Vérifie que les cases entre le roi et la tour sont libres\n        for (let x = fromX + direction; x !== rookX; x += direction) {\n          if (board.getPiece(x, fromY)) return false;\n        }\n\n        // Assure que le roi n'est pas en échec avant, pendant ou après le roque\n        if (\n          !board.isKingInCheck(this.color) &&\n          !board.isSquareUnderAttack(fromX + direction, fromY, this.color) &&\n          !board.isSquareUnderAttack(toX, fromY, this.color)\n        ) {\n          return true; // Roque valide\n        }\n      }\n    }\n\n    return false;\n  }\n}\n","// src/pieces/pawn.ts\nimport { Piece, PieceColor, PieceType } from '../piece';\nimport { Board } from '../board';\n\nexport class Pawn extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.PAWN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    const direction = this.color === PieceColor.WHITE ? 1 : -1;\n    const startRow = this.color === PieceColor.WHITE ? 1 : 6;\n    const distanceY = (toY - fromY) * direction;\n    const distanceX = Math.abs(toX - fromX);\n\n    // 1. Déplacement d'une case vers l'avant (sans capture)\n    if (distanceX === 0 && distanceY === 1) {\n      if (!board.getPiece(toX, toY)) {\n        // Promotion si le pion atteint la dernière rangée\n        if (\n          (this.color === PieceColor.WHITE && toY === 7) ||\n          (this.color === PieceColor.BLACK && toY === 0)\n        ) {\n          this.handlePromotion(toX, toY, board);\n        }\n        return true;\n      }\n    }\n\n    // 2. Déplacement de deux cases vers l'avant depuis la ligne de départ (sans capture)\n    if (distanceX === 0 && distanceY === 2 && fromY === startRow) {\n      if (\n        !board.getPiece(toX, toY) &&\n        !board.getPiece(fromX, fromY + direction)\n      ) {\n        // Mettre à jour la cible de la prise en passant\n        board.updateEnPassantTarget(fromX, fromY, toX, toY, this);\n        return true;\n      }\n    }\n\n    // 3. Capture en diagonale\n    if (distanceX === 1 && distanceY === 1) {\n      // Vérifie qu'il y a une pièce ennemie à capturer\n      if (board.getPiece(toX, toY) && this.canCapture(toX, toY, board)) {\n        // Promotion si le pion atteint la dernière rangée\n        if (\n          (this.color === PieceColor.WHITE && toY === 7) ||\n          (this.color === PieceColor.BLACK && toY === 0)\n        ) {\n          this.handlePromotion(toX, toY, board);\n        }\n        return true;\n      }\n\n      // Prise en passant\n      if (board.isEnPassantMove(fromX, fromY, toX, toY)) {\n        return true;\n      }\n    }\n\n    // Si aucune des conditions n'est remplie, le mouvement est invalide\n    return false;\n  }\n\n  private handlePromotion(toX: number, toY: number, board: Board): void {\n    const promotionDialog = document.getElementById('promotionDialog');\n    if (promotionDialog) {\n      promotionDialog.style.display = 'block';\n\n      // Définis la fonction promote sur l'objet global window\n      window.promote = (pieceType: string) => {\n        promotionDialog.style.display = 'none';\n        board.promotePawn(toX, toY, pieceType);\n      };\n    }\n  }\n}\n","// src/utils.ts\n\nimport { PieceColor, PieceType } from './piece';\n\nexport let capturedWhite: string[] = []; // Exportation pour les tests\nexport let capturedBlack: string[] = [];\n\nexport function showMessage(message: string) {\n  const gameMessageElement = document.getElementById('gameMessage')!;\n  gameMessageElement.textContent = message;\n  gameMessageElement.style.display = 'block'; // Afficher le message\n}\n\nfunction getPieceSymbol(piece: PieceType, color: PieceColor): string {\n  switch (piece) {\n    case PieceType.PAWN:\n      return color === PieceColor.WHITE ? '♙' : '♟';\n    case PieceType.ROOK:\n      return color === PieceColor.WHITE ? '♖' : '♜';\n    case PieceType.KNIGHT:\n      return color === PieceColor.WHITE ? '♘' : '♞';\n    case PieceType.BISHOP:\n      return color === PieceColor.WHITE ? '♗' : '♝';\n    case PieceType.QUEEN:\n      return color === PieceColor.WHITE ? '♕' : '♛';\n    case PieceType.KING:\n      return color === PieceColor.WHITE ? '♔' : '♚';\n    default:\n      return '';\n  }\n}\n\nexport function updateCapturedPieces(piece: PieceType, color: PieceColor) {\n  const capturedWhiteElement = document.getElementById('capturedWhite')!;\n  const capturedBlackElement = document.getElementById('capturedBlack')!;\n\n  const pieceSymbol = getPieceSymbol(piece, color);\n  if (color === PieceColor.WHITE) {\n    capturedWhite.push(pieceSymbol);\n    capturedWhiteElement.textContent = capturedWhite.join(' ');\n  } else {\n    capturedBlack.push(pieceSymbol);\n    capturedBlackElement.textContent = capturedBlack.join(' ');\n  }\n}\n","// src/board.ts\nimport { Piece, PieceColor, PieceType } from './piece';\nimport { Rook } from './pieces/rook';\nimport { Knight } from './pieces/knight';\nimport { Bishop } from './pieces/bishop';\nimport { Queen } from './pieces/queen';\nimport { King } from './pieces/king';\nimport { Pawn } from './pieces/pawn';\nimport { updateCapturedPieces } from './utils';\n\ntype BoardSquare = Piece | null;\n\nexport class Board {\n  private readonly grid: BoardSquare[][];\n  private enPassantTarget: { x: number; y: number } | null = null;\n  private halfMoveCount: number = 0; // Compteur pour la règle des 50 coups\n\n  constructor() {\n    this.grid = this.initializeBoard();\n  }\n\n  public initializeBoard(): BoardSquare[][] {\n    const board: BoardSquare[][] = Array(8)\n      .fill(null)\n      .map(() => Array(8).fill(null));\n\n    // Ajouter les pièces blanches\n    board[0] = [\n      new Rook(PieceColor.WHITE),\n      new Knight(PieceColor.WHITE),\n      new Bishop(PieceColor.WHITE),\n      new Queen(PieceColor.WHITE),\n      new King(PieceColor.WHITE),\n      new Bishop(PieceColor.WHITE),\n      new Knight(PieceColor.WHITE),\n      new Rook(PieceColor.WHITE),\n    ];\n    board[1] = Array(8)\n      .fill(null)\n      .map(() => new Pawn(PieceColor.WHITE));\n\n    // Ajouter les pièces noires\n    board[7] = [\n      new Rook(PieceColor.BLACK),\n      new Knight(PieceColor.BLACK),\n      new Bishop(PieceColor.BLACK),\n      new Queen(PieceColor.BLACK),\n      new King(PieceColor.BLACK),\n      new Bishop(PieceColor.BLACK),\n      new Knight(PieceColor.BLACK),\n      new Rook(PieceColor.BLACK),\n    ];\n    board[6] = Array(8)\n      .fill(null)\n      .map(() => new Pawn(PieceColor.BLACK));\n\n    return board;\n  }\n\n  public setupInitialPosition(): void {\n    this.clearBoard();\n\n    // Ajouter les pièces blanches\n    this.grid[0] = [\n      new Rook(PieceColor.WHITE),\n      new Knight(PieceColor.WHITE),\n      new Bishop(PieceColor.WHITE),\n      new Queen(PieceColor.WHITE),\n      new King(PieceColor.WHITE),\n      new Bishop(PieceColor.WHITE),\n      new Knight(PieceColor.WHITE),\n      new Rook(PieceColor.WHITE),\n    ];\n    this.grid[1] = Array(8)\n      .fill(null)\n      .map(() => new Pawn(PieceColor.WHITE));\n\n    // Ajouter les pièces noires\n    this.grid[7] = [\n      new Rook(PieceColor.BLACK),\n      new Knight(PieceColor.BLACK),\n      new Bishop(PieceColor.BLACK),\n      new Queen(PieceColor.BLACK),\n      new King(PieceColor.BLACK),\n      new Bishop(PieceColor.BLACK),\n      new Knight(PieceColor.BLACK),\n      new Rook(PieceColor.BLACK),\n    ];\n    this.grid[6] = Array(8)\n      .fill(null)\n      .map(() => new Pawn(PieceColor.BLACK));\n  }\n\n  // Méthode générale pour vérifier les limites\n  public isWithinBounds(x: number, y: number): boolean {\n    return x >= 0 && x < 8 && y >= 0 && y < 8;\n  }\n\n  public getPiece(x: number, y: number): BoardSquare {\n    return this.grid[y][x];\n  }\n\n  public getValidMoves(x: number, y: number): { x: number; y: number }[] {\n    let piece = null;\n    if (this.isWithinBounds(x, y)) piece = this.getPiece(x, y);\n    if (!piece) return [];\n\n    const validMoves: { x: number; y: number }[] = [];\n\n    for (let toY = 0; toY < 8; toY++) {\n      for (let toX = 0; toX < 8; toX++) {\n        if (piece.isValidMove(x, y, toX, toY, this)) {\n          validMoves.push({ x: toX, y: toY });\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  public getKingInCheck(): { x: number; y: number } | null {\n    if (this.isKingInCheck(PieceColor.WHITE)) {\n      return this.findKing(PieceColor.WHITE);\n    } else if (this.isKingInCheck(PieceColor.BLACK)) {\n      return this.findKing(PieceColor.BLACK);\n    }\n    return null;\n  }\n\n  public movePiece(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (\n      toY < 0 ||\n      toY >= this.grid.length ||\n      fromY < 0 ||\n      fromY >= this.grid.length ||\n      ['__proto__', 'constructor', 'prototype'].includes(toY.toString()) ||\n      ['__proto__', 'constructor', 'prototype'].includes(fromY.toString())\n    ) {\n      return false; // Invalid move if fromY or toY is out of bounds or a special property name\n    }\n\n    let piece = null;\n    if (this.isWithinBounds(fromX, fromY)) piece = this.getPiece(fromX, fromY);\n\n    if (piece && piece.isValidMove(fromX, fromY, toX, toY, this)) {\n      let targetPiece = null;\n      if (this.isWithinBounds(toX, toY)) targetPiece = this.getPiece(toX, toY);\n\n      if (targetPiece && targetPiece.type === PieceType.KING) {\n        return false; // Mouvement invalide si la cible est un roi\n      }\n\n      if (this.isEnPassantMove(fromX, fromY, toX, toY)) {\n        this.captureEnPassant(fromX, fromY, toX, toY);\n      }\n\n      // Vérifie si c'est un mouvement de roque pour le roi\n      if (piece instanceof King && Math.abs(toX - fromX) === 2) {\n        if (!this.isCastlingValid(piece, fromX, fromY, toX)) {\n          return false; // Roque invalide\n        }\n\n        // Effectue le roque\n        this.handleCastling(toX, fromY);\n      }\n\n      // Sauvegarder l'état actuel pour vérifier l'échec\n      let originalPiece = null;\n      if (this.isWithinBounds(toX, toY))\n        originalPiece = this.getPiece(toX, toY);\n      this.grid[toY][toX] = piece;\n      this.grid[fromY][fromX] = null;\n\n      // Vérification de l'échec après le mouvement\n      if (this.isKingInCheck(piece.color)) {\n        // Annuler le mouvement\n        this.grid[fromY][fromX] = piece;\n        this.grid[toY][toX] = originalPiece;\n        return false;\n      }\n\n      // Compte les mouvements pour la règle des 50 coups\n      if (piece.type === PieceType.PAWN || targetPiece) {\n        this.halfMoveCount = 0; // Réinitialise le compteur si un pion bouge ou si une capture a lieu\n      } else {\n        this.halfMoveCount++;\n      }\n\n      // Déplace la pièce\n      this.grid[toY][toX] = piece;\n      this.grid[fromY][fromX] = null;\n\n      // Met à jour l'état du roi et des tours pour le roque\n      if (piece instanceof King) {\n        piece.hasMoved = true;\n      } else if (piece instanceof Rook) {\n        piece.hasMoved = true;\n      }\n\n      return true;\n    }\n    return false;\n  }\n\n  private isCastlingValid(\n    king: King,\n    fromX: number,\n    fromY: number,\n    toX: number,\n  ): boolean {\n    const direction = toX > fromX ? 1 : -1;\n    const rookX = toX > fromX ? 7 : 0;\n    let rook = null;\n    if (this.isWithinBounds(rookX, fromY)) rook = this.getPiece(rookX, fromY);\n\n    if (!(rook instanceof Rook) || rook.hasMoved || king.hasMoved) {\n      return false;\n    }\n\n    // Vérifie que les cases entre le roi et la tour sont libres\n    for (let x = fromX + direction; x !== rookX; x += direction) {\n      if (this.getPiece(x, fromY)) {\n        return false;\n      }\n    }\n\n    // Assure que le roi ne passe pas par une case attaquée\n    for (let x = fromX; x !== toX + direction; x += direction) {\n      if (this.isSquareUnderAttack(x, fromY, king.color)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private handleCastling(kingX: number, kingY: number): void {\n    // Déplacement pour le petit roque (roi se déplace vers la droite)\n    if (kingX === 6) {\n      const rook = this.getPiece(7, kingY);\n      if (rook instanceof Rook) {\n        this.movePiece(7, kingY, 5, kingY);\n      }\n    }\n    // Déplacement pour le grand roque (roi se déplace vers la gauche)\n    else if (kingX === 2) {\n      const rook = this.getPiece(0, kingY);\n      if (rook instanceof Rook) {\n        this.movePiece(0, kingY, 3, kingY);\n      }\n    }\n  }\n\n  public updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    if (piece instanceof Pawn && Math.abs(toY - fromY) === 2 && fromX === toX) {\n      // Si le pion avance de deux cases, configure la cible pour la prise en passant\n      this.enPassantTarget = { x: toX, y: (fromY + toY) / 2 };\n    } else {\n      this.enPassantTarget = null;\n    }\n  }\n\n  public captureEnPassant(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): void {\n    const piece = this.getPiece(fromX, fromY);\n\n    // Vérifie que le mouvement est une prise en passant valide\n    if (this.isEnPassantMove(fromX, fromY, toX, toY) && piece instanceof Pawn) {\n      // Détermine la direction pour la capture en passant\n      const direction = piece.color === PieceColor.WHITE ? -1 : 1;\n\n      // Calcul de la position du pion capturé (en passant)\n      const capturedPawnY = toY + direction; // Position Y du pion capturé\n      const capturedPawn = this.getPiece(toX, capturedPawnY);\n\n      // Vérifie si un pion est bien présent à capturer\n      if (capturedPawn && capturedPawn.type === PieceType.PAWN) {\n        this.grid[capturedPawnY][toX] = null;\n        updateCapturedPieces(capturedPawn.type, capturedPawn.color);\n      }\n\n      // Déplace le pion qui effectue la capture\n      this.grid[toY][toX] = piece;\n      this.grid[fromY][fromX] = null;\n    }\n  }\n\n  public isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (!this.enPassantTarget) return false;\n\n    // Vérifie que le mouvement cible la bonne case pour la prise en passant\n    const piece = this.getPiece(fromX, fromY);\n    return (\n      piece instanceof Pawn &&\n      toX === this.enPassantTarget.x &&\n      toY === this.enPassantTarget.y &&\n      Math.abs(fromX - toX) === 1 &&\n      Math.abs(fromY - toY) === 1\n    );\n  }\n\n  public promotePawn(x: number, y: number, pieceType: string): void {\n    const color = this.getPiece(x, y)?.color;\n\n    if (!color) return;\n\n    switch (pieceType) {\n      case 'queen':\n        this.grid[y][x] = new Queen(color);\n        break;\n      case 'rook':\n        this.grid[y][x] = new Rook(color);\n        break;\n      case 'bishop':\n        this.grid[y][x] = new Bishop(color);\n        break;\n      case 'knight':\n        this.grid[y][x] = new Knight(color);\n        break;\n    }\n  }\n\n  public isKingInCheck(color: PieceColor): boolean {\n    const kingPosition = this.findKing(color);\n    if (!kingPosition) {\n      return false;\n    }\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(x, y, kingPosition.x, kingPosition.y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  public isCheckmate(color: PieceColor): boolean {\n    if (!this.isKingInCheck(color)) {\n      return false;\n    }\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          for (let toY = 0; toY < 8; toY++) {\n            for (let toX = 0; toX < 8; toX++) {\n              if (piece.isValidMove(x, y, toX, toY, this)) {\n                const originalPiece = this.getPiece(toX, toY);\n                this.grid[toY][toX] = piece;\n                this.grid[y][x] = null;\n\n                const kingSafe = !this.isKingInCheck(color);\n\n                this.grid[y][x] = piece;\n                this.grid[toY][toX] = originalPiece;\n\n                if (kingSafe) {\n                  return false;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  public isStalemate(color: PieceColor): boolean {\n    if (this.isKingInCheck(color)) {\n      return false;\n    }\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          for (let toY = 0; toY < 8; toY++) {\n            for (let toX = 0; toX < 8; toX++) {\n              if (piece.isValidMove(x, y, toX, toY, this)) {\n                const originalPiece = this.getPiece(toX, toY);\n                this.grid[toY][toX] = piece;\n                this.grid[y][x] = null;\n\n                const kingSafe = !this.isKingInCheck(color);\n\n                this.grid[y][x] = piece;\n                this.grid[toY][toX] = originalPiece;\n\n                if (kingSafe) {\n                  return false;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  private findKing(color: PieceColor): { x: number; y: number } | null {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece instanceof King && piece.color === color) {\n          return { x, y };\n        }\n      }\n    }\n    return null;\n  }\n\n  public isSquareUnderAttack(x: number, y: number, color: PieceColor): boolean {\n    for (let fromY = 0; fromY < 8; fromY++) {\n      for (let fromX = 0; fromX < 8; fromX++) {\n        const piece = this.getPiece(fromX, fromY);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(fromX, fromY, x, y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Vérifie le matériel insuffisant pour un échec et mat\n  public isInsufficientMaterial(): boolean {\n    const pieces = this.grid.flat().filter((piece) => piece !== null);\n\n    // Cas les plus courants de matériel insuffisant\n    if (pieces.length <= 2) return true; // Seulement les rois sur le plateau\n    return (\n      pieces.length === 3 &&\n      pieces.some(\n        (piece) =>\n          piece?.type === PieceType.BISHOP || piece?.type === PieceType.KNIGHT,\n      )\n    );\n  }\n\n  // Vérifie si la règle des 50 coups est remplie\n  public isFiftyMoveRule(): boolean {\n    return this.halfMoveCount >= 50;\n  }\n\n  public setPiece(x: number, y: number, piece: Piece | null): void {\n    this.grid[y][x] = piece;\n  }\n\n  public clearBoard(): void {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        this.grid[y][x] = null;\n      }\n    }\n  }\n\n  // Vérifie si un mouvement est valide\n  public isMoveValid(\n    fromRow: number,\n    fromCol: number,\n    toRow: number,\n    toCol: number,\n  ): boolean {\n    const piece = this.getPiece(fromRow, fromCol);\n\n    // Si aucune pièce n'est présente à l'emplacement source, le mouvement est invalide\n    if (!piece) {\n      return false;\n    }\n\n    // Si la destination est en dehors de l'échiquier, mouvement invalide\n    if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) {\n      return false;\n    }\n\n    // Vérifie si la pièce peut se déplacer à cette destination en utilisant la logique de mouvement de la pièce\n    if (!piece.isValidMove(fromRow, fromCol, toRow, toCol, this)) {\n      return false;\n    }\n\n    // Vérifie s'il y a une pièce à la destination et si elle est de la même couleur\n    const destinationPiece = this.getPiece(toRow, toCol);\n    return !(destinationPiece && destinationPiece.color === piece.color);\n  }\n\n  public isCapture(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    const piece = this.isWithinBounds(fromX, fromY)\n      ? this.getPiece(fromX, fromY)\n      : null;\n    const targetPiece = this.isWithinBounds(toX, toY)\n      ? this.getPiece(toX, toY)\n      : null;\n\n    // Vérifie qu'il y a une pièce à la position cible et qu'elle est d'une couleur opposée\n    return (\n      piece !== null &&\n      targetPiece !== null &&\n      piece.color !== targetPiece.color\n    );\n  }\n}\n","import { Board } from './board';\nimport { Piece, PieceColor, PieceType } from './piece';\n\n// Valeurs des pièces (évaluation de base)\nconst pieceValues: { [key in PieceType]: number } = {\n  [PieceType.PAWN]: 1,\n  [PieceType.KNIGHT]: 3,\n  [PieceType.BISHOP]: 3.25,\n  [PieceType.ROOK]: 5,\n  [PieceType.QUEEN]: 9,\n  [PieceType.KING]: 0,\n};\n\n// Tables de positions pour améliorer l'évaluation\nconst pieceSquareTables: { [key in PieceType]: number[][] } = {\n  [PieceType.PAWN]: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n    [0.1, 0.1, 0.2, 0.3, 0.3, 0.2, 0.1, 0.1],\n    [0.05, 0.05, 0.1, 0.25, 0.25, 0.1, 0.05, 0.05],\n    [0, 0, 0, 0.2, 0.2, 0, 0, 0],\n    [0.05, -0.05, -0.1, 0, 0, -0.1, -0.05, 0.05],\n    [0.05, 0.1, 0.1, -0.2, -0.2, 0.1, 0.1, 0.05],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n  ],\n  [PieceType.KNIGHT]: [\n    [-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5],\n    [-0.4, -0.2, 0, 0, 0, 0, -0.2, -0.4],\n    [-0.3, 0, 0.1, 0.15, 0.15, 0.1, 0, -0.3],\n    [-0.3, 0.05, 0.15, 0.2, 0.2, 0.15, 0.05, -0.3],\n    [-0.3, 0, 0.15, 0.2, 0.2, 0.15, 0, -0.3],\n    [-0.3, 0.05, 0.1, 0.15, 0.15, 0.1, 0.05, -0.3],\n    [-0.4, -0.2, 0, 0.05, 0.05, 0, -0.2, -0.4],\n    [-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5],\n  ],\n  [PieceType.BISHOP]: [\n    [-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2],\n    [-0.1, 0, 0, 0, 0, 0, 0, -0.1],\n    [-0.1, 0, 0.05, 0.1, 0.1, 0.05, 0, -0.1],\n    [-0.1, 0.05, 0.05, 0.1, 0.1, 0.05, 0.05, -0.1],\n    [-0.1, 0, 0.1, 0.1, 0.1, 0.1, 0, -0.1],\n    [-0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, -0.1],\n    [-0.1, 0.05, 0, 0, 0, 0, 0.05, -0.1],\n    [-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2],\n  ],\n  [PieceType.ROOK]: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [0, 0, 0, 0.05, 0.05, 0, 0, 0],\n  ],\n  [PieceType.QUEEN]: [\n    [-0.2, -0.1, -0.1, -0.05, -0.05, -0.1, -0.1, -0.2],\n    [-0.1, 0, 0, 0, 0, 0, 0, -0.1],\n    [-0.1, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.1],\n    [-0.05, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.05],\n    [0, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.05],\n    [-0.1, 0.05, 0.05, 0.05, 0.05, 0.05, 0, -0.1],\n    [-0.1, 0, 0.05, 0, 0, 0, 0, -0.1],\n    [-0.2, -0.1, -0.1, -0.05, -0.05, -0.1, -0.1, -0.2],\n  ],\n  [PieceType.KING]: [\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.2, -0.3, -0.3, -0.4, -0.4, -0.3, -0.3, -0.2],\n    [-0.1, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.1],\n    [0.2, 0.2, 0, 0, 0, 0, 0.2, 0.2],\n    [0.2, 0.3, 0, 0, 0, 0, 0.3, 0.2],\n  ],\n};\n\n// Bonus pour le contrôle du centre du plateau (cases centrales plus précieuses)\nexport const centerControlBonus: { [key: string]: number } = {\n  '3,3': 0.5,\n  '3,4': 0.5,\n  '4,3': 0.5,\n  '4,4': 0.5, // Cases centrales\n  '2,3': 0.25,\n  '2,4': 0.25,\n  '3,2': 0.25,\n  '4,2': 0.25,\n  '4,5': 0.25,\n  '3,5': 0.25,\n  '5,3': 0.25,\n  '5,4': 0.25, // Cases autour\n};\n\n// Fonction d'évaluation principale\nexport function evaluateBoard(board: Board, color: PieceColor): number {\n  let score = 0;\n\n  for (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n      const piece = board.getPiece(x, y);\n      if (piece) {\n        let pieceScore = pieceValues[piece.type];\n\n        const pieceTable = pieceSquareTables[piece.type];\n        if (pieceTable) {\n          pieceScore += pieceTable[y][x];\n        }\n\n        const positionKey = `${x},${y}`;\n        if (centerControlBonus[positionKey]) {\n          pieceScore += centerControlBonus[positionKey];\n        }\n\n        if (piece.type === PieceType.PAWN) {\n          pieceScore += evaluatePawnStructure(board, x, y, piece.color);\n        }\n\n        if (\n          piece.type === PieceType.BISHOP &&\n          hasBishopPair(board, piece.color)\n        ) {\n          pieceScore += 0.5;\n        }\n\n        if (isKingExposed(board, x, y, piece.color)) {\n          pieceScore -= 0.5;\n        }\n\n        score += piece.color === color ? pieceScore : -pieceScore;\n      }\n    }\n  }\n\n  return score;\n}\n\n// Évaluer la structure des pions\n// Évaluer la structure des pions\nfunction evaluatePawnStructure(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  let score = 0;\n\n  // Vérifier les pions doublés et isolés avec une pénalité plus importante\n  score -= checkDoubledPawns(board, x, y, color) * 1.5; // Pénalité augmentée pour les pions doublés\n  score -= checkIsolatedPawns(board, x, y, color) * 1.5; // Pénalité augmentée pour les pions isolés\n\n  return score;\n}\n\nfunction checkDoubledPawns(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  for (let i = 0; i < 8; i++) {\n    if (\n      i !== y &&\n      board.getPiece(x, i)?.type === PieceType.PAWN &&\n      board.getPiece(x, i)?.color === color\n    ) {\n      return 0.5;\n    }\n  }\n  return 0;\n}\n\nfunction checkIsolatedPawns(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  const leftColumn = x - 1 >= 0 ? board.getPiece(x - 1, y) : null;\n  const rightColumn = x + 1 < 8 ? board.getPiece(x + 1, y) : null;\n\n  if (\n    (!leftColumn ||\n      leftColumn.type !== PieceType.PAWN ||\n      leftColumn.color !== color) &&\n    (!rightColumn ||\n      rightColumn.type !== PieceType.PAWN ||\n      rightColumn.color !== color)\n  ) {\n    return 1.5; // Augmentation de la pénalité pour les pions isolés\n  }\n\n  return 0;\n}\n\nfunction hasBishopPair(board: Board, color: PieceColor): boolean {\n  const bishops = getPieces(board, color).filter(\n    (piece) => piece.type === PieceType.BISHOP,\n  );\n  return bishops.length === 2;\n}\n\nfunction isKingExposed(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): boolean {\n  const piece = board.getPiece(x, y);\n  if (piece && piece.type === PieceType.KING) {\n    const surroundingSquares = [\n      { dx: -1, dy: 0 },\n      { dx: 1, dy: 0 },\n      { dx: 0, dy: -1 },\n      { dx: 0, dy: 1 },\n    ];\n\n    return surroundingSquares.some(({ dx, dy }) => {\n      const newX = x + dx;\n      const newY = y + dy;\n\n      // Utilise `isWithinBounds` pour vérifier que les coordonnées sont valides avant d'accéder à la pièce\n      if (board.isWithinBounds(newX, newY)) {\n        const adjPiece = board.getPiece(newX, newY);\n        return (\n          !adjPiece ||\n          adjPiece.color !== color ||\n          adjPiece.type === PieceType.KING\n        );\n      }\n\n      // Si la case est hors des limites, considère que le roi est exposé\n      return true;\n    });\n  }\n  return false;\n}\n\n// Nouvelle méthode pour obtenir toutes les pièces d'une certaine couleur sur le plateau\nexport function getPieces(board: Board, color: PieceColor): Piece[] {\n  const pieces: Piece[] = [];\n\n  for (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n      const piece = board.getPiece(x, y);\n      if (piece && piece.color === color) {\n        pieces.push(piece);\n      }\n    }\n  }\n\n  return pieces;\n}\n","import { Board } from './board';\nimport { PieceColor } from './piece';\nimport { evaluateBoard, centerControlBonus } from './evaluator';\n\n// Classe AI utilisant l'algorithme Minimax avec Alpha-Beta Pruning et Transposition Table\nexport class AI {\n  private transpositionTable: Map<string, number>; // Table de transposition\n  private readonly maxTime: number; // Temps maximum de réflexion en millisecondes\n  private startTime: number; // Temps de début pour gestion du temps\n  private readonly killerMoves: {\n    [depth: number]: {\n      fromX: number;\n      fromY: number;\n      toX: number;\n      toY: number;\n    }[];\n  }; // Heuristic des coups efficaces\n\n  constructor(\n    private color: PieceColor,\n    maxTime: number = 5000,\n  ) {\n    this.transpositionTable = new Map();\n    this.maxTime = maxTime;\n    this.killerMoves = {};\n    this.startTime = 0;\n  }\n\n  // Méthode principale pour faire un mouvement\n  public makeMove(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    let bestMove = null;\n    let bestValue = -Infinity;\n    const maxDepth = 7; // Augmentation de la profondeur maximale de recherche\n    this.startTime = Date.now();\n\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      let moves = this.getAllValidMoves(board);\n\n      // Trie les mouvements pour optimiser la recherche\n      moves = this.sortMoves(moves, board, depth);\n\n      for (const move of moves) {\n        const piece = board.getPiece(move.fromX, move.fromY);\n        const originalPiece = board.getPiece(move.toX, move.toY);\n        board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n        // Appelle la recherche Minimax avec Alpha-Beta Pruning\n        const boardValue = this.minimax(\n          board,\n          depth - 1,\n          -Infinity,\n          Infinity,\n          false,\n        );\n\n        board.setPiece(move.fromX, move.fromY, piece);\n        board.setPiece(move.toX, move.toY, originalPiece);\n\n        if (boardValue > bestValue) {\n          bestValue = boardValue;\n          bestMove = move;\n        }\n\n        // Limite le temps de réflexion\n        if (Date.now() - this.startTime > this.maxTime) {\n          break;\n        }\n      }\n\n      // Limite le temps de réflexion\n      if (Date.now() - this.startTime > this.maxTime) {\n        break;\n      }\n    }\n\n    return bestMove;\n  }\n\n  // Fonction Minimax avec Alpha-Beta Pruning et table de transposition\n  private minimax(\n    board: Board,\n    depth: number,\n    alpha: number,\n    beta: number,\n    isMaximizing: boolean,\n  ): number {\n    const boardKey = board.toString();\n\n    if (Date.now() - this.startTime > this.maxTime) {\n      return evaluateBoard(board, this.color);\n    }\n\n    if (this.transpositionTable.has(boardKey)) {\n      return this.transpositionTable.get(boardKey)!;\n    }\n\n    if (\n      depth === 0 ||\n      board.isCheckmate(this.color) ||\n      board.isCheckmate(this.getOpponentColor()) ||\n      Date.now() - this.startTime > this.maxTime\n    ) {\n      const evaluation = this.quiescenceSearch(board, alpha, beta);\n      this.transpositionTable.set(boardKey, evaluation);\n      return evaluation;\n    }\n\n    if (\n      board.isKingInCheck(this.color) &&\n      this.getAllValidMoves(board).length === 0\n    ) {\n      return -Infinity;\n    }\n\n    if (isMaximizing) {\n      let maxEval = -Infinity;\n      let moves = this.getAllValidMoves(board);\n      moves = this.sortMoves(moves, board, depth);\n\n      for (const move of moves) {\n        const fromPiece = board.getPiece(move.fromX, move.fromY);\n        const toPiece = board.getPiece(move.toX, move.toY);\n\n        board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n        const evaluation = this.minimax(board, depth - 1, alpha, beta, false);\n\n        board.setPiece(move.fromX, move.fromY, fromPiece);\n        board.setPiece(move.toX, move.toY, toPiece);\n\n        maxEval = Math.max(maxEval, evaluation);\n        alpha = Math.max(alpha, evaluation);\n\n        if (beta <= alpha) {\n          this.addKillerMove(depth, move);\n          break;\n        }\n      }\n\n      this.transpositionTable.set(boardKey, maxEval);\n      return maxEval;\n    } else {\n      let minEval = Infinity;\n      let moves = this.getAllValidMoves(board);\n      moves = this.sortMoves(moves, board, depth);\n\n      for (const move of moves) {\n        const fromPiece = board.getPiece(move.fromX, move.fromY);\n        const toPiece = board.getPiece(move.toX, move.toY);\n\n        board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n        const evaluation = this.minimax(board, depth - 1, alpha, beta, true);\n\n        board.setPiece(move.fromX, move.fromY, fromPiece);\n        board.setPiece(move.toX, move.toY, toPiece);\n\n        minEval = Math.min(minEval, evaluation);\n        beta = Math.min(beta, evaluation);\n\n        if (beta <= alpha) {\n          this.addKillerMove(depth, move);\n          break;\n        }\n      }\n\n      this.transpositionTable.set(boardKey, minEval);\n      return minEval;\n    }\n  }\n\n  // Ajout d'un coup prometteur dans les killer moves\n  private addKillerMove(\n    depth: number,\n    move: { fromX: number; fromY: number; toX: number; toY: number },\n  ) {\n    if (!this.killerMoves[depth]) {\n      this.killerMoves[depth] = [];\n    }\n    this.killerMoves[depth].push(move);\n  }\n\n  // Recherche de quiescence pour améliorer l'évaluation des positions\n  private quiescenceSearch(board: Board, alpha: number, beta: number): number {\n    const standPat = evaluateBoard(board, this.color);\n\n    if (standPat >= beta) return beta;\n    if (alpha < standPat) alpha = standPat;\n\n    const moves = this.getAllValidMoves(board).filter((move) =>\n      board.isCapture(move.fromX, move.fromY, move.toX, move.toY),\n    );\n\n    for (const move of moves) {\n      const fromPiece = board.getPiece(move.fromX, move.fromY);\n      const toPiece = board.getPiece(move.toX, move.toY);\n\n      board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n      const score = -this.quiescenceSearch(board, -beta, -alpha);\n\n      board.setPiece(move.fromX, move.fromY, fromPiece);\n      board.setPiece(move.toX, move.toY, toPiece);\n\n      if (score >= beta) return beta;\n      if (score > alpha) alpha = score;\n    }\n\n    return alpha;\n  }\n\n  private getOpponentColor(): PieceColor {\n    return this.color === PieceColor.WHITE\n      ? PieceColor.BLACK\n      : PieceColor.WHITE;\n  }\n\n  private getAllValidMoves(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number }[] {\n    const validMoves = [];\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = board.getPiece(x, y);\n\n        if (piece && piece.color === this.color) {\n          const moves = board.getValidMoves(x, y);\n\n          for (const move of moves) {\n            if (board.isMoveValid(x, y, move.x, move.y)) {\n              const originalPiece = board.getPiece(move.x, move.y);\n              board.setPiece(move.x, move.y, piece);\n              board.setPiece(x, y, null);\n\n              const kingSafe = !board.isKingInCheck(this.color);\n\n              board.setPiece(x, y, piece);\n              board.setPiece(move.x, move.y, originalPiece);\n\n              if (kingSafe) {\n                validMoves.push({\n                  fromX: x,\n                  fromY: y,\n                  toX: move.x,\n                  toY: move.y,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  private sortMoves(\n    moves: { fromX: number; fromY: number; toX: number; toY: number }[],\n    board: Board,\n    depth: number,\n  ): {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n  }[] {\n    return moves.sort((a, b) => {\n      if (\n        this.killerMoves[depth] &&\n        this.killerMoves[depth].some(\n          (move) => move.fromX === a.fromX && move.fromY === a.fromY,\n        )\n      )\n        return -1;\n\n      const pieceA = board.getPiece(a.toX, a.toY);\n      const pieceB = board.getPiece(b.toX, b.toY);\n\n      if (pieceA && !pieceB) return -1;\n      if (!pieceA && pieceB) return 1;\n\n      const centerControlA = centerControlBonus[`${a.toX},${a.toY}`] || 0;\n      const centerControlB = centerControlBonus[`${b.toX},${b.toY}`] || 0;\n\n      return centerControlB - centerControlA;\n    });\n  }\n}\n","import { Board } from './board';\nimport { AI } from './ai';\nimport { PieceColor } from './piece';\nimport { updateCapturedPieces } from './utils';\n\nexport class Game {\n  private readonly board: Board;\n  private readonly ai: AI | null;\n\n  constructor() {\n    this.board = new Board();\n    // Initialise l'IA pour jouer avec les Noirs par exemple\n    this.ai = new AI(PieceColor.BLACK);\n  }\n\n  public getBoard(): Board {\n    return this.board;\n  }\n\n  // Méthode pour faire jouer l'IA\n  public makeAIMove(): void {\n    if (this.ai) {\n      const move = this.ai.makeMove(this.board);\n\n      if (move) {\n        const targetPiece = this.board.getPiece(move.toX, move.toY);\n\n        // Si l'IA capture une pièce\n        if (targetPiece) {\n          // Mettre à jour la liste des pièces capturées\n          updateCapturedPieces(targetPiece.type, targetPiece.color);\n        }\n\n        // Effectuer le mouvement de l'IA sur le plateau\n        this.board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n      } else {\n        console.log(\"Aucun mouvement valide pour l'IA.\");\n      }\n    }\n  }\n}\n","// src/canvas-renderer.ts\nimport { Board } from './board';\nimport { Piece, PieceColor } from './piece';\n\nexport class CanvasRenderer {\n  private canvas: HTMLCanvasElement;\n  private context: CanvasRenderingContext2D;\n  private readonly tileSize: number;\n  private draggingPiece: Piece | null = null;\n  private startX: number | null = null;\n  private startY: number | null = null;\n  private highlightedMoves: { x: number; y: number }[] = [];\n  private kingInCheckPosition: { x: number; y: number } | null = null;\n\n  constructor(\n    private board: Board,\n    canvasId: string,\n    private moveHandler: (\n      fromX: number,\n      fromY: number,\n      toX: number,\n      toY: number,\n    ) => boolean, // Utilisation d'un retour booléen pour vérifier si le mouvement est valide\n  ) {\n    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    this.context = this.canvas.getContext('2d')!;\n    this.tileSize = this.canvas.width / 8;\n\n    // Définir le curseur par défaut\n    this.canvas.style.cursor = 'default';\n\n    // Ajouter des écouteurs pour gérer les événements de glisser-déposer\n    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n  }\n\n  // Animation pour déplacer une pièce\n  public animateMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    const frames = 10;\n    let currentFrame = 0;\n\n    const startX = fromX * this.tileSize;\n    const startY = fromY * this.tileSize;\n    const deltaX = ((toX - fromX) * this.tileSize) / frames;\n    const deltaY = ((toY - fromY) * this.tileSize) / frames;\n\n    const animate = () => {\n      if (currentFrame <= frames) {\n        // Redessine l'échiquier pour effacer l'ancienne position de la pièce\n        this.drawBoard();\n\n        this.context.fillStyle =\n          piece.color === PieceColor.WHITE ? 'white' : 'black';\n        this.context.font = '48px Arial';\n        this.context.textAlign = 'center';\n        this.context.textBaseline = 'middle';\n\n        // Dessine la pièce en mouvement\n        this.context.fillText(\n          this.getPieceText(piece),\n          startX + deltaX * currentFrame + this.tileSize / 2,\n          startY + deltaY * currentFrame + this.tileSize / 2,\n        );\n\n        currentFrame++;\n        requestAnimationFrame(animate);\n      } else {\n        // Redessiner l'échiquier à la fin de l'animation pour afficher la pièce à la position finale\n        this.drawBoard();\n      }\n    };\n\n    animate();\n  }\n\n  // Surligne les mouvements valides pour une pièce sélectionnée\n  highlightValidMoves(moves: { x: number; y: number }[]): void {\n    this.context.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Couleur de surlignage (vert translucide)\n    moves.forEach((move) => {\n      this.context.fillRect(\n        move.x * this.tileSize,\n        move.y * this.tileSize,\n        this.tileSize,\n        this.tileSize,\n      );\n    });\n  }\n\n  // Dessiner l'échiquier et les pièces\n  public drawBoard(): void {\n    // Obtenir la position du roi en échec si elle existe\n    const kingInCheck = this.board.getKingInCheck();\n    this.kingInCheckPosition = kingInCheck\n      ? { x: kingInCheck.x, y: kingInCheck.y }\n      : null;\n\n    // Dessiner le plateau\n    this.drawTiles();\n    this.drawPieces();\n  }\n\n  // Dessiner les cases de l'échiquier\n  private drawTiles(): void {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const isDarkTile = (x + y) % 2 === 1;\n        let tileColor = isDarkTile ? '#769656' : '#eeeed2';\n\n        // Si la case contient le roi en échec, change la couleur\n        if (\n          this.kingInCheckPosition &&\n          this.kingInCheckPosition.x === x &&\n          this.kingInCheckPosition.y === y\n        ) {\n          tileColor = '#ff6347'; // Par exemple, une couleur rouge pour indiquer l'échec\n        }\n\n        this.context.fillStyle = tileColor;\n        this.context.fillRect(\n          x * this.tileSize,\n          y * this.tileSize,\n          this.tileSize,\n          this.tileSize,\n        );\n      }\n    }\n  }\n\n  // Dessiner toutes les pièces sur l'échiquier\n  private drawPieces(): void {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.board.getPiece(x, y);\n        if (piece) {\n          this.drawPiece(piece, x, y);\n        }\n      }\n    }\n  }\n\n  // Dessiner une pièce spécifique\n  private drawPiece(piece: Piece, x: number, y: number): void {\n    this.context.fillStyle = piece.color === 'white' ? 'white' : 'black';\n    this.context.font = '48px Arial';\n    this.context.textAlign = 'center';\n    this.context.textBaseline = 'middle';\n    const pieceText = this.getPieceText(piece);\n    this.context.fillText(\n      pieceText,\n      x * this.tileSize + this.tileSize / 2,\n      y * this.tileSize + this.tileSize / 2,\n    );\n  }\n\n  // Convertir le type de pièce en texte pour affichage\n  private getPieceText(piece: Piece): string {\n    switch (piece.type) {\n      case 'pawn':\n        return piece.color === 'white' ? '♙' : '♟';\n      case 'rook':\n        return piece.color === 'white' ? '♖' : '♜';\n      case 'knight':\n        return piece.color === 'white' ? '♘' : '♞';\n      case 'bishop':\n        return piece.color === 'white' ? '♗' : '♝';\n      case 'queen':\n        return piece.color === 'white' ? '♕' : '♛';\n      case 'king':\n        return piece.color === 'white' ? '♔' : '♚';\n      default:\n        return '';\n    }\n  }\n\n  // Gérer le début du glissement\n  private handleMouseDown(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    const piece = this.board.getPiece(x, y);\n    if (piece) {\n      this.draggingPiece = piece;\n      this.startX = x;\n      this.startY = y;\n      this.canvas.style.cursor = 'grabbing'; // Change le curseur pendant le drag\n\n      // Obtenez les mouvements légaux pour la pièce sélectionnée\n      this.highlightedMoves = this.board.getValidMoves(x, y);\n\n      // Redessinez le plateau avec les cases surlignées\n      this.drawBoard();\n      this.highlightValidMoves(this.highlightedMoves); // Surligne les mouvements valides\n    }\n  }\n\n  // Gérer le mouvement pendant le glissement\n  private handleMouseMove(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    // Changer le curseur lorsque la souris survole une pièce\n    let piece = null;\n    if (this.board.isWithinBounds(x, y)) piece = this.board.getPiece(x, y);\n    if (piece && !this.draggingPiece) {\n      this.canvas.style.cursor = 'pointer';\n    } else if (!this.draggingPiece) {\n      this.canvas.style.cursor = 'default';\n    }\n\n    if (!this.draggingPiece) return;\n\n    // Dessiner l'échiquier et les pièces\n    this.drawBoard();\n\n    // Assurez-vous que les mouvements valides restent visibles pendant le glissement\n    this.highlightValidMoves(this.highlightedMoves);\n\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n\n    // Dessiner la pièce en mouvement\n    this.context.fillStyle =\n      this.draggingPiece.color === 'white' ? 'white' : 'black';\n    this.context.font = '48px Arial';\n    this.context.textAlign = 'center';\n    this.context.textBaseline = 'middle';\n    const pieceText = this.getPieceText(this.draggingPiece);\n    this.context.fillText(pieceText, mouseX, mouseY);\n  }\n\n  // Gérer la fin du glissement\n  private handleMouseUp(event: MouseEvent): void {\n    if (!this.draggingPiece || this.startX === null || this.startY === null)\n      return;\n\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    // Utilise la fonction de rappel `moveHandler` pour déplacer la pièce\n    const moveSuccessful = this.moveHandler(this.startX, this.startY, x, y);\n\n    // Réinitialise l'état de glissement\n    this.draggingPiece = null;\n    this.startX = null;\n    this.startY = null;\n    this.canvas.style.cursor = 'default'; // Rétablir le curseur par défaut\n\n    // Efface les coups surlignés\n    this.highlightedMoves = [];\n\n    // Redessine le plateau après la fin du glissement\n    this.drawBoard();\n\n    // Si le mouvement est réussi, met à jour le tour\n    if (moveSuccessful) {\n      this.drawBoard();\n    }\n  }\n}\n","// src/timer.ts\nexport class Timer {\n  private intervalId: number | null = null;\n  private currentTime: number;\n  private readonly onTimeUpdate: (timeLeft: number) => void;\n  public isRunning: boolean = false;\n\n  constructor(\n    private initialTime: number,\n    onTimeUpdate: (timeLeft: number) => void,\n  ) {\n    this.currentTime = initialTime;\n    this.onTimeUpdate = onTimeUpdate;\n  }\n\n  // Démarrer le compte à rebours\n  public start(): void {\n    if (this.isRunning) return;\n\n    this.isRunning = true;\n    this.intervalId = window.setInterval(() => {\n      this.currentTime--;\n      this.onTimeUpdate(this.currentTime);\n\n      if (this.currentTime <= 0) {\n        this.currentTime = 0;\n        this.stop();\n        // Appel de la fonction onTimeUpdate une dernière fois pour garantir l'affichage du temps écoulé\n        this.onTimeUpdate(this.currentTime);\n      }\n    }, 1000);\n  }\n\n  // Arrêter le compte à rebours\n  public stop(): void {\n    if (!this.isRunning) {\n      return;\n    }\n\n    if (this.intervalId !== null) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    this.isRunning = false;\n  }\n\n  // Réinitialiser le temps\n  public reset(time: number): void {\n    this.stop();\n    this.currentTime = time;\n    this.start();\n  }\n}\n","// src/index.ts\nimport { Game } from './game';\nimport { CanvasRenderer } from './canvas-renderer';\nimport { Timer } from './timer';\nimport { PieceColor, PieceType } from './piece';\nimport { showMessage, updateCapturedPieces } from './utils';\n\nconst game = new Game();\nconst board = game.getBoard();\nconst moveHistoryElement = document.getElementById('moveHistory')!;\nconst currentTurnElement = document.getElementById('currentTurn')!;\nconst timerElement = document.getElementById('timer')!;\nconst passTurnButton = document.getElementById('passTurnButton')!;\nconst gameMessageElement = document.getElementById('gameMessage')!;\nconst replayButton = document.getElementById('replayButton')!;\n\nlet currentPlayer: PieceColor = PieceColor.WHITE; // Les blancs commencent toujours\nlet gameState: 'playing' | 'waiting' = 'playing'; // Ajout de l'état pour la proposition de nullité\nlet hasMoved: boolean = false; // Indique si un mouvement a déjà été effectué dans ce tour\nlet moveHistory: {\n  fromX: number;\n  fromY: number;\n  toX: number;\n  toY: number;\n  pieceType: PieceType;\n}[][] = [[]]; // Historique des mouvements par tour\nlet isGameEnded = false;\n\n// Initialiser le timer avec 60 secondes pour chaque joueur\nlet whiteTimer = new Timer(60, (timeLeft) =>\n  updateTimerDisplay(timeLeft, PieceColor.WHITE),\n);\nlet blackTimer = new Timer(60, (timeLeft) =>\n  updateTimerDisplay(timeLeft, PieceColor.BLACK),\n);\n\n// Fonction pour mettre à jour l'affichage du timer\nfunction updateTimerDisplay(timeLeft: number, color: PieceColor) {\n  if (color === currentPlayer) {\n    timerElement.textContent = `Temps restant: ${timeLeft}s`;\n    if (timeLeft <= 0 && !isGameEnded) {\n      endGame();\n      showMessage(\n        `${currentPlayer === PieceColor.WHITE ? 'Noir' : 'Blanc'} gagne par temps écoulé !`,\n      );\n    }\n  }\n}\n\n// Démarrer le jeu et dessiner le plateau\nconst renderer = new CanvasRenderer(board, 'chessBoard', handleMove);\nrenderer.drawBoard();\nwhiteTimer.start();\n\n// Fonction pour terminer la partie\nfunction endGame() {\n  // Empêche l'appel multiple d'endGame\n  if (isGameEnded) return;\n  isGameEnded = true;\n\n  // Stoppez les timers seulement si ce n'est pas déjà fait\n  if (whiteTimer.isRunning) whiteTimer.stop();\n  if (blackTimer.isRunning) blackTimer.stop();\n\n  gameState = 'waiting';\n  showMessage('La partie est terminée !');\n  replayButton.style.display = 'block';\n}\n\n// Fonction pour effacer le message d'erreur\nfunction clearMessage() {\n  gameMessageElement.textContent = '';\n  gameMessageElement.style.display = 'none';\n}\n\n// Fonction pour mettre à jour le tour et l'affichage\nfunction updateTurn() {\n  clearMessage();\n  currentPlayer =\n    currentPlayer === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n  currentTurnElement.textContent = `Tour actuel: ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`;\n  hasMoved = false;\n\n  // Gestion du bouton \"Passer son tour\"\n  passTurnButton.disabled = currentPlayer === PieceColor.BLACK;\n\n  // Gestion des timers\n  if (currentPlayer === PieceColor.WHITE) {\n    if (blackTimer.isRunning) blackTimer.stop();\n    whiteTimer.reset(60);\n  } else {\n    if (whiteTimer.isRunning) whiteTimer.stop();\n    blackTimer.reset(60);\n  }\n\n  // Vérifie les conditions de nullité\n  if (board.isStalemate(currentPlayer)) {\n    endGame();\n    showMessage('Pat ! La partie est nulle.');\n  }\n\n  if (board.isInsufficientMaterial()) {\n    endGame();\n    showMessage('Matériel insuffisant pour continuer, partie nulle !');\n  }\n\n  if (board.isFiftyMoveRule()) {\n    endGame();\n    showMessage('Règle des 50 coups, partie nulle !');\n  }\n\n  // Seul \"playing\" permet de jouer\n  if (gameState === 'playing') {\n    gameState = 'playing';\n  }\n\n  // Crée un nouveau tour dans l'historique des mouvements\n  moveHistory.push([]);\n\n  // Si c'est au tour de l'IA, faire jouer l'IA automatiquement\n  if (currentPlayer === PieceColor.BLACK) {\n    game.makeAIMove();\n    renderer.drawBoard();\n    updateTurn(); // Change de tour après que l'IA a joué\n  }\n}\n\n// Ajouter un mouvement à l'historique\nfunction addMoveToHistory(\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n  pieceType: PieceType,\n) {\n  const moveText = `${pieceType} de (${fromX}, ${fromY}) à (${toX}, ${toY})`;\n  const listItem = document.createElement('li');\n  listItem.textContent = moveText;\n  moveHistoryElement.appendChild(listItem);\n\n  // Ajoutez le mouvement au tour actuel\n  moveHistory[moveHistory.length - 1].push({\n    fromX,\n    fromY,\n    toX,\n    toY,\n    pieceType,\n  });\n}\n\n// Fonction pour gérer un mouvement sur le plateau\nexport function handleMove(\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n): boolean {\n  if (gameState === 'waiting' || hasMoved) {\n    showMessage('Veuillez attendre le prochain tour !');\n    return false;\n  }\n\n  const piece = board.getPiece(fromX, fromY);\n  const targetPiece = board.getPiece(toX, toY);\n\n  // Vérifie que c'est bien le tour du joueur qui joue\n  if (!piece || piece.color !== currentPlayer) {\n    showMessage(\n      `C'est le tour de ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`,\n    );\n    return false;\n  }\n\n  // Vérifie si le mouvement est valide pour la pièce et respecte les règles des échecs\n  if (piece.isValidMove(fromX, fromY, toX, toY, board)) {\n    // Si une pièce normale est capturée, l'ajouter aux pièces capturées\n    if (board.movePiece(fromX, fromY, toX, toY)) {\n      if (targetPiece) {\n        updateCapturedPieces(targetPiece.type, targetPiece.color);\n      }\n\n      // Ajoute le mouvement à l'historique\n      addMoveToHistory(fromX, fromY, toX, toY, piece.type);\n\n      // Utilise l'animation pour le déplacement\n      renderer.animateMove(fromX, fromY, toX, toY, piece);\n\n      // Vérifie si cela met le roi adverse en échec\n      const opponentColor =\n        currentPlayer === PieceColor.WHITE\n          ? PieceColor.BLACK\n          : PieceColor.WHITE;\n      if (board.isKingInCheck(opponentColor)) {\n        if (board.isCheckmate(opponentColor)) {\n          endGame();\n          showMessage(\n            `Échec et Mat ! ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'} gagne !`,\n          );\n        } else {\n          showMessage(\n            `Échec au ${opponentColor === PieceColor.WHITE ? 'Blanc' : 'Noir'} !`,\n          );\n        }\n      }\n\n      // Change de tour après un mouvement valide\n      updateTurn();\n\n      return true;\n    }\n\n    // Si le mouvement est invalide, retourne faux\n    showMessage('Mouvement invalide !');\n    return false;\n  }\n\n  // Ajoute un return false par défaut si aucune condition n'est remplie\n  return false;\n}\n\n// Gérer le clic sur \"Passer son tour\"\nif (passTurnButton) {\n  passTurnButton.addEventListener('click', (event) => {\n    event.preventDefault();\n    if (gameState === 'playing' && currentPlayer === PieceColor.WHITE) {\n      showMessage(\n        `Tour passé pour ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`,\n      );\n      updateTurn();\n    }\n  });\n}\n\n// Gérer le clic sur \"Rejouer\"\nif (replayButton) {\n  replayButton.addEventListener('click', () => {\n    location.reload();\n  });\n}\n"],"names":["PieceColor","PieceType","Piece","color","type","fromX","fromY","toX","toY","board","dx","dy","x","y","targetPiece","Rook","__publicField","Knight","Bishop","Queen","King","direction","rookX","rook","Pawn","startRow","distanceY","distanceX","promotionDialog","pieceType","capturedWhite","capturedBlack","showMessage","message","gameMessageElement","getPieceSymbol","piece","updateCapturedPieces","capturedWhiteElement","capturedBlackElement","pieceSymbol","Board","validMoves","originalPiece","king","kingX","kingY","capturedPawnY","capturedPawn","_a","kingPosition","kingSafe","pieces","fromRow","fromCol","toRow","toCol","destinationPiece","pieceValues","pieceSquareTables","centerControlBonus","evaluateBoard","score","pieceScore","pieceTable","positionKey","evaluatePawnStructure","hasBishopPair","isKingExposed","checkDoubledPawns","checkIsolatedPawns","i","_b","leftColumn","rightColumn","getPieces","newX","newY","adjPiece","AI","maxTime","bestMove","bestValue","maxDepth","depth","moves","move","boardValue","alpha","beta","isMaximizing","boardKey","evaluation","maxEval","fromPiece","toPiece","minEval","standPat","a","b","pieceA","pieceB","centerControlA","Game","CanvasRenderer","canvasId","moveHandler","currentFrame","startX","startY","deltaX","deltaY","animate","kingInCheck","tileColor","pieceText","event","rect","mouseX","mouseY","moveSuccessful","Timer","initialTime","onTimeUpdate","time","game","moveHistoryElement","currentTurnElement","timerElement","passTurnButton","replayButton","currentPlayer","gameState","hasMoved","moveHistory","isGameEnded","whiteTimer","timeLeft","updateTimerDisplay","blackTimer","endGame","renderer","handleMove","clearMessage","updateTurn","addMoveToHistory","moveText","listItem","opponentColor"],"mappings":"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"}