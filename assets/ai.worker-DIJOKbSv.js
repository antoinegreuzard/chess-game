async function E(l,e){switch(l){case u.PAWN:const{Pawn:t}=await Promise.resolve().then(function(){return S});return new t(e);case u.ROOK:const{Rook:i}=await Promise.resolve().then(function(){return B});return new i(e);case u.KNIGHT:const{Knight:s}=await Promise.resolve().then(function(){return A});return new s(e);case u.BISHOP:const{Bishop:n}=await Promise.resolve().then(function(){return H});return new n(e);case u.QUEEN:const{Queen:r}=await Promise.resolve().then(function(){return x});return new r(e);case u.KING:const{King:c}=await Promise.resolve().then(function(){return N});return new c(e);default:throw new Error(`Type de pièce inconnu : ${l}`)}}var h=(l=>(l.WHITE="white",l.BLACK="black",l))(h||{}),u=(l=>(l.PAWN="pawn",l.ROOK="rook",l.KNIGHT="knight",l.BISHOP="bishop",l.QUEEN="queen",l.KING="king",l))(u||{});class M{constructor(e,t){this.color=e,this.type=t}isPathClear(e,t,i,s,n){const r=Math.sign(i-e),c=Math.sign(s-t);let o=e+r,a=t+c;for(;o!==i||a!==s;){if(n.getPiece(o,a)!==null)return!1;o+=r,a+=c}return!0}canCapture(e,t,i){const s=i.getPiece(e,t);return!s||s.color!==this.color}toData(){return{color:this.color,type:this.type}}static async fromData(e){return await E(e.type,e.color)}}var W=Object.freeze({__proto__:null,Piece:M,PieceColor:h,PieceType:u});class P extends M{hasMoved=!1;constructor(e){super(e,u.ROOK)}isValidMove(e,t,i,s,n){return!(e===i||t===s)||!this.isPathClear(e,t,i,s,n)?!1:this.canCapture(i,s,n)}toData(){return{...super.toData(),hasMoved:this.hasMoved}}static async fromData(e){const t=new P(e.color);return t.hasMoved=e.hasMoved,t}}var B=Object.freeze({__proto__:null,Rook:P});class m extends M{constructor(e){super(e,u.KNIGHT)}isValidMove(e,t,i,s,n){const r=Math.abs(i-e),c=Math.abs(s-t);return(r===2&&c===1||r===1&&c===2)&&this.canCapture(i,s,n)}}var A=Object.freeze({__proto__:null,Knight:m});class d extends(await Promise.resolve().then(function(){return W})).Piece{constructor(e){super(e,u.BISHOP)}isValidMove(e,t,i,s,n){return Math.abs(i-e)===Math.abs(s-t)&&this.isPathClear(e,t,i,s,n)?this.canCapture(i,s,n):!1}}var H=Object.freeze({__proto__:null,Bishop:d});class K extends M{constructor(e){super(e,u.QUEEN)}isValidMove(e,t,i,s,n){return(e===i||t===s||Math.abs(i-e)===Math.abs(s-t))&&this.isPathClear(e,t,i,s,n)?this.canCapture(i,s,n):!1}}var x=Object.freeze({__proto__:null,Queen:K});class I extends M{hasMoved=!1;constructor(e){super(e,u.KING)}isValidMove(e,t,i,s,n){const r=Math.abs(i-e),c=Math.abs(s-t);if(r<=1&&c<=1){const o=n.getPiece(i,s);return this.canCapture(i,s,n)&&(!o||o.type!==u.KING)}if(!this.hasMoved&&c===0&&r===2){const o=i>e?1:-1,a=i>e?7:0,f=n.getPiece(a,t);if(f&&f instanceof P&&!f.hasMoved){for(let p=e+o;p!==a;p+=o)if(n.getPiece(p,t))return!1;if(!n.isKingInCheck(this.color)&&!n.isSquareUnderAttack(e+o,t,this.color)&&!n.isSquareUnderAttack(i,t,this.color))return!0}}return!1}}var N=Object.freeze({__proto__:null,King:I});class v extends M{constructor(e){super(e,u.PAWN)}isValidMove(e,t,i,s,n){const r=this.color===h.WHITE?1:-1,c=this.color===h.WHITE?1:6,o=(s-t)*r,a=Math.abs(i-e);if(a===0&&o===1&&!n.getPiece(i,s))return(this.color===h.WHITE&&s===7||this.color===h.BLACK&&s===0)&&n.getPiece(i,s)?.type===u.PAWN&&this.handlePromotion(i,s,n),!0;if(a===0&&o===2&&t===c&&!n.getPiece(i,s)&&!n.getPiece(e,t+r))return n.updateEnPassantTarget(e,t,i,s,this),!0;if(a===1&&o===1){if(n.getPiece(i,s)&&this.canCapture(i,s,n))return(this.color===h.WHITE&&s===7||this.color===h.BLACK&&s===0&&n.getPiece(i,s)?.type===u.PAWN)&&this.handlePromotion(i,s,n),!0;if(n.isEnPassantMove(e,t,i,s))return!0}return!1}handlePromotion(e,t,i){const s=document.getElementById("promotionDialog");s&&(s.style.display="block",window.promote=n=>{s.style.display="none",i.promotePawn(e,t,n)})}}var S=Object.freeze({__proto__:null,Pawn:v});let k=[],T=[];function O(l,e){switch(l){case u.PAWN:return e===h.WHITE?"♙":"♟";case u.ROOK:return e===h.WHITE?"♖":"♜";case u.KNIGHT:return e===h.WHITE?"♘":"♞";case u.BISHOP:return e===h.WHITE?"♗":"♝";case u.QUEEN:return e===h.WHITE?"♕":"♛";case u.KING:return e===h.WHITE?"♔":"♚";default:return""}}function V(l,e){const t=O(l,e);e===h.WHITE?k.push(t):T.push(t),_()}function _(){const l=document.getElementById("capturedWhite"),e=document.getElementById("capturedBlack");l&&(l.textContent=k.join(" ")),e&&(e.textContent=T.join(" "))}class C{grid;enPassantTarget=null;halfMoveCount=0;constructor(){this.grid=this.initializeBoard()}initializeBoard(){const e=Array(8).fill(null).map(()=>Array(8).fill(null));return e[0]=[new P(h.WHITE),new m(h.WHITE),new d(h.WHITE),new K(h.WHITE),new I(h.WHITE),new d(h.WHITE),new m(h.WHITE),new P(h.WHITE)],e[1]=Array(8).fill(null).map(()=>new v(h.WHITE)),e[7]=[new P(h.BLACK),new m(h.BLACK),new d(h.BLACK),new K(h.BLACK),new I(h.BLACK),new d(h.BLACK),new m(h.BLACK),new P(h.BLACK)],e[6]=Array(8).fill(null).map(()=>new v(h.BLACK)),e}isWithinBounds(e,t){return e>=0&&e<8&&t>=0&&t<8}getPiece(e,t){return this.grid[t][e]}getValidMoves(e,t){let i=null;if(this.isWithinBounds(e,t)&&(i=this.getPiece(e,t)),!i)return[];const s=[];for(let n=0;n<8;n++)for(let r=0;r<8;r++)i.isValidMove(e,t,r,n,this)&&s.push({x:r,y:n});return s}getKingInCheck(){return this.isKingInCheck(h.WHITE)?this.findKing(h.WHITE):this.isKingInCheck(h.BLACK)?this.findKing(h.BLACK):null}movePiece(e,t,i,s){if(!this.isWithinBounds(e,t)||!this.isWithinBounds(i,s))return!1;const n=this.getPiece(e,t);if(n&&n.isValidMove(e,t,i,s,this)){const r=this.getPiece(i,s);if(r&&r.type===u.KING)return!1;if(n instanceof I&&Math.abs(i-e)===2)if(this.isCastlingValid(n,e,t,i))this.handleCastling(i,t);else return!1;if(n instanceof v&&this.isEnPassantMove(e,t,i,s)&&this.captureEnPassant(e,t,i,s),this.grid[s][i]=n,this.grid[t][e]=null,this.isKingInCheck(n.color))return this.grid[t][e]=n,this.grid[s][i]=r,!1;n.hasMoved=!0,this.updateEnPassantTarget(e,t,i,s,n),this.halfMoveCount=n.type===u.PAWN||r?0:this.halfMoveCount+1;const c=n.color===h.WHITE?h.BLACK:h.WHITE;return this.isCheckmate(c),!0}return!1}isCastlingValid(e,t,i,s){const n=s>t?1:-1,r=s>t?7:0,c=this.getPiece(r,i);if(!(c instanceof P)||c.hasMoved||e.hasMoved)return!1;for(let o=t+n;o!==s;o+=n)if(this.getPiece(o,i)||this.isSquareUnderAttack(o,i,e.color))return!1;return!this.isSquareUnderAttack(s,i,e.color)}handleCastling(e,t){e===6?this.getPiece(7,t)instanceof P&&this.movePiece(7,t,5,t):e===2&&this.getPiece(0,t)instanceof P&&this.movePiece(0,t,3,t)}updateEnPassantTarget(e,t,i,s,n){n instanceof v&&Math.abs(s-t)===2&&e===i?this.enPassantTarget={x:i,y:(t+s)/2}:this.enPassantTarget=null}captureEnPassant(e,t,i,s){const n=this.getPiece(e,t);if(this.isEnPassantMove(e,t,i,s)&&n instanceof v){const r=n.color===h.WHITE?-1:1,c=s+r,o=this.getPiece(i,c);if(o&&o.type===u.PAWN){this.grid[c][i]=null;const a={capturedWhite:[],capturedBlack:[]};return o.color===h.WHITE?a.capturedWhite.push(o.type):a.capturedBlack.push(o.type),V(o.type,o.color),a}}return null}isEnPassantMove(e,t,i,s){return this.enPassantTarget?this.getPiece(e,t)instanceof v&&i===this.enPassantTarget.x&&s===this.enPassantTarget.y&&Math.abs(e-i)===1&&Math.abs(t-s)===1:!1}promotePawn(e,t,i){const s=this.getPiece(e,t)?.color;if(s)switch(i){case"queen":this.grid[t][e]=new K(s);break;case"rook":this.grid[t][e]=new P(s);break;case"bishop":this.grid[t][e]=new d(s);break;case"knight":this.grid[t][e]=new m(s);break}}isKingInCheck(e){const t=this.findKing(e);if(!t)return!1;for(let i=0;i<8;i++)for(let s=0;s<8;s++){const n=this.getPiece(s,i);if(n&&n.color!==e&&n.isValidMove(s,i,t.x,t.y,this))return!0}return!1}isCheckmate(e){if(!this.isKingInCheck(e))return!1;for(let t=0;t<8;t++)for(let i=0;i<8;i++){const s=this.getPiece(i,t);if(s&&s.color===e){const n=this.getValidMoves(i,t);for(const r of n){const c=this.getPiece(r.x,r.y);this.grid[r.y][r.x]=s,this.grid[t][i]=null;const o=!this.isKingInCheck(e);if(this.grid[t][i]=s,this.grid[r.y][r.x]=c,o)return!1}}}return!0}isStalemate(e){if(this.isKingInCheck(e))return!1;for(let t=0;t<8;t++)for(let i=0;i<8;i++){const s=this.getPiece(i,t);if(s&&s.color===e){for(let n=0;n<8;n++)for(let r=0;r<8;r++)if(s.isValidMove(i,t,r,n,this)){const c=this.getPiece(r,n);this.grid[n][r]=s,this.grid[t][i]=null;const o=!this.isKingInCheck(e);if(this.grid[t][i]=s,this.grid[n][r]=c,o)return!1}}}return!0}findKing(e){for(let t=0;t<8;t++)for(let i=0;i<8;i++){const s=this.getPiece(i,t);if(s&&s instanceof I&&s.color===e)return{x:i,y:t}}return null}isSquareUnderAttack(e,t,i){for(let s=0;s<8;s++)for(let n=0;n<8;n++){const r=this.getPiece(n,s);if(r&&r.color!==i&&r.isValidMove(n,s,e,t,this))return!0}return!1}isInsufficientMaterial(){const e=this.grid.flat().filter(t=>t!==null);return e.length<=2?!0:e.length===3&&e.some(t=>t?.type===u.BISHOP||t?.type===u.KNIGHT)}isFiftyMoveRule(){return this.halfMoveCount>=50}setPiece(e,t,i){this.grid[t][e]=i}isMoveValid(e,t,i,s){const n=this.getPiece(e,t);if(!n||i<0||i>=8||s<0||s>=8||!n.isValidMove(e,t,i,s,this))return!1;const r=this.getPiece(i,s);return!(r&&r.color===n.color)}isCapture(e,t,i,s){const n=this.isWithinBounds(e,t)?this.getPiece(e,t):null,r=this.isWithinBounds(i,s)?this.getPiece(i,s):null;return n!==null&&r!==null&&n.color!==r.color}static async fromData(e){const t=new C;return t.grid=await Promise.all(e.grid.map(async i=>Promise.all(i.map(async s=>s?await M.fromData(s):null)))),t}toData(){return{grid:this.grid.map(e=>e.map(t=>t?t.toData():null))}}}const D={[u.PAWN]:1,[u.KNIGHT]:3,[u.BISHOP]:3.25,[u.ROOK]:5,[u.QUEEN]:9,[u.KING]:0},G={[u.PAWN]:[[0,0,0,0,0,0,0,0],[.5,.5,.5,.5,.5,.5,.5,.5],[.1,.1,.2,.3,.3,.2,.1,.1],[.05,.05,.1,.25,.25,.1,.05,.05],[0,0,0,.2,.2,0,0,0],[.05,-.05,-.1,0,0,-.1,-.05,.05],[.05,.1,.1,-.2,-.2,.1,.1,.05],[0,0,0,0,0,0,0,0]],[u.KNIGHT]:[[-.5,-.4,-.3,-.3,-.3,-.3,-.4,-.5],[-.4,-.2,0,0,0,0,-.2,-.4],[-.3,0,.1,.15,.15,.1,0,-.3],[-.3,.05,.15,.2,.2,.15,.05,-.3],[-.3,0,.15,.2,.2,.15,0,-.3],[-.3,.05,.1,.15,.15,.1,.05,-.3],[-.4,-.2,0,.05,.05,0,-.2,-.4],[-.5,-.4,-.3,-.3,-.3,-.3,-.4,-.5]],[u.BISHOP]:[[-.2,-.1,-.1,-.1,-.1,-.1,-.1,-.2],[-.1,0,0,0,0,0,0,-.1],[-.1,0,.05,.1,.1,.05,0,-.1],[-.1,.05,.05,.1,.1,.05,.05,-.1],[-.1,0,.1,.1,.1,.1,0,-.1],[-.1,.1,.1,.1,.1,.1,.1,-.1],[-.1,.05,0,0,0,0,.05,-.1],[-.2,-.1,-.1,-.1,-.1,-.1,-.1,-.2]],[u.ROOK]:[[0,0,0,0,0,0,0,0],[.05,.1,.1,.1,.1,.1,.1,.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[0,0,0,.05,.05,0,0,0]],[u.QUEEN]:[[-.2,-.1,-.1,-.05,-.05,-.1,-.1,-.2],[-.1,0,0,0,0,0,0,-.1],[-.1,0,.05,.05,.05,.05,0,-.1],[-.05,0,.05,.05,.05,.05,0,-.05],[0,0,.05,.05,.05,.05,0,-.05],[-.1,.05,.05,.05,.05,.05,0,-.1],[-.1,0,.05,0,0,0,0,-.1],[-.2,-.1,-.1,-.05,-.05,-.1,-.1,-.2]],[u.KING]:[[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.2,-.3,-.3,-.4,-.4,-.3,-.3,-.2],[-.1,-.2,-.2,-.2,-.2,-.2,-.2,-.1],[.2,.2,0,0,0,0,.2,.2],[.2,.3,0,0,0,0,.3,.2]]},y={"3,3":.5,"3,4":.5,"4,3":.5,"4,4":.5,"2,3":.25,"2,4":.25,"3,2":.25,"4,2":.25,"4,5":.25,"3,5":.25,"5,3":.25,"5,4":.25};function w(l,e){let t=0;for(let i=0;i<8;i++)for(let s=0;s<8;s++){const n=l.getPiece(s,i);if(n){let r=D[n.type];const c=G[n.type];c&&(r+=c[i][s]);const o=`${s},${i}`;y[o]&&(r+=y[o]),n.type===u.PAWN&&(r+=L(l,s,i,n.color)),n.type===u.BISHOP&&U(l,n.color)&&(r+=.5),j(l,s,i,n.color)&&(r-=.5),t+=n.color===e?r:-r}}return t}function L(l,e,t,i){let s=0;return s-=q(l,e,t,i)*1.5,s-=Q(l,e,t,i)*1.5,s}function q(l,e,t,i){for(let s=0;s<8;s++)if(s!==t&&l.getPiece(e,s)?.type===u.PAWN&&l.getPiece(e,s)?.color===i)return .5;return 0}function Q(l,e,t,i){const s=e-1>=0?l.getPiece(e-1,t):null,n=e+1<8?l.getPiece(e+1,t):null;return(!s||s.type!==u.PAWN||s.color!==i)&&(!n||n.type!==u.PAWN||n.color!==i)?1.5:0}function U(l,e){return z(l,e).filter(i=>i.type===u.BISHOP).length===2}function j(l,e,t,i){const s=l.getPiece(e,t);return s&&s.type===u.KING?[{dx:-1,dy:0},{dx:1,dy:0},{dx:0,dy:-1},{dx:0,dy:1}].some(({dx:r,dy:c})=>{const o=e+r,a=t+c;if(l.isWithinBounds(o,a)){const f=l.getPiece(o,a);return!f||f.color!==i||f.type===u.KING}return!0}):!1}function z(l,e){const t=[];for(let i=0;i<8;i++)for(let s=0;s<8;s++){const n=l.getPiece(s,i);n&&n.color===e&&t.push(n)}return t}class ${constructor(e,t=5e3){this.color=e,this.transpositionTable=new Map,this.maxTime=t,this.killerMoves={},this.startTime=0}transpositionTable;maxTime;startTime;killerMoves;makeMove(e){let t=null,i=-1/0;const s=7;this.startTime=Date.now();for(let n=1;n<=s;n++){let r=this.getAllValidMoves(e);r=this.sortMoves(r,e,n);for(const c of r){const o=e.getPiece(c.fromX,c.fromY),a=e.getPiece(c.toX,c.toY);e.movePiece(c.fromX,c.fromY,c.toX,c.toY);const f=this.minimax(e,n-1,-1/0,1/0,!1);if(e.setPiece(c.fromX,c.fromY,o),e.setPiece(c.toX,c.toY,a),f>i&&(i=f,t=c),Date.now()-this.startTime>this.maxTime)break}if(Date.now()-this.startTime>this.maxTime)break}return t}minimax(e,t,i,s,n){const r=e.toString();if(Date.now()-this.startTime>this.maxTime)return w(e,this.color);if(this.transpositionTable.has(r))return this.transpositionTable.get(r);if(t===0||e.isCheckmate(this.color)||e.isCheckmate(this.getOpponentColor())||Date.now()-this.startTime>this.maxTime){const c=this.quiescenceSearch(e,i,s);return this.transpositionTable.set(r,c),c}if(e.isKingInCheck(this.color)&&this.getAllValidMoves(e).length===0)return-1/0;if(n){let c=-1/0,o=this.getAllValidMoves(e);o=this.sortMoves(o,e,t);for(const a of o){const f=e.getPiece(a.fromX,a.fromY),p=e.getPiece(a.toX,a.toY);e.movePiece(a.fromX,a.fromY,a.toX,a.toY);const g=this.minimax(e,t-1,i,s,!1);if(e.setPiece(a.fromX,a.fromY,f),e.setPiece(a.toX,a.toY,p),c=Math.max(c,g),i=Math.max(i,g),s<=i){this.addKillerMove(t,a);break}}return this.transpositionTable.set(r,c),c}else{let c=1/0,o=this.getAllValidMoves(e);o=this.sortMoves(o,e,t);for(const a of o){const f=e.getPiece(a.fromX,a.fromY),p=e.getPiece(a.toX,a.toY);e.movePiece(a.fromX,a.fromY,a.toX,a.toY);const g=this.minimax(e,t-1,i,s,!0);if(e.setPiece(a.fromX,a.fromY,f),e.setPiece(a.toX,a.toY,p),c=Math.min(c,g),s=Math.min(s,g),s<=i){this.addKillerMove(t,a);break}}return this.transpositionTable.set(r,c),c}}addKillerMove(e,t){this.killerMoves[e]||(this.killerMoves[e]=[]),this.killerMoves[e].push(t)}quiescenceSearch(e,t,i,s=0){if(s>=10)return w(e,this.color);const r=w(e,this.color);if(r>=i)return i;t<r&&(t=r);const c=this.getAllValidMoves(e).filter(o=>e.isCapture(o.fromX,o.fromY,o.toX,o.toY));for(const o of c){const a=e.getPiece(o.fromX,o.fromY),f=e.getPiece(o.toX,o.toY);if(e.movePiece(o.fromX,o.fromY,o.toX,o.toY),!e.isKingInCheck(this.color)){const g=-this.quiescenceSearch(e,-i,-t,s+1);if(e.setPiece(o.fromX,o.fromY,a),e.setPiece(o.toX,o.toY,f),g>=i)return i;g>t&&(t=g)}else e.setPiece(o.fromX,o.fromY,a),e.setPiece(o.toX,o.toY,f)}return t}getOpponentColor(){return this.color===h.WHITE?h.BLACK:h.WHITE}getAllValidMoves(e){const t=[];for(let i=0;i<8;i++)for(let s=0;s<8;s++){const n=e.getPiece(s,i);if(n&&n.color===this.color){const r=e.getValidMoves(s,i);for(const c of r)if(e.isMoveValid(s,i,c.x,c.y)){const o=e.getPiece(c.x,c.y);e.setPiece(c.x,c.y,n),e.setPiece(s,i,null);const a=!e.isKingInCheck(this.color);e.setPiece(s,i,n),e.setPiece(c.x,c.y,o),a&&t.push({fromX:s,fromY:i,toX:c.x,toY:c.y})}}}return t}sortMoves(e,t,i){return e.sort((s,n)=>{if(this.killerMoves[i]&&this.killerMoves[i].some(f=>f.fromX===s.fromX&&f.fromY===s.fromY))return-1;const r=t.getPiece(s.toX,s.toY),c=t.getPiece(n.toX,n.toY);if(r&&!c)return-1;if(!r&&c)return 1;const o=y[`${s.toX},${s.toY}`]||0;return(y[`${n.toX},${n.toY}`]||0)-o})}}const R=new $(h.BLACK);self.onmessage=async l=>{const{boardData:e}=l.data,t=await C.fromData(e),i=R.makeMove(t);let s=null;if(i&&t.isCapture(i.fromX,i.fromY,i.toX,i.toY)){const n=t.getPiece(i.toX,i.toY);n&&(s={capturedWhite:[],capturedBlack:[]},n.color===h.WHITE?s.capturedWhite.push(n.type):s.capturedBlack.push(n.type))}self.postMessage({bestMove:i,captureData:s})};
//# sourceMappingURL=ai.worker-DIJOKbSv.js.map
