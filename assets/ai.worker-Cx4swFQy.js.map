{"version":3,"file":"ai.worker-Cx4swFQy.js","sources":["../src/utils/pieceFactory.ts","../src/piece.ts","../src/utils/utils.ts","../src/board.ts","../src/evaluator.ts","../src/endgameTablebase.ts","../src/openingBook.ts","../src/ai.ts","../src/pieces/pawn.ts","../src/ai.worker.ts"],"sourcesContent":["import { PieceColor, PieceType } from '../piece';\n\nexport async function createPiece(type: PieceType, color: PieceColor) {\n  switch (type) {\n    case PieceType.PAWN:\n      const { Pawn } = await import('../pieces/pawn');\n      return new Pawn(color);\n    case PieceType.ROOK:\n      const { Rook } = await import('../pieces/rook');\n      return new Rook(color);\n    case PieceType.KNIGHT:\n      const { Knight } = await import('../pieces/knight');\n      return new Knight(color);\n    case PieceType.BISHOP:\n      const { Bishop } = await import('../pieces/bishop');\n      return new Bishop(color);\n    case PieceType.QUEEN:\n      const { Queen } = await import('../pieces/queen');\n      return new Queen(color);\n    case PieceType.KING:\n      const { King } = await import('../pieces/king');\n      return new King(color);\n    default:\n      throw new Error(`Type de pièce inconnu : ${type}`);\n  }\n}\n","// src/piece.ts\nimport { createPiece } from './utils/pieceFactory';\nimport { King } from './pieces/king';\n\nexport enum PieceColor {\n  WHITE = 'white',\n  BLACK = 'black',\n}\n\nexport enum PieceType {\n  PAWN = 'pawn',\n  ROOK = 'rook',\n  KNIGHT = 'knight',\n  BISHOP = 'bishop',\n  QUEEN = 'queen',\n  KING = 'king',\n}\n\nexport interface BoardInterface {\n  getPiece(x: number, y: number): Piece | null;\n\n  updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void;\n\n  isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean;\n\n  promotePawn(x: number, y: number, pieceType: string): void;\n\n  isSquareUnderAttack(x: number, y: number, color: string): boolean;\n\n  isKing(x: number, y: number): boolean;\n\n  isAdjacentToAnotherKing(x: number, y: number, color: PieceColor): boolean;\n\n  getPlayerColor(): PieceColor;\n}\n\nexport abstract class Piece {\n  public hasMoved: boolean = false;\n\n  protected constructor(\n    public color: PieceColor,\n    public type: PieceType,\n  ) {}\n\n  abstract isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean;\n\n  public isPathClear(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const dx = Math.sign(toX - fromX);\n    const dy = Math.sign(toY - fromY);\n\n    let x = fromX + dx;\n    let y = fromY + dy;\n    while (x !== toX || y !== toY) {\n      if (board.getPiece(x, y) !== null) return false;\n      x += dx;\n      y += dy;\n    }\n    return true;\n  }\n\n  static isKing(piece: Piece): piece is King {\n    return piece.type === PieceType.KING;\n  }\n\n  public canCapture(toX: number, toY: number, board: BoardInterface): boolean {\n    const targetPiece = board.getPiece(toX, toY);\n    return !targetPiece || targetPiece.color !== this.color;\n  }\n\n  // Sérialisation des données de la pièce\n  public toData(): any {\n    return {\n      color: this.color,\n      type: this.type,\n    };\n  }\n\n  static async fromData(data: any): Promise<Piece> {\n    return await createPiece(data.type, data.color);\n  }\n}\n","// src/utils/utils.ts\n\nimport { PieceColor, PieceType } from '../piece';\n\nexport let capturedWhite: string[] = [];\nexport let capturedBlack: string[] = [];\n\nexport function showMessage(message: string) {\n  const gameMessageElement = document.getElementById(\n    'gameMessage',\n  ) as HTMLDivElement;\n  gameMessageElement.textContent = message;\n  gameMessageElement.style.display = 'block'; // Afficher le message\n}\n\nexport function getPieceSymbol(piece: PieceType, color: PieceColor): string {\n  switch (piece) {\n    case PieceType.PAWN:\n      return color === PieceColor.WHITE ? '♙' : '♟';\n    case PieceType.ROOK:\n      return color === PieceColor.WHITE ? '♖' : '♜';\n    case PieceType.KNIGHT:\n      return color === PieceColor.WHITE ? '♘' : '♞';\n    case PieceType.BISHOP:\n      return color === PieceColor.WHITE ? '♗' : '♝';\n    case PieceType.QUEEN:\n      return color === PieceColor.WHITE ? '♕' : '♛';\n    case PieceType.KING:\n      return color === PieceColor.WHITE ? '♔' : '♚';\n    default:\n      return '';\n  }\n}\n\nexport function updateCapturedPieces(piece: PieceType, color: PieceColor) {\n  const pieceSymbol = getPieceSymbol(piece, color);\n\n  if (color === PieceColor.WHITE) {\n    capturedWhite.push(pieceSymbol);\n  } else {\n    capturedBlack.push(pieceSymbol);\n  }\n\n  updateCapturedPiecesDOM();\n}\n\nexport function updateCapturedPiecesDOM() {\n  const capturedWhiteElement = document.getElementById(\n    'capturedWhite',\n  ) as HTMLDivElement;\n  const capturedBlackElement = document.getElementById(\n    'capturedBlack',\n  ) as HTMLDivElement;\n\n  if (capturedWhiteElement) {\n    capturedWhiteElement.textContent = capturedWhite.join(' ');\n  }\n  if (capturedBlackElement) {\n    capturedBlackElement.textContent = capturedBlack.join(' ');\n  }\n}\n","// src/board.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from './piece';\nimport { King } from './pieces/king';\nimport { updateCapturedPieces } from './utils/utils';\nimport { createPiece } from './utils/pieceFactory';\n\ntype BoardSquare = Piece | null;\n\nexport class Board implements BoardInterface {\n  private grid: (Piece | null)[][];\n  private enPassantTarget: { x: number; y: number } | null = null;\n  private halfMoveCount: number = 0; // Compteur pour la règle des 50 coups\n  private currentPlayer: PieceColor = PieceColor.WHITE;\n\n  constructor() {\n    this.grid = [];\n  }\n\n  public async init(): Promise<void> {\n    this.grid = await this.initializeBoard();\n  }\n\n  private async initializeBoard(): Promise<(Piece | null)[][]> {\n    const board: (Piece | null)[][] = Array(8)\n      .fill(null)\n      .map(() => Array(8).fill(null));\n\n    // Ajouter les pièces blanches\n    board[0] = [\n      await createPiece(PieceType.ROOK, PieceColor.WHITE),\n      await createPiece(PieceType.KNIGHT, PieceColor.WHITE),\n      await createPiece(PieceType.BISHOP, PieceColor.WHITE),\n      await createPiece(PieceType.QUEEN, PieceColor.WHITE),\n      await createPiece(PieceType.KING, PieceColor.WHITE),\n      await createPiece(PieceType.BISHOP, PieceColor.WHITE),\n      await createPiece(PieceType.KNIGHT, PieceColor.WHITE),\n      await createPiece(PieceType.ROOK, PieceColor.WHITE),\n    ];\n    board[1] = await Promise.all(\n      Array(8)\n        .fill(null)\n        .map(() => createPiece(PieceType.PAWN, PieceColor.WHITE)),\n    );\n\n    // Ajouter les pièces noires\n    board[7] = [\n      await createPiece(PieceType.ROOK, PieceColor.BLACK),\n      await createPiece(PieceType.KNIGHT, PieceColor.BLACK),\n      await createPiece(PieceType.BISHOP, PieceColor.BLACK),\n      await createPiece(PieceType.QUEEN, PieceColor.BLACK),\n      await createPiece(PieceType.KING, PieceColor.BLACK),\n      await createPiece(PieceType.BISHOP, PieceColor.BLACK),\n      await createPiece(PieceType.KNIGHT, PieceColor.BLACK),\n      await createPiece(PieceType.ROOK, PieceColor.BLACK),\n    ];\n    board[6] = await Promise.all(\n      Array(8)\n        .fill(null)\n        .map(() => createPiece(PieceType.PAWN, PieceColor.BLACK)),\n    );\n\n    return board;\n  }\n\n  // Méthode générale pour vérifier les limites\n  public isWithinBounds(x: number, y: number): boolean {\n    return x >= 0 && x < 8 && y >= 0 && y < 8;\n  }\n\n  public getPiece(x: number, y: number): BoardSquare {\n    return this.grid[y][x];\n  }\n\n  public getValidMoves(x: number, y: number): { x: number; y: number }[] {\n    let piece = null;\n    if (this.isWithinBounds(x, y)) piece = this.getPiece(x, y);\n    if (!piece) return [];\n\n    const validMoves: { x: number; y: number }[] = [];\n\n    for (let toY = 0; toY < 8; toY++) {\n      for (let toX = 0; toX < 8; toX++) {\n        if (piece.isValidMove(x, y, toX, toY, this)) {\n          validMoves.push({ x: toX, y: toY });\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  public getKingInCheck(): { x: number; y: number } | null {\n    if (this.isKingInCheck(PieceColor.WHITE)) {\n      return this.findKing(PieceColor.WHITE);\n    } else if (this.isKingInCheck(PieceColor.BLACK)) {\n      return this.findKing(PieceColor.BLACK);\n    }\n    return null;\n  }\n\n  public movePiece(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (\n      !this.isWithinBounds(fromX, fromY) ||\n      !this.isWithinBounds(toX, toY) ||\n      ['__proto__', 'constructor', 'prototype'].includes(fromY.toString()) ||\n      ['__proto__', 'constructor', 'prototype'].includes(toY.toString())\n    ) {\n      return false; // Mouvement invalide en dehors des limites ou clé interdite\n    }\n\n    const piece = this.getPiece(fromX, fromY);\n    if (piece && piece.isValidMove(fromX, fromY, toX, toY, this)) {\n      const targetPiece = this.getPiece(toX, toY);\n\n      // Empêche de capturer le roi ennemi\n      if (targetPiece && targetPiece.type === PieceType.KING) {\n        return false;\n      }\n\n      if (piece?.type === PieceType.KING && Math.abs(toX - fromX) === 2) {\n        if (this.isCastlingValid(piece, fromX, fromY, toX)) {\n          this.handleCastling(toX, fromY);\n          piece.hasMoved = true; // Met à jour le statut de mouvement du roi\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      // Gestion de la prise en passant\n      if (\n        piece?.type === PieceType.PAWN &&\n        this.isEnPassantMove(fromX, fromY, toX, toY)\n      ) {\n        this.captureEnPassant(fromX, fromY, toX, toY); // Capture le pion en passant\n      }\n\n      // Sauvegarde l'état avant de simuler le mouvement\n      this.grid[toY][toX] = piece;\n      this.grid[fromY][fromX] = null;\n      piece.hasMoved = true;\n\n      // Vérifie si le mouvement met le roi du joueur en échec\n      if (this.isKingInCheck(piece.color)) {\n        // Annule le mouvement si le roi est en échec\n        this.grid[fromY][fromX] = piece;\n        this.grid[toY][toX] = targetPiece;\n        return false;\n      }\n\n      // Mise à jour de l'état après un mouvement valide\n      if ('hasMoved' in piece) {\n        (piece as any).hasMoved = true;\n      }\n      this.updateEnPassantTarget(fromX, fromY, toX, toY, piece);\n\n      // Réinitialise le compteur pour la règle des 50 coups si un pion bouge ou une capture a lieu\n      this.halfMoveCount =\n        piece.type === PieceType.PAWN || targetPiece\n          ? 0\n          : this.halfMoveCount + 1;\n\n      // Vérifie si le mouvement met l'adversaire en échec et mat\n      const opponentColor =\n        piece.color === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n      if (this.isCheckmate(opponentColor)) {\n        return true; // Partie terminée\n      }\n\n      return true;\n    }\n\n    return false; // Mouvement invalide\n  }\n\n  private isCastlingValid(\n    king: King,\n    fromX: number,\n    fromY: number,\n    toX: number,\n  ): boolean {\n    const direction = toX > fromX ? 1 : -1;\n    const rookX = toX > fromX ? 7 : 0;\n    const rook = this.getPiece(rookX, fromY);\n\n    // Vérification des conditions de roque : roi et tour n'ont pas bougé, et la tour est présente\n    if (!(rook?.type === PieceType.ROOK) || rook.hasMoved || king.hasMoved)\n      return false;\n\n    // Vérifie que les cases entre le roi et la tour sont libres et non attaquées\n    for (let x = fromX + direction; x !== toX + direction; x += direction) {\n      if (\n        this.getPiece(x, fromY) ||\n        this.isSquareUnderAttack(x, fromY, king.color)\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private handleCastling(kingX: number, kingY: number): void {\n    // Petit roque (roi vers la droite)\n    if (kingX === 6) {\n      const rook = this.getPiece(7, kingY);\n      const king = this.getPiece(4, kingY);\n      if (\n        rook?.type === PieceType.ROOK &&\n        !rook.hasMoved &&\n        king?.type === PieceType.KING\n      ) {\n        this.setPiece(5, kingY, rook); // Déplace la tour\n        this.setPiece(7, kingY, null); // Enlève la tour de sa position initiale\n        this.setPiece(6, kingY, king); // Déplace le roi vers sa nouvelle position\n        this.setPiece(4, kingY, null); // Enlève le roi de sa position initiale\n      }\n    }\n    // Grand roque (roi vers la gauche)\n    else if (kingX === 2) {\n      const rook = this.getPiece(0, kingY);\n      const king = this.getPiece(4, kingY);\n      if (\n        rook?.type === PieceType.ROOK &&\n        !rook.hasMoved &&\n        king?.type === PieceType.KING\n      ) {\n        this.setPiece(3, kingY, rook); // Déplace la tour\n        this.setPiece(0, kingY, null); // Enlève la tour de sa position initiale\n        this.setPiece(2, kingY, king); // Déplace le roi vers sa nouvelle position\n        this.setPiece(4, kingY, null); // Enlève le roi de sa position initiale\n      }\n    }\n  }\n\n  public updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    if (\n      piece?.type === PieceType.PAWN &&\n      Math.abs(toY - fromY) === 2 &&\n      fromX === toX\n    ) {\n      // Si le pion avance de deux cases, configure la cible pour la prise en passant\n      this.enPassantTarget = { x: toX, y: (fromY + toY) / 2 };\n    } else {\n      this.enPassantTarget = null;\n    }\n  }\n\n  public captureEnPassant(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): { capturedWhite: PieceType[]; capturedBlack: PieceType[] } | null {\n    const piece = this.getPiece(fromX, fromY);\n\n    if (\n      this.isEnPassantMove(fromX, fromY, toX, toY) &&\n      piece?.type === PieceType.PAWN\n    ) {\n      const direction = piece.color === PieceColor.WHITE ? -1 : 1;\n      const capturedPawnY = toY + direction;\n      const capturedPawn = this.getPiece(toX, capturedPawnY);\n\n      if (capturedPawn && capturedPawn.type === PieceType.PAWN) {\n        this.grid[capturedPawnY][toX] = null;\n\n        // Déclare explicitement le type de captureData pour éviter l'erreur\n        const captureData: {\n          capturedWhite: PieceType[];\n          capturedBlack: PieceType[];\n        } = {\n          capturedWhite: [],\n          capturedBlack: [],\n        };\n\n        if (capturedPawn.color === PieceColor.WHITE) {\n          captureData.capturedWhite.push(capturedPawn.type);\n        } else {\n          captureData.capturedBlack.push(capturedPawn.type);\n        }\n\n        // Appelle updateCapturedPieces pour mettre à jour le DOM\n        updateCapturedPieces(capturedPawn.type, capturedPawn.color);\n\n        return captureData;\n      }\n    }\n    return null;\n  }\n\n  public isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (!this.enPassantTarget) return false;\n\n    // Vérifie que le mouvement cible la bonne case pour la prise en passant\n    const piece = this.getPiece(fromX, fromY);\n    return (\n      piece?.type === PieceType.PAWN &&\n      toX === this.enPassantTarget.x &&\n      toY === this.enPassantTarget.y &&\n      Math.abs(fromX - toX) === 1 &&\n      Math.abs(fromY - toY) === 1\n    );\n  }\n\n  public async promotePawn(\n    x: number,\n    y: number,\n    pieceType: string,\n  ): Promise<void> {\n    const color = this.getPiece(x, y)?.color;\n\n    if (!color) return;\n\n    switch (pieceType) {\n      case 'queen':\n        this.grid[y][x] = await createPiece(PieceType.QUEEN, color);\n        break;\n      case 'rook':\n        this.grid[y][x] = await createPiece(PieceType.ROOK, color);\n        break;\n      case 'bishop':\n        this.grid[y][x] = await createPiece(PieceType.BISHOP, color);\n        break;\n      case 'knight':\n        this.grid[y][x] = await createPiece(PieceType.KNIGHT, color);\n        break;\n    }\n  }\n\n  public isKingInCheck(color: PieceColor): boolean {\n    const kingPosition = this.findKing(color);\n    if (!kingPosition) {\n      return false;\n    }\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(x, y, kingPosition.x, kingPosition.y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  public isCheckmate(color: PieceColor): boolean {\n    if (!this.isKingInCheck(color)) {\n      return false; // Pas de mat si le roi n'est pas en échec\n    }\n\n    // Parcourt chaque pièce de la couleur donnée pour trouver un mouvement légal\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          const moves = this.getValidMoves(x, y);\n\n          for (const move of moves) {\n            // Simule le mouvement\n            const originalPiece = this.getPiece(move.x, move.y);\n            this.grid[move.y][move.x] = piece;\n            this.grid[y][x] = null;\n\n            const kingSafe = !this.isKingInCheck(color);\n\n            // Annule le mouvement simulé\n            this.grid[y][x] = piece;\n            this.grid[move.y][move.x] = originalPiece;\n\n            if (kingSafe) {\n              return false; // Un mouvement légal existe pour sortir de l'échec\n            }\n          }\n        }\n      }\n    }\n\n    return true; // Aucun mouvement possible, échec et mat\n  }\n\n  public isStalemate(color: PieceColor): boolean {\n    // Pat uniquement si le roi n'est pas en échec et qu'il n'y a aucun coup légal disponible\n    if (this.isKingInCheck(color)) return false;\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          for (let toY = 0; toY < 8; toY++) {\n            for (let toX = 0; toX < 8; toX++) {\n              if (piece.isValidMove(x, y, toX, toY, this)) {\n                // Simuler le mouvement pour vérifier l'échec potentiel\n                const originalPiece = this.getPiece(toX, toY);\n                this.grid[toY][toX] = piece;\n                this.grid[y][x] = null;\n\n                const isKingSafe = !this.isKingInCheck(color);\n\n                // Annuler le mouvement simulé\n                this.grid[y][x] = piece;\n                this.grid[toY][toX] = originalPiece;\n\n                if (isKingSafe) return false; // Mouvement valide trouvé, pas de pat\n              }\n            }\n          }\n        }\n      }\n    }\n    return true; // Aucun coup légal trouvé, pat détecté\n  }\n\n  private findKing(color: PieceColor): { x: number; y: number } | null {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece?.type === PieceType.KING && piece.color === color) {\n          return { x, y };\n        }\n      }\n    }\n    return null;\n  }\n\n  public isKing(x: number, y: number): boolean {\n    const piece = this.getPiece(x, y);\n    return piece?.type === PieceType.KING;\n  }\n\n  public isSquareUnderAttack(x: number, y: number, color: PieceColor): boolean {\n    for (let fromY = 0; fromY < 8; fromY++) {\n      for (let fromX = 0; fromX < 8; fromX++) {\n        const piece = this.getPiece(fromX, fromY);\n        if (piece && piece.color !== color) {\n          // Vérifie si la pièce adverse peut se déplacer sur la case (x, y)\n          if (piece.isValidMove(fromX, fromY, x, y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Vérifie le matériel insuffisant pour un échec et mat\n  public isInsufficientMaterial(): boolean {\n    const pieces = this.grid.flat().filter((piece) => piece !== null);\n\n    // Cas les plus courants de matériel insuffisant\n    if (pieces.length <= 2) return true; // Seulement les rois sur le plateau\n    return (\n      pieces.length === 3 &&\n      pieces.some(\n        (piece) =>\n          piece?.type === PieceType.BISHOP || piece?.type === PieceType.KNIGHT,\n      )\n    );\n  }\n\n  // Vérifie si la règle des 50 coups est remplie\n  public isFiftyMoveRule(): boolean {\n    return this.halfMoveCount >= 50;\n  }\n\n  public setPiece(x: number, y: number, piece: Piece | null): void {\n    this.grid[y][x] = piece;\n  }\n\n  // Vérifie si un mouvement est valide\n  public isMoveValid(\n    fromRow: number,\n    fromCol: number,\n    toRow: number,\n    toCol: number,\n  ): boolean {\n    const piece = this.getPiece(fromRow, fromCol);\n\n    // Si aucune pièce n'est présente à l'emplacement source, le mouvement est invalide\n    if (!piece) {\n      return false;\n    }\n\n    // Si la destination est en dehors de l'échiquier, mouvement invalide\n    if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) {\n      return false;\n    }\n\n    // Vérifie si la pièce peut se déplacer à cette destination en utilisant la logique de mouvement de la pièce\n    if (!piece.isValidMove(fromRow, fromCol, toRow, toCol, this)) {\n      return false;\n    }\n\n    // Vérifie s'il y a une pièce à la destination et si elle est de la même couleur\n    const destinationPiece = this.getPiece(toRow, toCol);\n    return !(destinationPiece && destinationPiece.color === piece.color);\n  }\n\n  public isCapture(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    const piece = this.isWithinBounds(fromX, fromY)\n      ? this.getPiece(fromX, fromY)\n      : null;\n    const targetPiece = this.isWithinBounds(toX, toY)\n      ? this.getPiece(toX, toY)\n      : null;\n\n    // Vérifie qu'il y a une pièce à la position cible et qu'elle est d'une couleur opposée\n    return (\n      piece !== null &&\n      targetPiece !== null &&\n      piece.color !== targetPiece.color\n    );\n  }\n\n  public static async fromData(data: any): Promise<Board> {\n    const board = new Board();\n    await board.init();\n    board.grid = await Promise.all(\n      data.grid.map(async (row: any[]) =>\n        Promise.all(\n          row.map(async (pieceData) =>\n            pieceData ? await Piece.fromData(pieceData) : null,\n          ),\n        ),\n      ),\n    );\n    return board;\n  }\n\n  public toData(): any {\n    return {\n      grid: this.grid.map((row) =>\n        row.map((piece) => (piece ? piece.toData() : null)),\n      ),\n    };\n  }\n\n  public isAdjacentToAnotherKing(\n    x: number,\n    y: number,\n    color: PieceColor,\n  ): boolean {\n    const kingPositions = [\n      { dx: -1, dy: -1 },\n      { dx: -1, dy: 0 },\n      { dx: -1, dy: 1 },\n      { dx: 0, dy: -1 },\n      { dx: 0, dy: 1 },\n      { dx: 1, dy: -1 },\n      { dx: 1, dy: 0 },\n      { dx: 1, dy: 1 },\n    ];\n\n    for (const { dx, dy } of kingPositions) {\n      const nx = x + dx;\n      const ny = y + dy;\n      const piece = this.isWithinBounds(nx, ny) ? this.getPiece(nx, ny) : null;\n      if (piece?.type === PieceType.KING && piece.color !== color) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public clone(): Board {\n    const clonedBoard = new Board();\n    clonedBoard.grid = this.grid.map((row) =>\n      row.map((piece) =>\n        piece\n          ? Object.create(\n              Object.getPrototypeOf(piece),\n              Object.getOwnPropertyDescriptors(piece),\n            )\n          : null,\n      ),\n    );\n    clonedBoard.enPassantTarget = this.enPassantTarget\n      ? { ...this.enPassantTarget }\n      : null;\n    clonedBoard.halfMoveCount = this.halfMoveCount;\n    return clonedBoard;\n  }\n\n  public getPieceCount(): number {\n    return this.grid.flat().filter((piece) => piece !== null).length;\n  }\n\n  public isGameOver(): boolean {\n    // Vérifie l'échec et mat pour chaque couleur\n    if (\n      this.isCheckmate(PieceColor.WHITE) ||\n      this.isCheckmate(PieceColor.BLACK)\n    ) {\n      return true;\n    }\n\n    // Vérifie le pat pour chaque couleur\n    if (\n      this.isStalemate(PieceColor.WHITE) ||\n      this.isStalemate(PieceColor.BLACK)\n    ) {\n      return true;\n    }\n\n    // Vérifie le matériel insuffisant pour chaque couleur\n    if (this.isInsufficientMaterial()) {\n      return true;\n    }\n\n    // Vérifie si la règle des 50 coups est atteinte\n    return this.isFiftyMoveRule();\n  }\n\n  public getWinner(): PieceColor | null {\n    // Si c'est un échec et mat pour les Noirs, Blancs gagnent\n    if (this.isCheckmate(PieceColor.BLACK)) {\n      return PieceColor.WHITE;\n    }\n\n    // Si c'est un échec et mat pour les Blancs, Noirs gagnent\n    if (this.isCheckmate(PieceColor.WHITE)) {\n      return PieceColor.BLACK;\n    }\n\n    // Si c'est un pat, une égalité par matériel insuffisant, ou la règle des 50 coups, la partie est nulle\n    if (\n      this.isStalemate(PieceColor.WHITE) ||\n      this.isStalemate(PieceColor.BLACK) ||\n      this.isInsufficientMaterial() ||\n      this.isFiftyMoveRule()\n    ) {\n      return null;\n    }\n\n    return null; // Retourne null si le jeu n'est pas encore terminé\n  }\n\n  public getPieces(): Piece[] {\n    return this.grid.flat().filter((piece): piece is Piece => piece !== null);\n  }\n\n  public setPlayerColor(color: PieceColor): void {\n    this.currentPlayer = color;\n  }\n\n  public getPlayerColor(): PieceColor {\n    return this.currentPlayer;\n  }\n}\n","// src/evaluator.ts\nimport { Board } from './board';\nimport { PieceColor, PieceType } from './piece';\n\n// Valeurs des pièces (évaluation de base)\nconst pieceValues: { [key in PieceType]: number } = {\n  [PieceType.PAWN]: 1,\n  [PieceType.KNIGHT]: 3,\n  [PieceType.BISHOP]: 3.25,\n  [PieceType.ROOK]: 5,\n  [PieceType.QUEEN]: 9,\n  [PieceType.KING]: 0,\n};\n\n// Tables de positions pour améliorer l'évaluation\nconst pieceSquareTables: { [key in PieceType]: number[][] } = {\n  [PieceType.PAWN]: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n    [0.1, 0.1, 0.2, 0.3, 0.3, 0.2, 0.1, 0.1],\n    [0.05, 0.05, 0.1, 0.25, 0.25, 0.1, 0.05, 0.05],\n    [0, 0, 0, 0.2, 0.2, 0, 0, 0],\n    [0.05, -0.05, -0.1, 0, 0, -0.1, -0.05, 0.05],\n    [0.05, 0.1, 0.1, -0.2, -0.2, 0.1, 0.1, 0.05],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n  ],\n  [PieceType.KNIGHT]: [\n    [-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5],\n    [-0.4, -0.2, 0, 0, 0, 0, -0.2, -0.4],\n    [-0.3, 0, 0.1, 0.15, 0.15, 0.1, 0, -0.3],\n    [-0.3, 0.05, 0.15, 0.2, 0.2, 0.15, 0.05, -0.3],\n    [-0.3, 0, 0.15, 0.2, 0.2, 0.15, 0, -0.3],\n    [-0.3, 0.05, 0.1, 0.15, 0.15, 0.1, 0.05, -0.3],\n    [-0.4, -0.2, 0, 0.05, 0.05, 0, -0.2, -0.4],\n    [-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5],\n  ],\n  [PieceType.BISHOP]: [\n    [-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2],\n    [-0.1, 0, 0, 0, 0, 0, 0, -0.1],\n    [-0.1, 0, 0.05, 0.1, 0.1, 0.05, 0, -0.1],\n    [-0.1, 0.05, 0.05, 0.1, 0.1, 0.05, 0.05, -0.1],\n    [-0.1, 0, 0.1, 0.1, 0.1, 0.1, 0, -0.1],\n    [-0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, -0.1],\n    [-0.1, 0.05, 0, 0, 0, 0, 0.05, -0.1],\n    [-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2],\n  ],\n  [PieceType.ROOK]: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [0, 0, 0, 0.05, 0.05, 0, 0, 0],\n  ],\n  [PieceType.QUEEN]: [\n    [-0.2, -0.1, -0.1, -0.05, -0.05, -0.1, -0.1, -0.2],\n    [-0.1, 0, 0, 0, 0, 0, 0, -0.1],\n    [-0.1, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.1],\n    [-0.05, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.05],\n    [0, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.05],\n    [-0.1, 0.05, 0.05, 0.05, 0.05, 0.05, 0, -0.1],\n    [-0.1, 0, 0.05, 0, 0, 0, 0, -0.1],\n    [-0.2, -0.1, -0.1, -0.05, -0.05, -0.1, -0.1, -0.2],\n  ],\n  [PieceType.KING]: [\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.2, -0.3, -0.3, -0.4, -0.4, -0.3, -0.3, -0.2],\n    [-0.1, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.1],\n    [0.2, 0.2, 0, 0, 0, 0, 0.2, 0.2],\n    [0.2, 0.3, 0, 0, 0, 0, 0.3, 0.2],\n  ],\n};\n\n// Bonus pour le contrôle du centre du plateau (cases centrales plus précieuses)\nexport const centerControlBonus: { [key: string]: number } = {\n  '3,3': 0.5,\n  '3,4': 0.5,\n  '4,3': 0.5,\n  '4,4': 0.5, // Cases centrales\n  '2,3': 0.25,\n  '2,4': 0.25,\n  '3,2': 0.25,\n  '4,2': 0.25,\n  '4,5': 0.25,\n  '3,5': 0.25,\n  '5,3': 0.25,\n  '5,4': 0.25, // Cases autour\n};\n\n// Fonction d'évaluation principale\nexport function evaluateBoard(board: Board, color: PieceColor): number {\n  let score = 0;\n\n  for (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n      const piece = board.getPiece(x, y);\n      if (piece) {\n        let pieceScore = pieceValues[piece.type];\n\n        // Appliquer les tables de position selon le type de pièce\n        const pieceTable = pieceSquareTables[piece.type];\n        if (pieceTable) {\n          const adjustedY = color === PieceColor.WHITE ? y : 7 - y;\n          pieceScore += pieceTable[adjustedY][x];\n        }\n\n        // Contrôle du centre du plateau\n        const adjustedY = color === PieceColor.WHITE ? y : 7 - y;\n        const positionKey = `${x},${adjustedY}`;\n        if (centerControlBonus[positionKey]) {\n          pieceScore += centerControlBonus[positionKey];\n        }\n\n        // Structure des pions pour vérifier les pions passés\n        if (piece.type === PieceType.PAWN) {\n          pieceScore += evaluatePawnStructure(board, x, y, piece.color);\n          if (isPassedPawn(board, x, y, piece.color)) {\n            pieceScore += 1.0; // Bonus pour les pions passés\n          }\n        }\n\n        // Vérifier si le roi est exposé\n        if (\n          piece.type === PieceType.KING &&\n          isKingExposed(board, x, y, piece.color)\n        ) {\n          pieceScore -= 0.5; // Réduction pour les rois exposés\n        }\n\n        score += piece.color === color ? pieceScore : -pieceScore;\n      }\n    }\n  }\n\n  return parseFloat(score.toFixed(2));\n}\n\n// Évaluer la structure des pions\nfunction evaluatePawnStructure(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  let score = 0;\n\n  // Vérifier les pions doublés et isolés avec une pénalité plus importante\n  score -= checkDoubledPawns(board, x, y, color) * 1.5; // Pénalité augmentée pour les pions doublés\n  score -= checkIsolatedPawns(board, x, y, color) * 1.5; // Pénalité augmentée pour les pions isolés\n\n  return score;\n}\n\nfunction checkDoubledPawns(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  for (let i = 0; i < 8; i++) {\n    if (\n      i !== y &&\n      board.getPiece(x, i)?.type === PieceType.PAWN &&\n      board.getPiece(x, i)?.color === color\n    ) {\n      return 0.5;\n    }\n  }\n  return 0;\n}\n\nfunction checkIsolatedPawns(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  const leftColumn = x - 1 >= 0 ? board.getPiece(x - 1, y) : null;\n  const rightColumn = x + 1 < 8 ? board.getPiece(x + 1, y) : null;\n\n  if (\n    (!leftColumn ||\n      leftColumn.type !== PieceType.PAWN ||\n      leftColumn.color !== color) &&\n    (!rightColumn ||\n      rightColumn.type !== PieceType.PAWN ||\n      rightColumn.color !== color)\n  ) {\n    return 1.5; // Augmentation de la pénalité pour les pions isolés\n  }\n\n  return 0;\n}\n\nfunction isKingExposed(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): boolean {\n  const piece = board.getPiece(x, y);\n  if (piece && piece.type === PieceType.KING) {\n    const surroundingSquares = [\n      { dx: -1, dy: 0 },\n      { dx: 1, dy: 0 },\n      { dx: 0, dy: -1 },\n      { dx: 0, dy: 1 },\n      { dx: -1, dy: -1 },\n      { dx: 1, dy: 1 },\n      { dx: -1, dy: 1 },\n      { dx: 1, dy: -1 },\n    ];\n\n    return surroundingSquares.some(({ dx, dy }) => {\n      const newX = x + dx;\n      const newY = y + dy;\n\n      if (board.isWithinBounds(newX, newY)) {\n        const adjPiece = board.getPiece(newX, newY);\n        return (\n          !adjPiece || // Case vide\n          adjPiece.color !== color || // Pièce ennemie\n          adjPiece.type !== PieceType.PAWN // Pas de pion pour protéger\n        );\n      }\n      return true; // Case hors limites, expose le roi\n    });\n  }\n  return false;\n}\n\nfunction isPassedPawn(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): boolean {\n  const direction = color === PieceColor.WHITE ? -1 : 1;\n\n  for (let i = y + direction; i >= 0 && i < 8; i += direction) {\n    const pieceInFront = board.getPiece(x, i);\n    if (\n      pieceInFront &&\n      pieceInFront.type === PieceType.PAWN &&\n      pieceInFront.color !== color\n    ) {\n      return false;\n    }\n  }\n\n  // Vérifier s'il y a des pions alliés sur les colonnes adjacentes\n  const adjacentColumns = [x - 1, x + 1];\n  return adjacentColumns.every((col) => {\n    if (col < 0 || col >= 8) return true;\n    for (let i = 0; i < 8; i++) {\n      const adjacentPiece = board.getPiece(col, i);\n      if (\n        adjacentPiece &&\n        adjacentPiece.type === PieceType.PAWN &&\n        adjacentPiece.color === color\n      ) {\n        return false;\n      }\n    }\n    return true;\n  });\n}\n","// src/endgameTablebase.ts\nimport { Board } from './board';\nimport { PieceColor, PieceType } from './piece';\n\ntype Move = { fromX: number; fromY: number; toX: number; toY: number };\n\n// Retourne un mouvement optimal pour une fin de partie classique si disponible\nexport function getEndgameMove(board: Board, color: PieceColor): Move | null {\n  const pieces = board.getPieces();\n\n  // Roi + Tour contre Roi\n  if (\n    pieces.length === 3 &&\n    hasPiece(pieces, PieceType.KING, color) &&\n    hasPiece(pieces, PieceType.ROOK, color) &&\n    hasPiece(pieces, PieceType.KING, getOpponentColor(color))\n  ) {\n    return getKingRookVsKingMove(board, color);\n  }\n\n  // Roi + Fou + Cavalier contre Roi\n  if (\n    pieces.length === 4 &&\n    hasPiece(pieces, PieceType.KING, color) &&\n    hasPiece(pieces, PieceType.BISHOP, color) &&\n    hasPiece(pieces, PieceType.KNIGHT, color) &&\n    hasPiece(pieces, PieceType.KING, getOpponentColor(color))\n  ) {\n    return getKingBishopKnightVsKingMove(board, color);\n  }\n\n  // Roi + deux Fous contre Roi\n  if (\n    pieces.length === 4 &&\n    hasPiece(pieces, PieceType.KING, color) &&\n    hasPiece(pieces, PieceType.BISHOP, color) &&\n    pieces.filter(\n      (piece) => piece.type === PieceType.BISHOP && piece.color === color,\n    ).length === 2 &&\n    hasPiece(pieces, PieceType.KING, getOpponentColor(color))\n  ) {\n    return getKingTwoBishopsVsKingMove(board, color);\n  }\n\n  // Roi + Pion contre Roi (pour promotion)\n  if (\n    pieces.length === 3 &&\n    hasPiece(pieces, PieceType.KING, color) &&\n    hasPiece(pieces, PieceType.PAWN, color) &&\n    hasPiece(pieces, PieceType.KING, getOpponentColor(color))\n  ) {\n    return getKingPawnVsKingMove(board, color);\n  }\n\n  return null; // Aucun mouvement de fin de partie trouvé\n}\n\n// Fonction utilitaire pour vérifier la présence d'une pièce spécifique\nfunction hasPiece(pieces: any[], type: PieceType, color: PieceColor): boolean {\n  return pieces.some((piece) => piece.type === type && piece.color === color);\n}\n\n// Renvoie l'autre couleur\nfunction getOpponentColor(color: PieceColor): PieceColor {\n  return color === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n}\n\n// Génère un mouvement optimal pour Roi + Tour contre Roi\nfunction getKingRookVsKingMove(board: Board, color: PieceColor): Move | null {\n  const opponentKingPos = findPiecePosition(\n    board,\n    PieceType.KING,\n    getOpponentColor(color),\n  );\n  const rookPos = findPiecePosition(board, PieceType.ROOK, color);\n\n  if (!opponentKingPos || !rookPos) return null;\n\n  // Exemple : pousse la tour pour bloquer le roi adverse dans un coin\n  if (opponentKingPos.x < 4) {\n    return {\n      fromX: rookPos.x,\n      fromY: rookPos.y,\n      toX: opponentKingPos.x + 1,\n      toY: opponentKingPos.y,\n    };\n  } else {\n    return {\n      fromX: rookPos.x,\n      fromY: rookPos.y,\n      toX: opponentKingPos.x - 1,\n      toY: opponentKingPos.y,\n    };\n  }\n}\n\n// Génère un mouvement optimal pour Roi + Fou + Cavalier contre Roi\nfunction getKingBishopKnightVsKingMove(\n  board: Board,\n  color: PieceColor,\n): Move | null {\n  const opponentKingPos = findPiecePosition(\n    board,\n    PieceType.KING,\n    getOpponentColor(color),\n  );\n  const knightPos = findPiecePosition(board, PieceType.KNIGHT, color);\n  const bishopPos = findPiecePosition(board, PieceType.BISHOP, color);\n\n  if (!opponentKingPos || !knightPos || !bishopPos) return null;\n\n  // Exemple : pousse le cavalier et le fou pour rapprocher le roi adverse vers un coin\n  if (opponentKingPos.x < 4) {\n    return {\n      fromX: knightPos.x,\n      fromY: knightPos.y,\n      toX: opponentKingPos.x + 1,\n      toY: opponentKingPos.y,\n    };\n  } else {\n    return {\n      fromX: bishopPos.x,\n      fromY: bishopPos.y,\n      toX: opponentKingPos.x - 1,\n      toY: opponentKingPos.y,\n    };\n  }\n}\n\n// Génère un mouvement optimal pour Roi + deux Fous contre Roi\nfunction getKingTwoBishopsVsKingMove(\n  board: Board,\n  color: PieceColor,\n): Move | null {\n  const opponentKingPos = findPiecePosition(\n    board,\n    PieceType.KING,\n    getOpponentColor(color),\n  );\n  const bishops = findAllPiecesPositions(board, PieceType.BISHOP, color);\n\n  if (!opponentKingPos || bishops.length < 2) return null;\n\n  // Les deux fous coordonnent pour forcer le roi adverse vers un coin\n  return {\n    fromX: bishops[0].x,\n    fromY: bishops[0].y,\n    toX: opponentKingPos.x,\n    toY: opponentKingPos.y > 4 ? opponentKingPos.y - 1 : opponentKingPos.y + 1,\n  };\n}\n\n// Génère un mouvement optimal pour Roi + Pion contre Roi (promotion)\nfunction getKingPawnVsKingMove(board: Board, color: PieceColor): Move | null {\n  const opponentKingPos = findPiecePosition(\n    board,\n    PieceType.KING,\n    getOpponentColor(color),\n  );\n  const pawnPos = findPiecePosition(board, PieceType.PAWN, color);\n\n  if (!opponentKingPos || !pawnPos) return null;\n\n  // Pousse le pion vers la promotion (vers la 8ème rangée pour les Blancs, 1ère pour les Noirs)\n  const direction = color === PieceColor.WHITE ? 1 : -1;\n  return {\n    fromX: pawnPos.x,\n    fromY: pawnPos.y,\n    toX: pawnPos.x,\n    toY: pawnPos.y + direction,\n  };\n}\n\n// Fonction utilitaire pour trouver la position d'une pièce spécifique\nfunction findPiecePosition(\n  board: Board,\n  pieceType: PieceType,\n  color: PieceColor,\n): { x: number; y: number } | null {\n  for (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n      const piece = board.getPiece(x, y);\n      if (piece && piece.type === pieceType && piece.color === color) {\n        return { x, y };\n      }\n    }\n  }\n  return null;\n}\n\n// Fonction utilitaire pour trouver toutes les positions d'un type de pièce\nfunction findAllPiecesPositions(\n  board: Board,\n  pieceType: PieceType,\n  color: PieceColor,\n): { x: number; y: number }[] {\n  const positions = [];\n  for (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n      const piece = board.getPiece(x, y);\n      if (piece && piece.type === pieceType && piece.color === color) {\n        positions.push({ x, y });\n      }\n    }\n  }\n  return positions;\n}\n","// src/openingBook.ts\n\nexport const openingBook: {\n  [key: string]: { fromX: number; fromY: number; toX: number; toY: number }[];\n} = {\n  // Ouverture Ruy Lopez\n  'e2e4 e7e5 g1f3 b8c6 f1b5': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 4, fromY: 1, toX: 4, toY: 3 }, // e7e5\n    { fromX: 6, fromY: 7, toX: 5, toY: 5 }, // g1f3\n    { fromX: 1, fromY: 0, toX: 2, toY: 2 }, // b8c6\n    { fromX: 5, fromY: 7, toX: 1, toY: 5 }, // f1b5\n  ],\n\n  // Défense Sicilienne\n  'e2e4 c7c5': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 2, fromY: 1, toX: 2, toY: 3 }, // c7c5\n  ],\n  'e2e4 c7c5 g1f3 d7d6': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 2, fromY: 1, toX: 2, toY: 3 }, // c7c5\n    { fromX: 6, fromY: 7, toX: 5, toY: 5 }, // g1f3\n    { fromX: 3, fromY: 1, toX: 3, toY: 2 }, // d7d6\n  ],\n\n  // Gambit de la Reine\n  'd2d4 d7d5 c2c4': [\n    { fromX: 3, fromY: 6, toX: 3, toY: 4 }, // d2d4\n    { fromX: 3, fromY: 1, toX: 3, toY: 3 }, // d7d5\n    { fromX: 2, fromY: 6, toX: 2, toY: 4 }, // c2c4\n  ],\n\n  // Défense Caro-Kann\n  'e2e4 c7c6': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 2, fromY: 1, toX: 2, toY: 2 }, // c7c6\n  ],\n  'e2e4 c7c6 d2d4 d7d5': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 2, fromY: 1, toX: 2, toY: 2 }, // c7c6\n    { fromX: 3, fromY: 6, toX: 3, toY: 4 }, // d2d4\n    { fromX: 3, fromY: 1, toX: 3, toY: 3 }, // d7d5\n  ],\n\n  // Défense Française\n  'e2e4 e7e6': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 4, fromY: 1, toX: 4, toY: 2 }, // e7e6\n  ],\n  'e2e4 e7e6 d2d4 d7d5': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 4, fromY: 1, toX: 4, toY: 2 }, // e7e6\n    { fromX: 3, fromY: 6, toX: 3, toY: 4 }, // d2d4\n    { fromX: 3, fromY: 1, toX: 3, toY: 3 }, // d7d5\n  ],\n\n  // Partie Italienne\n  'e2e4 e7e5 g1f3 b8c6 f1c4': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 4, fromY: 1, toX: 4, toY: 3 }, // e7e5\n    { fromX: 6, fromY: 7, toX: 5, toY: 5 }, // g1f3\n    { fromX: 1, fromY: 0, toX: 2, toY: 2 }, // b8c6\n    { fromX: 5, fromY: 7, toX: 2, toY: 4 }, // f1c4\n  ],\n\n  // Défense Alekhine\n  'e2e4 g8f6': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 6, fromY: 0, toX: 5, toY: 2 }, // g8f6\n  ],\n\n  // Défense Pirc\n  'e2e4 d7d6': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 3, fromY: 1, toX: 3, toY: 2 }, // d7d6\n  ],\n\n  // Partie Écossaise\n  'e2e4 e7e5 g1f3 b8c6 d2d4': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 4, fromY: 1, toX: 4, toY: 3 }, // e7e5\n    { fromX: 6, fromY: 7, toX: 5, toY: 5 }, // g1f3\n    { fromX: 1, fromY: 0, toX: 2, toY: 2 }, // b8c6\n    { fromX: 3, fromY: 6, toX: 3, toY: 4 }, // d2d4\n  ],\n\n  // Gambit du Roi\n  'e2e4 e7e5 f2f4': [\n    { fromX: 4, fromY: 6, toX: 4, toY: 4 }, // e2e4\n    { fromX: 4, fromY: 1, toX: 4, toY: 3 }, // e7e5\n    { fromX: 5, fromY: 6, toX: 5, toY: 4 }, // f2f4\n  ],\n\n  // Ouverture anglaise\n  c2c4: [\n    { fromX: 2, fromY: 6, toX: 2, toY: 4 }, // c2c4\n  ],\n\n  // Ouverture Réti\n  'g1f3 d7d5': [\n    { fromX: 6, fromY: 7, toX: 5, toY: 5 }, // g1f3\n    { fromX: 3, fromY: 1, toX: 3, toY: 3 }, // d7d5\n  ],\n};\n","// src/ai.ts\nimport { Board } from './board';\nimport { PieceColor, PieceType, Piece } from './piece';\nimport { evaluateBoard, centerControlBonus } from './evaluator';\nimport { getEndgameMove } from './endgameTablebase';\nimport { openingBook } from './openingBook';\n\n// Classe AI utilisant l'algorithme Minimax avec Alpha-Beta Pruning et Transposition Table\nexport class AI {\n  private openingMoves: {\n    [key: string]: { fromX: number; fromY: number; toX: number; toY: number }[];\n  } = openingBook;\n  private transpositionTable: Map<string, number>; // Table de transposition\n  private readonly maxTime: number; // Temps maximum de réflexion en millisecondes\n  private startTime: number; // Temps de début pour gestion du temps\n  private readonly killerMoves: Map<\n    number,\n    {\n      move: { fromX: number; fromY: number; toX: number; toY: number };\n      score: number;\n    }[]\n  >; // Heuristic des coups efficaces\n\n  constructor(\n    private color: PieceColor,\n    maxTime: number = 5000,\n  ) {\n    this.transpositionTable = new Map();\n    this.maxTime = maxTime;\n    this.killerMoves = new Map();\n    this.startTime = 0;\n  }\n\n  // Méthode principale pour faire un mouvement\n  public makeMove(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    const openingMove = this.getOpeningMove(board);\n    if (openingMove) {\n      return openingMove;\n    }\n\n    // Vérifie si on peut utiliser une table de fin de partie\n    const endgameMove = this.useEndgameTablebase(board);\n    if (endgameMove) {\n      return endgameMove;\n    }\n\n    // Détermine si MCTS est pertinent pour la position actuelle\n    if (this.shouldUseMCTS(board)) {\n      return this.mcts(board); // Utilise MCTS pour les positions complexes ou de fin de partie\n    }\n\n    // Si MCTS n'est pas utilisé, continue avec Minimax\n    let bestMove = null;\n    let bestValue = -Infinity;\n    const maxDepth = 10; // Augmentation de la profondeur maximale de recherche\n    this.startTime = Date.now();\n\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      let moves = this.getAllValidMoves(board);\n\n      // Trie les mouvements pour optimiser la recherche\n      moves = this.sortMoves(moves, board, depth);\n\n      for (const move of moves) {\n        const piece = board.getPiece(move.fromX, move.fromY);\n        if (!piece) continue;\n        const originalPiece = board.getPiece(move.toX, move.toY);\n        board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n        const isCritical =\n          board.isKingInCheck(this.color) ||\n          this.isCriticalMove(piece, move, board);\n        const adjustedDepth = isCritical ? depth + 1 : depth;\n\n        // Appelle la recherche Minimax avec Alpha-Beta Pruning\n        const boardValue = this.minimax(\n          board,\n          adjustedDepth - 1,\n          -Infinity,\n          Infinity,\n          false,\n        );\n\n        board.setPiece(move.fromX, move.fromY, piece);\n        board.setPiece(move.toX, move.toY, originalPiece);\n\n        if (boardValue > bestValue) {\n          bestValue = boardValue;\n          bestMove = move;\n        }\n\n        // Limite le temps de réflexion\n        if (Date.now() - this.startTime > this.maxTime) {\n          break;\n        }\n      }\n\n      // Limite le temps de réflexion\n      if (Date.now() - this.startTime > this.maxTime) {\n        break;\n      }\n    }\n\n    return bestMove;\n  }\n\n  // Fonction Minimax avec Alpha-Beta Pruning et table de transposition\n  private minimax(\n    board: Board,\n    depth: number,\n    alpha: number,\n    beta: number,\n    isMaximizing: boolean,\n  ): number {\n    const boardKey = board.toString();\n\n    // Vérifie le temps limite\n    if (Date.now() - this.startTime > this.maxTime) {\n      return evaluateBoard(board, this.color);\n    }\n\n    // Vérifie si le résultat est déjà dans la table de transposition\n    if (this.transpositionTable.has(boardKey)) {\n      return this.transpositionTable.get(boardKey)!;\n    }\n\n    // Null Move Pruning : Effectue un coup nul pour voir si une menace est évidente\n    if (depth > 1 && !board.isKingInCheck(this.color)) {\n      const nullMoveEval = -this.minimax(\n        board,\n        depth - 2,\n        -beta,\n        -alpha,\n        !isMaximizing,\n      );\n      if (nullMoveEval >= beta) {\n        return beta; // Coupe si le coup nul montre une menace\n      }\n    }\n\n    // Condition de fin de récursion\n    if (\n      depth === 0 ||\n      board.isCheckmate(this.color) ||\n      board.isCheckmate(this.getOpponentColor()) ||\n      Date.now() - this.startTime > this.maxTime\n    ) {\n      const evaluation = this.quiescenceSearch(board, alpha, beta);\n      this.transpositionTable.set(boardKey, evaluation);\n      return evaluation;\n    }\n\n    if (isMaximizing) {\n      let maxEval = -Infinity;\n      let moves = this.getAllValidMoves(board);\n      moves = this.sortMoves(moves, board, depth);\n\n      for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const fromPiece = board.getPiece(move.fromX, move.fromY);\n        const toPiece = board.getPiece(move.toX, move.toY);\n\n        // Late Move Reduction : Réduit la profondeur pour les coups tardifs\n        const shouldReduce = i > 3 && depth > 2;\n        const newDepth = shouldReduce ? depth - 1 : depth;\n\n        // Extension : Allonge la profondeur pour les échecs et poussées de pions\n        const isCheck = board.isKingInCheck(this.color);\n        const isPawnPush =\n          fromPiece &&\n          fromPiece.type === PieceType.PAWN &&\n          (move.toY === 0 || move.toY === 7);\n        const extendedDepth = isCheck || isPawnPush ? newDepth + 1 : newDepth;\n\n        board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n        const evaluation = this.minimax(\n          board,\n          extendedDepth - 1,\n          alpha,\n          beta,\n          false,\n        );\n        board.setPiece(move.fromX, move.fromY, fromPiece);\n        board.setPiece(move.toX, move.toY, toPiece);\n\n        maxEval = Math.max(maxEval, evaluation);\n        alpha = Math.max(alpha, evaluation);\n\n        if (beta <= alpha) {\n          this.addKillerMove(depth, move);\n          break;\n        }\n      }\n\n      this.transpositionTable.set(boardKey, maxEval);\n      return maxEval;\n    } else {\n      let minEval = Infinity;\n      let moves = this.getAllValidMoves(board);\n      moves = this.sortMoves(moves, board, depth);\n\n      for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const fromPiece = board.getPiece(move.fromX, move.fromY);\n        const toPiece = board.getPiece(move.toX, move.toY);\n\n        // Late Move Reduction : Réduit la profondeur pour les coups tardifs\n        const shouldReduce = i > 3 && depth > 2;\n        const newDepth = shouldReduce ? depth - 1 : depth;\n\n        // Extension : Allonge la profondeur pour les échecs et poussées de pions\n        const isCheck = board.isKingInCheck(this.getOpponentColor());\n        const isPawnPush =\n          fromPiece &&\n          fromPiece.type === PieceType.PAWN &&\n          (move.toY === 0 || move.toY === 7);\n        const extendedDepth = isCheck || isPawnPush ? newDepth + 1 : newDepth;\n\n        board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n        const evaluation = this.minimax(\n          board,\n          extendedDepth - 1,\n          alpha,\n          beta,\n          true,\n        );\n        board.setPiece(move.fromX, move.fromY, fromPiece);\n        board.setPiece(move.toX, move.toY, toPiece);\n\n        minEval = Math.min(minEval, evaluation);\n        beta = Math.min(beta, evaluation);\n\n        if (beta <= alpha) {\n          this.addKillerMove(depth, move);\n          break;\n        }\n      }\n\n      this.transpositionTable.set(boardKey, minEval);\n      return minEval;\n    }\n  }\n\n  // Ajout d'un coup prometteur dans les killer moves\n  private addKillerMove(\n    depth: number,\n    move: { fromX: number; fromY: number; toX: number; toY: number },\n  ) {\n    const killers = this.killerMoves.get(depth) || [];\n    const existingMove = killers.find(\n      (k) =>\n        k.move.fromX === move.fromX &&\n        k.move.fromY === move.fromY &&\n        k.move.toX === move.toX &&\n        k.move.toY === move.toY,\n    );\n\n    if (existingMove) {\n      existingMove.score += 1;\n    } else {\n      killers.push({ move, score: 1 });\n    }\n\n    killers.sort((a, b) => b.score - a.score);\n    this.killerMoves.set(depth, killers);\n  }\n\n  // Recherche de quiescence pour améliorer l'évaluation des positions\n  private quiescenceSearch(\n    board: Board,\n    alpha: number,\n    beta: number,\n    depth: number = 0,\n  ): number {\n    const maxQuiescenceDepth = 10;\n\n    if (depth >= maxQuiescenceDepth) {\n      return evaluateBoard(board, this.color);\n    }\n\n    const standPat = evaluateBoard(board, this.color);\n    if (standPat >= beta) return beta;\n    if (alpha < standPat) alpha = standPat;\n\n    const moves = this.getAllValidMoves(board).filter((move) =>\n      board.isCapture(move.fromX, move.fromY, move.toX, move.toY),\n    );\n\n    for (const move of moves) {\n      const fromPiece = board.getPiece(move.fromX, move.fromY);\n      const toPiece = board.getPiece(move.toX, move.toY);\n\n      board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n      const kingSafe = !board.isKingInCheck(this.color);\n\n      if (kingSafe) {\n        const score = -this.quiescenceSearch(board, -beta, -alpha, depth + 1);\n        board.setPiece(move.fromX, move.fromY, fromPiece);\n        board.setPiece(move.toX, move.toY, toPiece);\n\n        if (score >= beta) return beta;\n        if (score > alpha) alpha = score;\n      } else {\n        board.setPiece(move.fromX, move.fromY, fromPiece);\n        board.setPiece(move.toX, move.toY, toPiece);\n      }\n    }\n\n    return alpha;\n  }\n\n  private getOpponentColor(): PieceColor {\n    return this.color === PieceColor.WHITE\n      ? PieceColor.BLACK\n      : PieceColor.WHITE;\n  }\n\n  private getAllValidMoves(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number }[] {\n    const validMoves = [];\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = board.getPiece(x, y);\n\n        if (piece && piece.color === this.color) {\n          const moves = board.getValidMoves(x, y);\n\n          for (const move of moves) {\n            if (board.isMoveValid(x, y, move.x, move.y)) {\n              const originalPiece = board.getPiece(move.x, move.y);\n              board.setPiece(move.x, move.y, piece);\n              board.setPiece(x, y, null);\n\n              const kingSafe = !board.isKingInCheck(this.color);\n\n              board.setPiece(x, y, piece);\n              board.setPiece(move.x, move.y, originalPiece);\n\n              if (kingSafe) {\n                validMoves.push({\n                  fromX: x,\n                  fromY: y,\n                  toX: move.x,\n                  toY: move.y,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  private sortMoves(\n    moves: { fromX: number; fromY: number; toX: number; toY: number }[],\n    board: Board,\n    depth: number,\n  ): { fromX: number; fromY: number; toX: number; toY: number }[] {\n    return moves.sort((a, b) => {\n      const killerMovesAtDepth = this.killerMoves.get(depth);\n\n      if (\n        killerMovesAtDepth &&\n        killerMovesAtDepth.some(\n          (move: {\n            move: { fromX: number; fromY: number; toX: number; toY: number };\n          }) => move.move.fromX === a.fromX && move.move.fromY === a.fromY,\n        )\n      ) {\n        return -1;\n      }\n\n      const pieceA = board.getPiece(a.toX, a.toY);\n      const pieceB = board.getPiece(b.toX, b.toY);\n\n      if (pieceA && !pieceB) return -1;\n      if (!pieceA && pieceB) return 1;\n\n      const centerControlA = centerControlBonus[`${a.toX},${a.toY}`] || 0;\n      const centerControlB = centerControlBonus[`${b.toX},${b.toY}`] || 0;\n\n      return centerControlB - centerControlA;\n    });\n  }\n\n  // Algorithme MCTS pour évaluer des positions complexes ou de fin de partie\n  private mcts(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    const iterations = 1000; // Nombre de simulations\n    const moveScores: Map<string, number> = new Map();\n    const validMoves = this.getAllValidMoves(board);\n\n    for (let i = 0; i < iterations; i++) {\n      const move = validMoves[Math.floor(Math.random() * validMoves.length)];\n\n      // Vérifie que toutes les propriétés de move sont bien définies\n      if (\n        !move ||\n        move.fromX === undefined ||\n        move.fromY === undefined ||\n        move.toX === undefined ||\n        move.toY === undefined\n      ) {\n        continue;\n      }\n\n      const simulationResult = this.simulateRandomGame(board, move);\n\n      const moveKey = `${move.fromX},${move.fromY},${move.toX},${move.toY}`;\n      moveScores.set(\n        moveKey,\n        (moveScores.get(moveKey) || 0) + simulationResult,\n      );\n    }\n\n    // Vérifie si moveScores est vide avant d'utiliser reduce\n    if (moveScores.size === 0) {\n      return null; // Aucun mouvement valide trouvé\n    }\n\n    // Sélectionne le mouvement avec la meilleure note moyenne\n    const bestMoveKey = Array.from(moveScores.entries()).reduce(\n      (best, current) => {\n        return current[1] > best[1] ? current : best;\n      },\n    )[0];\n\n    const [fromX, fromY, toX, toY] = bestMoveKey.split(',').map(Number);\n    return { fromX, fromY, toX, toY };\n  }\n\n  // Simule une partie aléatoire pour obtenir une estimation du résultat\n  private simulateRandomGame(\n    board: Board,\n    move: { fromX: number; fromY: number; toX: number; toY: number },\n  ): number {\n    // Vérifie que toutes les propriétés de move sont définies\n    if (\n      !move ||\n      move.fromX === undefined ||\n      move.fromY === undefined ||\n      move.toX === undefined ||\n      move.toY === undefined\n    ) {\n      console.error('Invalid move:', move);\n      return 0; // Retourne 0 ou une autre valeur par défaut si le mouvement est invalide\n    }\n\n    const tempBoard = board.clone();\n    tempBoard.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n    let currentPlayer = this.color;\n    let moves = this.getAllValidMoves(tempBoard);\n\n    while (!tempBoard.isGameOver() && moves.length > 0) {\n      const randomMove = moves[Math.floor(Math.random() * moves.length)];\n\n      // Vérifie que le mouvement aléatoire est valide\n      if (\n        !randomMove ||\n        randomMove.fromX === undefined ||\n        randomMove.fromY === undefined ||\n        randomMove.toX === undefined ||\n        randomMove.toY === undefined\n      ) {\n        console.error('Invalid random move:', randomMove);\n        break;\n      }\n\n      tempBoard.movePiece(\n        randomMove.fromX,\n        randomMove.fromY,\n        randomMove.toX,\n        randomMove.toY,\n      );\n      currentPlayer =\n        currentPlayer === PieceColor.WHITE\n          ? PieceColor.BLACK\n          : PieceColor.WHITE;\n      moves = this.getAllValidMoves(tempBoard);\n    }\n\n    // Retourne un score basé sur le résultat de la partie simulée\n    return tempBoard.getWinner() === this.color\n      ? 1\n      : tempBoard.getWinner() === null\n        ? 0.5\n        : 0;\n  }\n\n  // Détermine quand utiliser MCTS\n  private shouldUseMCTS(board: Board): boolean {\n    return board.getPieceCount() <= 10; // Par exemple, utilise MCTS pour la fin de partie\n  }\n\n  // Fonction de détection et d'application des tables de fin de partie\n  private useEndgameTablebase(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    if (board.getPieceCount() <= 4) {\n      // Condition pour appliquer les tables de fin de partie\n      return getEndgameMove(board, this.color); // Utilise une table de fin de partie externe\n    }\n    return null;\n  }\n\n  // Fonction pour identifier les mouvements critiques\n  private isCriticalMove(\n    piece: Piece,\n    move: {\n      fromX: number;\n      fromY: number;\n      toX: number;\n      toY: number;\n    },\n    board: Board,\n  ): boolean {\n    // Considère les captures et les coups qui mettent en échec comme critiques\n    const targetPiece = board.getPiece(move.toX, move.toY);\n    return (\n      (targetPiece && targetPiece.color !== piece.color) ||\n      board.isKingInCheck(piece.color)\n    );\n  }\n\n  // Méthode pour trouver le mouvement d'ouverture\n  private getOpeningMove(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    const boardHash = this.getBoardHash(board);\n\n    if (this.openingMoves[boardHash]) {\n      return this.openingMoves[boardHash][0]; // Récupère le premier mouvement d'ouverture correspondant\n    }\n\n    return null; // Aucun mouvement d'ouverture trouvé\n  }\n\n  // Génération d'un identifiant de position simplifié pour le dictionnaire d'ouverture\n  private getBoardHash(board: Board): string {\n    let hash = '';\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = board.getPiece(x, y);\n        if (piece) {\n          const pieceCode =\n            piece.color === PieceColor.WHITE\n              ? piece.type\n              : piece.type.toLowerCase();\n          hash += pieceCode + x + y + ' ';\n        }\n      }\n    }\n    return hash.trim();\n  }\n}\n","// src/pieces/pawn.ts\nimport { Piece, PieceColor, PieceType, BoardInterface } from '../piece';\n\nexport class Pawn extends Piece {\n  public hasMoved: boolean = false;\n  private _toX: number | null = null;\n  private _toY: number | null = null;\n  private _board: BoardInterface | null = null;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.PAWN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const playerColor = board.getPlayerColor();\n    const direction = this.color === PieceColor.WHITE ? 1 : -1;\n    const startRow = this.color === PieceColor.WHITE ? 1 : 6;\n    const distanceY = (toY - fromY) * direction;\n    const distanceX = Math.abs(toX - fromX);\n\n    const promotionRow = playerColor === PieceColor.WHITE ? 7 : 0;\n\n    if (distanceX === 0 && distanceY === 1 && !board.getPiece(toX, toY)) {\n      // Vérifie la rangée de promotion et déclenche la promotion uniquement à cette rangée\n      if (toY === promotionRow) {\n        return this.handlePromotion(toX, toY, board);\n      }\n      return true;\n    }\n\n    if (distanceX === 1 && distanceY === 1) {\n      if (board.getPiece(toX, toY) && this.canCapture(toX, toY, board)) {\n        if (toY === promotionRow) {\n          return this.handlePromotion(toX, toY, board);\n        }\n        return true;\n      }\n\n      if (board.isEnPassantMove(fromX, fromY, toX, toY)) {\n        return true;\n      }\n    }\n\n    if (\n      distanceX === 0 &&\n      distanceY === 2 &&\n      fromY === startRow &&\n      !board.getPiece(toX, toY) &&\n      !board.getPiece(fromX, fromY + direction)\n    ) {\n      board.updateEnPassantTarget(fromX, fromY, toX, toY, this);\n      return true;\n    }\n\n    return false;\n  }\n\n  handlePromotion(toX: number, toY: number, board: BoardInterface): boolean {\n    this._toX = toX;\n    this._toY = toY;\n    this._board = board;\n    return true;\n  }\n}\n","// ai.worker.ts\nimport { Board } from './board';\nimport { AI } from './ai';\nimport { PieceColor, PieceType } from './piece';\nimport { Pawn } from './pieces/pawn';\n\nlet ai: AI;\n\nself.onmessage = async (event) => {\n  const { boardData, aiColor } = event.data;\n\n  ai = new AI(aiColor);\n\n  const board = await Board.fromData(boardData);\n  const bestMove = ai.makeMove(board);\n\n  // Définit explicitement le type de captureData\n  let captureData: {\n    capturedWhite: PieceType[];\n    capturedBlack: PieceType[];\n  } | null = null;\n\n  // Vérifie si une capture est effectuée\n  if (\n    bestMove &&\n    board.isCapture(bestMove.fromX, bestMove.fromY, bestMove.toX, bestMove.toY)\n  ) {\n    const targetPiece = board.getPiece(bestMove.toX, bestMove.toY);\n    if (targetPiece) {\n      captureData = {\n        capturedWhite: [],\n        capturedBlack: [],\n      };\n      if (targetPiece.color === PieceColor.WHITE) {\n        captureData.capturedWhite.push(targetPiece.type);\n      } else {\n        captureData.capturedBlack.push(targetPiece.type);\n      }\n    }\n  }\n\n  // Vérifie si une promotion est nécessaire pour un pion\n  let promotionRequired = false;\n  if (\n    bestMove &&\n    board.getPiece(bestMove.fromX, bestMove.fromY)?.type === PieceType.PAWN\n  ) {\n    const piece = board.getPiece(bestMove.fromX, bestMove.fromY);\n    if (piece instanceof Pawn) {\n      const promotionRow = aiColor === PieceColor.WHITE ? 7 : 0;\n      // Vérifie si la pièce est un pion\n      if (bestMove.toY === promotionRow) {\n        promotionRequired = piece.handlePromotion(\n          bestMove.toX,\n          bestMove.toY,\n          board,\n        );\n      }\n    }\n  }\n\n  self.postMessage({ bestMove, captureData, promotionRequired });\n};\n"],"names":["createPiece","type","color","PieceType","Pawn","Rook","Knight","Bishop","Queen","King","PieceColor","Piece","fromX","fromY","toX","toY","board","dx","dy","x","y","piece","targetPiece","data","capturedWhite","capturedBlack","getPieceSymbol","updateCapturedPieces","pieceSymbol","updateCapturedPiecesDOM","capturedWhiteElement","capturedBlackElement","Board","validMoves","opponentColor","king","direction","rookX","rook","kingX","kingY","capturedPawnY","capturedPawn","captureData","pieceType","kingPosition","moves","move","originalPiece","kingSafe","isKingSafe","pieces","fromRow","fromCol","toRow","toCol","destinationPiece","row","pieceData","kingPositions","nx","ny","clonedBoard","pieceValues","pieceSquareTables","centerControlBonus","evaluateBoard","score","pieceScore","pieceTable","adjustedY","positionKey","evaluatePawnStructure","isPassedPawn","isKingExposed","checkDoubledPawns","checkIsolatedPawns","i","leftColumn","rightColumn","newX","newY","adjPiece","pieceInFront","col","adjacentPiece","getEndgameMove","hasPiece","getOpponentColor","getKingRookVsKingMove","getKingBishopKnightVsKingMove","getKingTwoBishopsVsKingMove","getKingPawnVsKingMove","opponentKingPos","findPiecePosition","rookPos","knightPos","bishopPos","bishops","findAllPiecesPositions","pawnPos","positions","openingBook","AI","maxTime","openingMove","endgameMove","bestMove","bestValue","maxDepth","depth","adjustedDepth","boardValue","alpha","beta","isMaximizing","boardKey","evaluation","maxEval","fromPiece","toPiece","newDepth","isCheck","isPawnPush","extendedDepth","minEval","killers","existingMove","k","a","b","standPat","killerMovesAtDepth","pieceA","pieceB","centerControlA","moveScores","simulationResult","moveKey","bestMoveKey","best","current","tempBoard","currentPlayer","randomMove","boardHash","hash","pieceCode","playerColor","startRow","distanceY","distanceX","promotionRow","ai","event","boardData","aiColor","promotionRequired"],"mappings":"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"}