async function g(c,t){switch(c){case r.PAWN:const{Pawn:i}=await Promise.resolve().then(function(){return it});return new i(t);case r.ROOK:const{Rook:e}=await import("./rook-DlCUXjDn.js");return new e(t);case r.KNIGHT:const{Knight:s}=await import("./knight-Cf_l6Qya.js");return new s(t);case r.BISHOP:const{Bishop:n}=await import("./bishop-Bx2X6lal.js");return new n(t);case r.QUEEN:const{Queen:o}=await import("./queen-b6BgB5GD.js");return new o(t);case r.KING:const{King:a}=await import("./king-CDIgTO-r.js");return new a(t);default:throw new Error(`Type de pièce inconnu : ${c}`)}}var f=(c=>(c.WHITE="white",c.BLACK="black",c))(f||{}),r=(c=>(c.PAWN="pawn",c.ROOK="rook",c.KNIGHT="knight",c.BISHOP="bishop",c.QUEEN="queen",c.KING="king",c))(r||{});class H{constructor(t,i){this.color=t,this.type=i}hasMoved=!1;isPathClear(t,i,e,s,n){const o=Math.sign(e-t),a=Math.sign(s-i);let l=t+o,u=i+a;for(;l!==e||u!==s;){if(n.getPiece(l,u)!==null)return!1;l+=o,u+=a}return!0}static isKing(t){return t.type==="king"}canCapture(t,i,e){const s=e.getPiece(t,i);return!s||s.color!==this.color}toData(){return{color:this.color,type:this.type}}static async fromData(t){return await g(t.type,t.color)}}let w=[],N=[];function B(c,t){switch(c){case r.PAWN:return t===f.WHITE?"♙":"♟";case r.ROOK:return t===f.WHITE?"♖":"♜";case r.KNIGHT:return t===f.WHITE?"♘":"♞";case r.BISHOP:return t===f.WHITE?"♗":"♝";case r.QUEEN:return t===f.WHITE?"♕":"♛";case r.KING:return t===f.WHITE?"♔":"♚";default:return""}}function x(c,t){const i=B(c,t);t===f.WHITE?w.push(i):N.push(i),O()}function O(){const c=document.getElementById("capturedWhite"),t=document.getElementById("capturedBlack");c&&(c.textContent=w.join(" ")),t&&(t.textContent=N.join(" "))}class K{grid;enPassantTarget=null;halfMoveCount=0;currentPlayer=f.WHITE;constructor(){this.grid=Array(8).fill(null).map(()=>Array(8).fill(null))}async init(){this.grid=await this.initializeBoard()}async initializeBoard(){const t=Array(8).fill(null).map(()=>Array(8).fill(null));return t[0]=[await g(r.ROOK,f.WHITE),await g(r.KNIGHT,f.WHITE),await g(r.BISHOP,f.WHITE),await g(r.QUEEN,f.WHITE),await g(r.KING,f.WHITE),await g(r.BISHOP,f.WHITE),await g(r.KNIGHT,f.WHITE),await g(r.ROOK,f.WHITE)],t[1]=await Promise.all(Array(8).fill(null).map(()=>g(r.PAWN,f.WHITE))),t[7]=[await g(r.ROOK,f.BLACK),await g(r.KNIGHT,f.BLACK),await g(r.BISHOP,f.BLACK),await g(r.QUEEN,f.BLACK),await g(r.KING,f.BLACK),await g(r.BISHOP,f.BLACK),await g(r.KNIGHT,f.BLACK),await g(r.ROOK,f.BLACK)],t[6]=await Promise.all(Array(8).fill(null).map(()=>g(r.PAWN,f.BLACK))),t}isWithinBounds(t,i){return t>=0&&t<8&&i>=0&&i<8}getPiece(t,i){return this.grid[i][t]}getValidMoves(t,i){let e=null;if(this.isWithinBounds(t,i)&&(e=this.getPiece(t,i)),!e)return[];const s=[];for(let n=0;n<8;n++)for(let o=0;o<8;o++)e.isValidMove(t,i,o,n,this)&&s.push({x:o,y:n});return s}captureEnPassantIfValid(t,i,e,s){if(this.isEnPassantMove(t,i,e,s)){const n=this.getPiece(t,i);if(!n)return;const o=s+(n.color===f.WHITE?-1:1);this.grid[o][e]&&(this.grid[o][e]=null)}}getKingInCheck(){return this.isKingInCheck(f.WHITE)?this.findKing(f.WHITE):this.isKingInCheck(f.BLACK)?this.findKing(f.BLACK):null}movePiece(t,i,e,s){if(!this.isWithinBounds(t,i)||!this.isWithinBounds(e,s)||["__proto__","constructor","prototype"].includes(i.toString())||["__proto__","constructor","prototype"].includes(s.toString()))return!1;const n=this.getPiece(t,i);if(n&&n.isValidMove(t,i,e,s,this)){const o=this.getPiece(e,s);if(o&&o.type===r.KING)return!1;if(n.type===r.KING&&Math.abs(e-t)===2)return this.isCastlingValid(n,t,i,e)?(this.handleCastling(e,i),n.hasMoved=!0,!0):!1;if(n?.type===r.PAWN&&this.isEnPassantMove(t,i,e,s)&&this.captureEnPassant(t,i,e,s),this.grid[s][e]=n,this.grid[i][t]=null,this.isKingInCheck(n.color))return this.grid[i][t]=n,this.grid[s][e]=o,!1;(n.type===r.KING||n.type===r.ROOK)&&(n.hasMoved=!0),this.updateEnPassantTarget(t,i,e,s,n),this.halfMoveCount=n.type===r.PAWN||o?0:this.halfMoveCount+1;const a=n.color===f.WHITE?f.BLACK:f.WHITE;return this.isCheckmate(a),!0}return!1}isCastlingValid(t,i,e,s){const n=s>i?1:-1,o=s>i?7:0,a=this.getPiece(o,e);if(a?.type!==r.ROOK||a.hasMoved||t.hasMoved)return!1;for(let l=i+n;l!==s+n;l+=n)if(this.getPiece(l,e)||this.isSquareUnderAttack(l,e,t.color))return!1;return!0}handleCastling(t,i){if(t===6){const e=this.getPiece(7,i),s=this.getPiece(4,i);e?.type===r.ROOK&&!e.hasMoved&&s?.type===r.KING&&!s.hasMoved&&(this.setPiece(5,i,e),this.setPiece(7,i,null),this.setPiece(6,i,s),this.setPiece(4,i,null),s.hasMoved=!0,e.hasMoved=!0)}else if(t===2){const e=this.getPiece(0,i),s=this.getPiece(4,i);e?.type===r.ROOK&&!e.hasMoved&&s?.type===r.KING&&!s.hasMoved&&(this.setPiece(3,i,e),this.setPiece(0,i,null),this.setPiece(2,i,s),this.setPiece(4,i,null),s.hasMoved=!0,e.hasMoved=!0)}}updateEnPassantTarget(t,i,e,s,n){n?.type===r.PAWN&&Math.abs(s-i)===2&&t===e?this.enPassantTarget={x:e,y:(i+s)/2}:this.enPassantTarget=null}captureEnPassant(t,i,e,s){const n=this.getPiece(t,i);if(this.isEnPassantMove(t,i,e,s)&&n?.type===r.PAWN){const o=n.color===f.WHITE?-1:1,a=s+o,l=this.getPiece(e,a);if(l&&l.type===r.PAWN){this.grid[a][e]=null;const u={capturedWhite:[],capturedBlack:[]};return l.color===f.WHITE?u.capturedWhite.push(l.type):u.capturedBlack.push(l.type),x(l.type,l.color),u}}return null}isEnPassantMove(t,i,e,s){return this.enPassantTarget?this.getPiece(t,i)?.type===r.PAWN&&e===this.enPassantTarget.x&&s===this.enPassantTarget.y&&Math.abs(t-e)===1&&Math.abs(i-s)===1:!1}async promotePawn(t,i,e){const s=this.getPiece(t,i)?.color;if(s)switch(e){case"queen":this.grid[i][t]=await g(r.QUEEN,s);break;case"rook":this.grid[i][t]=await g(r.ROOK,s);break;case"bishop":this.grid[i][t]=await g(r.BISHOP,s);break;case"knight":this.grid[i][t]=await g(r.KNIGHT,s);break}}isKingInCheck(t){const i=this.findKing(t);if(!i)return!1;for(let e=0;e<8;e++)for(let s=0;s<8;s++){const n=this.getPiece(s,e);if(n&&n.color!==t&&n.isValidMove(s,e,i.x,i.y,this))return!0}return!1}isCheckmate(t){if(!this.isKingInCheck(t))return!1;for(let e=0;e<8;e++)for(let s=0;s<8;s++){const n=this.getPiece(s,e);if(n&&n.color===t){const o=this.getValidMoves(s,e);for(const a of o){const l=this.getPiece(a.x,a.y);this.grid[a.y][a.x]=n,this.grid[e][s]=null;const u=!this.isKingInCheck(t);if(this.grid[e][s]=n,this.grid[a.y][a.x]=l,u)return!1}}}return!0}isStalemate(t){if(this.isKingInCheck(t))return!1;for(let i=0;i<8;i++)for(let e=0;e<8;e++){const s=this.getPiece(e,i);if(s&&s.color===t){for(let n=0;n<8;n++)for(let o=0;o<8;o++)if(s.isValidMove(e,i,o,n,this)){const a=this.getPiece(o,n);this.grid[n][o]=s,this.grid[i][e]=null;const l=!this.isKingInCheck(t);if(this.grid[i][e]=s,this.grid[n][o]=a,l)return!1}}}return!0}findKing(t){for(let i=0;i<8;i++)for(let e=0;e<8;e++){const s=this.getPiece(e,i);if(s&&s?.type===r.KING&&s.color===t)return{x:e,y:i}}return null}isKing(t,i){return this.getPiece(t,i)?.type===r.KING}isSquareUnderAttack(t,i,e){for(let s=0;s<8;s++)for(let n=0;n<8;n++){const o=this.getPiece(n,s);if(o&&o.color!==e&&o.isValidMove(n,s,t,i,this))return!0}return!1}isInsufficientMaterial(){const t=this.grid.flat().filter(i=>i!==null);return t.length<=2?!0:t.length===3&&t.some(i=>i?.type===r.BISHOP||i?.type===r.KNIGHT)}isFiftyMoveRule(){return this.halfMoveCount>=50}setPiece(t,i,e){this.grid[i][t]=e}isMoveValid(t,i,e,s){const n=this.getPiece(t,i);if(!n||e<0||e>=8||s<0||s>=8||!n.isValidMove(t,i,e,s,this))return!1;const o=this.getPiece(e,s);return!(o&&o.color===n.color)}isCapture(t,i,e,s){const n=this.isWithinBounds(t,i)?this.getPiece(t,i):null,o=this.isWithinBounds(e,s)?this.getPiece(e,s):null;return n!==null&&o!==null&&n.color!==o.color}static async fromData(t){const i=new K;return await i.init(),i.grid=await Promise.all(t.grid.map(async e=>Promise.all(e.map(async s=>s?await H.fromData(s):null)))),i}toData(){return{grid:this.grid.map(t=>t.map(i=>i?i.toData():null))}}isAdjacentToAnotherKing(t,i,e){const s=[{dx:-1,dy:-1},{dx:-1,dy:0},{dx:-1,dy:1},{dx:0,dy:-1},{dx:0,dy:1},{dx:1,dy:-1},{dx:1,dy:0},{dx:1,dy:1}];for(const{dx:n,dy:o}of s){const a=t+n,l=i+o,u=this.isWithinBounds(a,l)?this.getPiece(a,l):null;if(u?.type===r.KING&&u.color!==e)return!0}return!1}clone(){const t=new K;return t.grid=this.grid.map(i=>i.map(e=>e?Object.create(Object.getPrototypeOf(e),Object.getOwnPropertyDescriptors(e)):null)),t.enPassantTarget=this.enPassantTarget?{...this.enPassantTarget}:null,t.halfMoveCount=this.halfMoveCount,t}getPieceCount(){return this.grid.flat().filter(t=>t!==null).length}isGameOver(){return this.isCheckmate(f.WHITE)||this.isCheckmate(f.BLACK)||this.isStalemate(f.WHITE)||this.isStalemate(f.BLACK)||this.isInsufficientMaterial()?!0:this.isFiftyMoveRule()}getWinner(){return this.isCheckmate(f.BLACK)?f.WHITE:this.isCheckmate(f.WHITE)?f.BLACK:(this.isStalemate(f.WHITE)||this.isStalemate(f.BLACK)||this.isInsufficientMaterial()||this.isFiftyMoveRule(),null)}getPieces(){return this.grid.flat().filter(t=>t!==null)}setPlayerColor(t){this.currentPlayer=t}getPlayerColor(){return this.currentPlayer}}const S={[r.PAWN]:1,[r.KNIGHT]:3,[r.BISHOP]:3.25,[r.ROOK]:5,[r.QUEEN]:9,[r.KING]:0},G={[r.PAWN]:[[0,0,0,0,0,0,0,0],[.5,.5,.5,.5,.5,.5,.5,.5],[.1,.1,.2,.3,.3,.2,.1,.1],[.05,.05,.1,.25,.25,.1,.05,.05],[0,0,0,.2,.2,0,0,0],[.05,-.05,-.1,0,0,-.1,-.05,.05],[.05,.1,.1,-.2,-.2,.1,.1,.05],[0,0,0,0,0,0,0,0]],[r.KNIGHT]:[[-.5,-.4,-.3,-.3,-.3,-.3,-.4,-.5],[-.4,-.2,0,0,0,0,-.2,-.4],[-.3,0,.1,.15,.15,.1,0,-.3],[-.3,.05,.15,.2,.2,.15,.05,-.3],[-.3,0,.15,.2,.2,.15,0,-.3],[-.3,.05,.1,.15,.15,.1,.05,-.3],[-.4,-.2,0,.05,.05,0,-.2,-.4],[-.5,-.4,-.3,-.3,-.3,-.3,-.4,-.5]],[r.BISHOP]:[[-.2,-.1,-.1,-.1,-.1,-.1,-.1,-.2],[-.1,0,0,0,0,0,0,-.1],[-.1,0,.05,.1,.1,.05,0,-.1],[-.1,.05,.05,.1,.1,.05,.05,-.1],[-.1,0,.1,.1,.1,.1,0,-.1],[-.1,.1,.1,.1,.1,.1,.1,-.1],[-.1,.05,0,0,0,0,.05,-.1],[-.2,-.1,-.1,-.1,-.1,-.1,-.1,-.2]],[r.ROOK]:[[0,0,0,0,0,0,0,0],[.05,.1,.1,.1,.1,.1,.1,.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[0,0,0,.05,.05,0,0,0]],[r.QUEEN]:[[-.2,-.1,-.1,-.05,-.05,-.1,-.1,-.2],[-.1,0,0,0,0,0,0,-.1],[-.1,0,.05,.05,.05,.05,0,-.1],[-.05,0,.05,.05,.05,.05,0,-.05],[0,0,.05,.05,.05,.05,0,-.05],[-.1,.05,.05,.05,.05,.05,0,-.1],[-.1,0,.05,0,0,0,0,-.1],[-.2,-.1,-.1,-.05,-.05,-.1,-.1,-.2]],[r.KING]:[[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.2,-.3,-.3,-.4,-.4,-.3,-.3,-.2],[-.1,-.2,-.2,-.2,-.2,-.2,-.2,-.1],[.2,.2,0,0,0,0,.2,.2],[.2,.3,0,0,0,0,.3,.2]]},X={"3,3":.5,"3,4":.5,"4,3":.5,"4,4":.5,"2,3":.25,"2,4":.25,"3,2":.25,"4,2":.25,"4,5":.25,"3,5":.25,"5,3":.25,"5,4":.25};function V(c,t){const i=c.findKing(t);return i&&c.isSquareUnderAttack(i.x,i.y,t)?-.5:0}function R(c,t,i,e){const s=G[c];return s?e?s[7-i][7-t]:s[i][t]:0}function T(c,t,i=!1){let e=0;for(let s=0;s<8;s++)for(let n=0;n<8;n++){const o=c.getPiece(n,s);if(!o)continue;let a=S[o.type];a+=R(o.type,n,s,i);const l=`${n},${s}`;X[l]&&(a+=X[l]),o.type===r.PAWN&&(a+=D(c,n,s,o.color)),o.type===r.KING&&$(c,n,s,o.color)&&(a-=.5),e+=o.color===t?a:-a}return parseFloat(e.toFixed(2))}function D(c,t,i,e){let s=0;return s-=L(c,t,i,e)*1.5,s-=_(c,t,i,e)*1.5,j(c,t,i,e)&&(s+=1),s}function L(c,t,i,e){for(let s=0;s<8;s++)if(s!==i&&c.getPiece(t,s)?.type===r.PAWN&&c.getPiece(t,s)?.color===e)return .5;return 0}function _(c,t,i,e){const s=t-1>=0?c.getPiece(t-1,i):null,n=t+1<8?c.getPiece(t+1,i):null;return(!s||s.type!==r.PAWN||s.color!==e)&&(!n||n.type!==r.PAWN||n.color!==e)?1.5:0}function $(c,t,i,e){const s=c.getPiece(t,i);return s&&s.type===r.KING?[{dx:-1,dy:0},{dx:1,dy:0},{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:-1},{dx:1,dy:1},{dx:-1,dy:1},{dx:1,dy:-1}].some(({dx:o,dy:a})=>{const l=t+o,u=i+a;if(!c.isWithinBounds(l,u))return!1;const h=c.getPiece(l,u);return!h||h.color!==e||h.type!==r.PAWN}):!1}function j(c,t,i,e){const s=e===f.WHITE?-1:1;for(let o=i+s;o>=0&&o<8;o+=s){const a=c.getPiece(t,o);if(a&&a.type===r.PAWN&&a.color!==e)return!1}return[t-1,t+1].every(o=>{if(o<0||o>=8)return!0;for(let a=0;a<8;a++){const l=c.getPiece(o,a);if(l&&l.type===r.PAWN&&l.color===e)return!1}return!0})}function q(c,t){return t?{fromX:7-c.fromX,fromY:7-c.fromY,toX:7-c.toX,toY:7-c.toY}:c}function U(c,t,i=!1){const e=c.getPieces();let s=null;return e.length===3&&p(e,r.KING,t)&&p(e,r.ROOK,t)&&p(e,r.KING,d(t))?s=Q(c,t):e.length===4&&p(e,r.KING,t)&&p(e,r.BISHOP,t)&&p(e,r.KNIGHT,t)&&p(e,r.KING,d(t))?s=F(c,t):e.length===4&&p(e,r.KING,t)&&p(e,r.BISHOP,t)&&e.filter(n=>n.type===r.BISHOP&&n.color===t).length===2&&p(e,r.KING,d(t))?s=z(c,t):e.length===3&&p(e,r.KING,t)&&p(e,r.PAWN,t)&&p(e,r.KING,d(t))&&(s=J(c,t)),s?q(s,t===f.BLACK||i):null}function p(c,t,i){return c.some(e=>e.type===t&&e.color===i)}function d(c){return c===f.WHITE?f.BLACK:f.WHITE}function Q(c,t){const i=v(c,r.KING,d(t)),e=v(c,r.ROOK,t);return!i||!e?null:i.x<4?{fromX:e.x,fromY:e.y,toX:i.x+1,toY:i.y}:{fromX:e.x,fromY:e.y,toX:i.x-1,toY:i.y}}function F(c,t){const i=v(c,r.KING,d(t)),e=v(c,r.KNIGHT,t),s=v(c,r.BISHOP,t);return!i||!e||!s?null:i.x<4?{fromX:e.x,fromY:e.y,toX:i.x+1,toY:i.y}:{fromX:s.x,fromY:s.y,toX:i.x-1,toY:i.y}}function z(c,t){const i=v(c,r.KING,d(t)),e=Z(c,r.BISHOP,t);return!i||e.length<2?null:{fromX:e[0].x,fromY:e[0].y,toX:i.x,toY:i.y>4?i.y-1:i.y+1}}function J(c,t){const i=v(c,r.KING,d(t)),e=v(c,r.PAWN,t);if(!i||!e)return null;const s=t===f.WHITE?1:-1;return{fromX:e.x,fromY:e.y,toX:e.x,toY:e.y+s}}function v(c,t,i){for(let e=0;e<8;e++)for(let s=0;s<8;s++){const n=c.getPiece(s,e);if(n&&n.type===t&&n.color===i)return{x:s,y:e}}return null}function Z(c,t,i){const e=[];for(let s=0;s<8;s++)for(let n=0;n<8;n++){const o=c.getPiece(n,s);o&&o.type===t&&o.color===i&&e.push({x:n,y:s})}return e}const W={"e2e4 e7e5 g1f3 b8c6 f1b5":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:3},{fromX:6,fromY:7,toX:5,toY:5},{fromX:1,fromY:0,toX:2,toY:2},{fromX:5,fromY:7,toX:1,toY:5}],"e2e4 c7c5":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:2,fromY:1,toX:2,toY:3}],"e2e4 c7c5 g1f3 d7d6":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:2,fromY:1,toX:2,toY:3},{fromX:6,fromY:7,toX:5,toY:5},{fromX:3,fromY:1,toX:3,toY:2}],"d2d4 d7d5 c2c4":[{fromX:3,fromY:6,toX:3,toY:4},{fromX:3,fromY:1,toX:3,toY:3},{fromX:2,fromY:6,toX:2,toY:4}],"e2e4 c7c6":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:2,fromY:1,toX:2,toY:2}],"e2e4 c7c6 d2d4 d7d5":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:2,fromY:1,toX:2,toY:2},{fromX:3,fromY:6,toX:3,toY:4},{fromX:3,fromY:1,toX:3,toY:3}],"e2e4 e7e6":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:2}],"e2e4 e7e6 d2d4 d7d5":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:2},{fromX:3,fromY:6,toX:3,toY:4},{fromX:3,fromY:1,toX:3,toY:3}],"e2e4 e7e5 g1f3 b8c6 f1c4":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:3},{fromX:6,fromY:7,toX:5,toY:5},{fromX:1,fromY:0,toX:2,toY:2},{fromX:5,fromY:7,toX:2,toY:4}],"e2e4 g8f6":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:6,fromY:0,toX:5,toY:2}],"e2e4 d7d6":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:3,fromY:1,toX:3,toY:2}],"e2e4 e7e5 g1f3 b8c6 d2d4":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:3},{fromX:6,fromY:7,toX:5,toY:5},{fromX:1,fromY:0,toX:2,toY:2},{fromX:3,fromY:6,toX:3,toY:4}],"e2e4 e7e5 f2f4":[{fromX:4,fromY:6,toX:4,toY:4},{fromX:4,fromY:1,toX:4,toY:3},{fromX:5,fromY:6,toX:5,toY:4}],c2c4:[{fromX:2,fromY:6,toX:2,toY:4}],"g1f3 d7d5":[{fromX:6,fromY:7,toX:5,toY:5},{fromX:3,fromY:1,toX:3,toY:3}]};function b(c,t){return t?{fromX:7-c.fromX,fromY:7-c.fromY,toX:7-c.toX,toY:7-c.toY}:c}function tt(c,t){const i=c.join(" ");return t[i]?.[c.length]??null}class et{constructor(t,i=5e3){this.color=t,this.transpositionTable=new Map,this.maxTime=i,this.killerMoves=new Map,this.startTime=0}openingMoves=W;transpositionTable;maxTime;startTime;killerMoves;moveHistory=[];makeMove(t){const i=this.getOpeningMove(t);if(i)return this.moveHistory.push(i),i;const e=this.getPastMoves(),s=this.chooseMove(e);if(s)return this.moveHistory.push(s),s;const n=this.useEndgameTablebase(t);if(n)return this.moveHistory.push(n),n;if(this.shouldUseMCTS(t)){const u=this.mcts(t);return u&&this.moveHistory.push(u),u}let o=null,a=-1/0;const l=10;this.startTime=Date.now();for(let u=1;u<=l;u++){let h=this.getAllValidMoves(t);h=this.sortMoves(h,t,u);for(const m of h){const P=t.getPiece(m.fromX,m.fromY);if(!P)continue;const y=t.getPiece(m.toX,m.toY);t.movePiece(m.fromX,m.fromY,m.toX,m.toY);const Y=t.isKingInCheck(this.color)||this.isCriticalMove(P,m,t)?u+1:u,I=this.minimax(t,Y-1,-1/0,1/0,!1);if(t.setPiece(m.fromX,m.fromY,P),t.setPiece(m.toX,m.toY,y),I>a&&(a=I,o=m),Date.now()-this.startTime>this.maxTime)break}if(Date.now()-this.startTime>this.maxTime)break}return o&&this.moveHistory.push(o),o}getPastMoves(){return this.moveHistory.map(t=>`${t.fromX}${t.fromY}${t.toX}${t.toY}`)}minimax(t,i,e,s,n){const o=t.toString();if(Date.now()-this.startTime>this.maxTime)return this.evaluatePositionWithKingSafety(t,this.color);if(this.transpositionTable.has(o))return this.transpositionTable.get(o);if(i>1&&!t.isKingInCheck(this.color)&&-this.minimax(t,i-2,-s,-e,!n)>=s)return s;if(i===0||t.isCheckmate(this.color)||t.isCheckmate(this.getOpponentColor())||Date.now()-this.startTime>this.maxTime){const a=this.quiescenceSearch(t,e,s);return this.transpositionTable.set(o,a),a}if(n){let a=-1/0,l=this.getAllValidMoves(t);l=this.sortMoves(l,t,i);for(const u of l){const h=t.getPiece(u.fromX,u.fromY),m=t.getPiece(u.toX,u.toY);t.movePiece(u.fromX,u.fromY,u.toX,u.toY);const P=this.minimax(t,i-1,e,s,!1);if(t.setPiece(u.fromX,u.fromY,h),t.setPiece(u.toX,u.toY,m),a=Math.max(a,P),e=Math.max(e,P),s<=e){this.addKillerMove(i,u);break}}return this.transpositionTable.set(o,a),a}else{let a=1/0,l=this.getAllValidMoves(t);l=this.sortMoves(l,t,i);for(let u=0;u<l.length;u++){const h=l[u],m=t.getPiece(h.fromX,h.fromY),P=t.getPiece(h.toX,h.toY),M=u>3&&i>2?i-1:i,Y=t.isKingInCheck(this.getOpponentColor()),I=m&&m.type===r.PAWN&&(h.toY===0||h.toY===7),k=Y||I?M+1:M;t.movePiece(h.fromX,h.fromY,h.toX,h.toY);const C=this.minimax(t,k-1,e,s,!0);if(t.setPiece(h.fromX,h.fromY,m),t.setPiece(h.toX,h.toY,P),a=Math.min(a,C),s=Math.min(s,C),s<=e){this.addKillerMove(i,h);break}}return this.transpositionTable.set(o,a),a}}chooseMove(t){const i=tt(t,W);return i||null}addKillerMove(t,i){const e=this.killerMoves.get(t)??[],s=e.find(n=>n.move.fromX===i.fromX&&n.move.fromY===i.fromY);s?s.score+=1:e.push({move:i,score:1}),this.killerMoves.set(t,e.sort((n,o)=>o.score-n.score).slice(0,2))}quiescenceSearch(t,i,e,s=0){if(s>=5)return T(t,this.color);const o=T(t,this.color);if(o>=e)return e;i<o&&(i=o);const a=this.getAllValidMoves(t).filter(l=>t.isCapture(l.fromX,l.fromY,l.toX,l.toY));for(const l of a){const u=t.getPiece(l.fromX,l.fromY),h=t.getPiece(l.toX,l.toY);t.movePiece(l.fromX,l.fromY,l.toX,l.toY);const m=!t.isKingInCheck(this.color);let P=o;if(m&&(P=-this.quiescenceSearch(t,-e,-i,s+1)),t.setPiece(l.fromX,l.fromY,u),t.setPiece(l.toX,l.toY,h),P>=e)return e;P>i&&(i=P)}return i}getOpponentColor(){return this.color===f.WHITE?f.BLACK:f.WHITE}getAllValidMoves(t){const i=[];for(let e=0;e<8;e++)for(let s=0;s<8;s++){const n=t.getPiece(s,e);if(n&&n.color===this.color){const o=t.getValidMoves(s,e);for(const a of o)if(t.isMoveValid(s,e,a.x,a.y)){const l=t.getPiece(a.x,a.y);t.setPiece(a.x,a.y,n),t.setPiece(s,e,null);const u=!t.isKingInCheck(this.color);t.setPiece(s,e,n),t.setPiece(a.x,a.y,l),u&&i.push({fromX:s,fromY:e,toX:a.x,toY:a.y})}}}return i}sortMoves(t,i,e){return t.sort((s,n)=>{const o=this.killerMoves.get(e);if(o&&o.some(m=>m.move.fromX===s.fromX&&m.move.fromY===s.fromY))return-1;const a=i.getPiece(s.toX,s.toY),l=i.getPiece(n.toX,n.toY);if(a&&!l)return-1;if(!a&&l)return 1;const u=X[`${s.toX},${s.toY}`]||0;return(X[`${n.toX},${n.toY}`]||0)-u})}mcts(t){const e=new Map,s=this.getAllValidMoves(t).filter(h=>h.fromX!==void 0&&h.fromY!==void 0&&h.toX!==void 0&&h.toY!==void 0);if(s.length===0)return null;for(let h=0;h<1e3;h++){const m=s[Math.floor(Math.random()*s.length)];if(!m||m.fromX===void 0||m.fromY===void 0||m.toX===void 0||m.toY===void 0)continue;const P=this.simulateRandomGame(t,m),y=`${m.fromX},${m.fromY},${m.toX},${m.toY}`;if(e.set(y,(e.get(y)??0)+P),Date.now()-this.startTime>this.maxTime)break}const n=Array.from(e.entries()).reduce((h,m)=>m[1]>h[1]?m:h)[0],[o,a,l,u]=n.split(",").map(Number);return{fromX:o,fromY:a,toX:l,toY:u}}evaluatePositionWithKingSafety(t,i){let e=T(t,i);const s=V(t,i);return e+=s,e}simulateRandomGame(t,i){if(!i||i.fromX===void 0||i.fromY===void 0||i.toX===void 0||i.toY===void 0)return console.error("Invalid move:",i),0;const e=t.clone();e.movePiece(i.fromX,i.fromY,i.toX,i.toY);let s=this.color,n=this.getAllValidMoves(e);for(;!e.isGameOver()&&n.length>0;){const o=n[Math.floor(Math.random()*n.length)];if(!o||o.fromX===void 0||o.fromY===void 0||o.toX===void 0||o.toY===void 0){console.error("Invalid random move:",o);break}e.movePiece(o.fromX,o.fromY,o.toX,o.toY),s=s===f.WHITE?f.BLACK:f.WHITE,n=this.getAllValidMoves(e)}return e.getWinner()===this.color?1:e.getWinner()===null?.5:0}shouldUseMCTS(t){return t.getPieceCount()<=10}useEndgameTablebase(t){return t.getPieceCount()<=4?U(t,this.color):null}isCriticalMove(t,i,e){const s=e.getPiece(i.toX,i.toY);return s&&s.color!==t.color&&s.type!==r.PAWN}getOpeningMove(t){const i=this.getBoardHash(t);if(this.openingMoves[i]){const e=this.openingMoves[i][0];return b(e,this.color===f.BLACK)}return null}getBoardHash(t){let i="";for(let e=0;e<8;e++)for(let s=0;s<8;s++){const n=t.getPiece(s,e);if(n){const o=n.color===f.WHITE?n.type:n.type.toLowerCase();i+=o+s+e+" "}}return i.trim()}}class A extends H{hasMoved=!1;_toX=null;_toY=null;_board=null;constructor(t){super(t,r.PAWN)}isValidMove(t,i,e,s,n){if(e<0||e>=8||s<0||s>=8)return!1;const o=n.getPlayerColor(),a=this.color===f.WHITE?1:-1,l=this.color===f.WHITE?1:6,u=(s-i)*a,h=Math.abs(e-t),m=o===f.WHITE?7:0;if(h===0&&u===1&&!n.getPiece(e,s))return s===m?this.handlePromotion(e,s,n):!0;if(h===1&&u===1){if(n.getPiece(e,s)&&this.canCapture(e,s,n))return s===m?this.handlePromotion(e,s,n):!0;if(n.isEnPassantMove(t,i,e,s))return n.captureEnPassantIfValid(t,i,e,s),!0}return h===0&&u===2&&i===l&&!n.getPiece(e,s)&&!n.getPiece(t,i+a)?(n.updateEnPassantTarget(t,i,e,s,this),this.hasMoved=!0,!0):!1}handlePromotion(t,i,e){return this._toX=t,this._toY=i,this._board=e,!0}}var it=Object.freeze({__proto__:null,Pawn:A});let E;self.onmessage=async c=>{const{boardData:t,aiColor:i}=c.data;E=new et(i);const e=await K.fromData(t),s=E.makeMove(e);let n=null;if(s&&e.isCapture(s.fromX,s.fromY,s.toX,s.toY)){const a=e.getPiece(s.toX,s.toY);a&&(n={capturedWhite:[],capturedBlack:[]},a.color===f.WHITE?n.capturedWhite.push(a.type):n.capturedBlack.push(a.type))}let o=!1;if(s&&e.getPiece(s.fromX,s.fromY)?.type===r.PAWN){const a=e.getPiece(s.fromX,s.fromY);if(a instanceof A){const l=i===f.WHITE?7:0;s.toY===l&&(o=a.handlePromotion(s.toX,s.toY,e))}}self.postMessage({bestMove:s,captureData:n,promotionRequired:o})};export{H as P,r as a,g as c};
//# sourceMappingURL=ai.worker-CXU6DqCI.js.map
