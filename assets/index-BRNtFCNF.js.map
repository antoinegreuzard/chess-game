{"version":3,"mappings":"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","names":["createPiece","type","color","PieceType","Pawn","__vitePreload","pawn","Rook","rook","Knight","knight","Bishop","bishop","Queen","queen","King","king","PieceColor","Piece","fromX","fromY","toX","toY","board","dx","dy","x","y","targetPiece","data","direction","rookX","startRow","distanceY","distanceX","promotionDialog","pieceType","capturedWhite","capturedBlack","showMessage","message","gameMessageElement","getPieceSymbol","piece","updateCapturedPieces","pieceSymbol","updateCapturedPiecesDOM","capturedWhiteElement","capturedBlackElement","Board","validMoves","opponentColor","kingX","kingY","capturedPawnY","capturedPawn","captureData","kingPosition","moves","move","originalPiece","kingSafe","isKingSafe","pieces","fromRow","fromCol","toRow","toCol","destinationPiece","row","pieceData","kingPositions","nx","ny","Game","event","bestMove","boardData","CanvasRenderer","canvasId","moveHandler","currentFrame","startX","startY","deltaX","deltaY","animate","kingInCheck","tileColor","pieceText","rect","mouseX","mouseY","moveSuccessful","Timer","initialTime","onTimeUpdate","time","game","moveHistoryElement","currentTurnElement","timerElement","passTurnButton","replayButton","currentPlayer","gameState","hasMoved","moveHistory","isGameEnded","whiteTimer","timeLeft","updateTimerDisplay","blackTimer","endGame","renderer","handleMove","clearMessage","updateTurn","addMoveToHistory","moveText","listItem"],"ignoreList":[],"sources":["../../src/utils/pieceFactory.ts","../../src/piece.ts","../../src/pieces/rook.ts","../../src/pieces/knight.ts","../../src/pieces/bishop.ts","../../src/pieces/queen.ts","../../src/pieces/king.ts","../../src/pieces/pawn.ts","../../src/utils/utils.ts","../../src/board.ts","../../src/game.ts","../../src/canvas-renderer.ts","../../src/timer.ts","../../src/index.ts"],"sourcesContent":["import { PieceColor, PieceType } from '../piece';\n\nexport async function createPiece(type: PieceType, color: PieceColor) {\n  switch (type) {\n    case PieceType.PAWN:\n      const { Pawn } = await import('../pieces/pawn');\n      return new Pawn(color);\n    case PieceType.ROOK:\n      const { Rook } = await import('../pieces/rook');\n      return new Rook(color);\n    case PieceType.KNIGHT:\n      const { Knight } = await import('../pieces/knight');\n      return new Knight(color);\n    case PieceType.BISHOP:\n      const { Bishop } = await import('../pieces/bishop');\n      return new Bishop(color);\n    case PieceType.QUEEN:\n      const { Queen } = await import('../pieces/queen');\n      return new Queen(color);\n    case PieceType.KING:\n      const { King } = await import('../pieces/king');\n      return new King(color);\n    default:\n      throw new Error(`Type de pièce inconnu : ${type}`);\n  }\n}\n","// src/piece.ts\nimport { createPiece } from './utils/pieceFactory';\n\nexport enum PieceColor {\n  WHITE = 'white',\n  BLACK = 'black',\n}\n\nexport enum PieceType {\n  PAWN = 'pawn',\n  ROOK = 'rook',\n  KNIGHT = 'knight',\n  BISHOP = 'bishop',\n  QUEEN = 'queen',\n  KING = 'king',\n}\n\nexport interface BoardInterface {\n  getPiece(x: number, y: number): Piece | null;\n\n  updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void;\n\n  isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean;\n\n  promotePawn(x: number, y: number, pieceType: string): void;\n\n  isSquareUnderAttack(x: number, y: number, color: string): boolean;\n\n  isKing(x: number, y: number): boolean;\n\n  isAdjacentToAnotherKing(x: number, y: number, color: PieceColor): boolean;\n}\n\nexport abstract class Piece {\n  protected constructor(\n    public color: PieceColor,\n    public type: PieceType,\n  ) {}\n\n  abstract isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean;\n\n  public isPathClear(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const dx = Math.sign(toX - fromX);\n    const dy = Math.sign(toY - fromY);\n\n    let x = fromX + dx;\n    let y = fromY + dy;\n    while (x !== toX || y !== toY) {\n      if (board.getPiece(x, y) !== null) return false;\n      x += dx;\n      y += dy;\n    }\n    return true;\n  }\n\n  public canCapture(toX: number, toY: number, board: BoardInterface): boolean {\n    const targetPiece = board.getPiece(toX, toY);\n    return !targetPiece || targetPiece.color !== this.color;\n  }\n\n  // Sérialisation des données de la pièce\n  public toData(): any {\n    return {\n      color: this.color,\n      type: this.type,\n    };\n  }\n\n  static async fromData(data: any): Promise<Piece> {\n    return await createPiece(data.type, data.color);\n  }\n}\n","// src/pieces/rook.ts\n\nimport { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\n\nexport class Rook extends Piece {\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.ROOK);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const isStraightMove = fromX === toX || fromY === toY;\n    if (!isStraightMove) {\n      return false;\n    }\n\n    const isPathClear = this.isPathClear(fromX, fromY, toX, toY, board);\n    if (!isPathClear) {\n      return false;\n    }\n\n    return this.canCapture(toX, toY, board);\n  }\n\n  public toData(): any {\n    return {\n      ...super.toData(),\n      hasMoved: this.hasMoved,\n    };\n  }\n\n  // Ajuste le type de retour pour inclure Promise<Rook>\n  static async fromData(data: any): Promise<Rook> {\n    const rook = new Rook(data.color);\n    rook.hasMoved = data.hasMoved;\n    return rook;\n  }\n}\n","// src/pieces/knight.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\n\nexport class Knight extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.KNIGHT);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    // Le Cavalier se déplace en L : 2 cases dans une direction puis 1 case perpendiculairement\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n    return (\n      ((dx === 2 && dy === 1) || (dx === 1 && dy === 2)) &&\n      this.canCapture(toX, toY, board)\n    );\n  }\n}\n","// src/pieces/bishop.ts\nimport { Piece, PieceColor, PieceType, BoardInterface } from '../piece';\n\nexport class Bishop extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.BISHOP);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    // Le fou se déplace en diagonale\n    if (Math.abs(toX - fromX) === Math.abs(toY - fromY)) {\n      // Vérifie que la trajectoire est dégagée\n      if (this.isPathClear(fromX, fromY, toX, toY, board)) {\n        // Vérifie si la cible est vide ou contient une pièce ennemie\n        return this.canCapture(toX, toY, board);\n      }\n    }\n    return false;\n  }\n}\n","// src/pieces/queen.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\n\nexport class Queen extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.QUEEN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    // La reine peut se déplacer en ligne droite ou en diagonale\n    if (\n      fromX === toX || // Déplacement en colonne\n      fromY === toY || // Déplacement en ligne\n      Math.abs(toX - fromX) === Math.abs(toY - fromY) // Déplacement en diagonale\n    ) {\n      // Vérifie que la trajectoire est dégagée\n      if (this.isPathClear(fromX, fromY, toX, toY, board)) {\n        // Vérifie si la cible est vide ou contient une pièce ennemie\n        return this.canCapture(toX, toY, board);\n      }\n    }\n\n    return false;\n  }\n}\n","import { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\nimport { Rook } from './rook';\n\nexport class King extends Piece {\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.KING);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n\n    // Mouvement classique du roi\n    if (dx <= 1 && dy <= 1) {\n      return (\n        this.canCapture(toX, toY, board) &&\n        !board.isAdjacentToAnotherKing(toX, toY, this.color)\n      );\n    }\n\n    // Roque : si roi et tour n'ont pas bougé, la voie est libre et non attaquée\n    if (!this.hasMoved && dy === 0 && dx === 2) {\n      const direction = toX > fromX ? 1 : -1;\n      const rookX = toX > fromX ? 7 : 0;\n      const rook = board.getPiece(rookX, fromY);\n\n      if (rook && rook instanceof Rook && !rook.hasMoved) {\n        for (let x = fromX + direction; x !== toX; x += direction) {\n          if (\n            board.getPiece(x, fromY) ||\n            board.isSquareUnderAttack(x, fromY, this.color)\n          ) {\n            return false;\n          }\n        }\n        return (\n          !board.isSquareUnderAttack(toX, fromY, this.color) &&\n          !board.isAdjacentToAnotherKing(toX, toY, this.color)\n        );\n      }\n    }\n\n    return false;\n  }\n}\n","// src/pieces/pawn.ts\nimport { Piece, PieceColor, PieceType, BoardInterface } from '../piece';\n\nexport class Pawn extends Piece {\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.PAWN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const direction = this.color === PieceColor.WHITE ? 1 : -1;\n    const startRow = this.color === PieceColor.WHITE ? 1 : 6;\n    const distanceY = (toY - fromY) * direction;\n    const distanceX = Math.abs(toX - fromX);\n\n    if (distanceX === 0 && distanceY === 1 && !board.getPiece(toX, toY)) {\n      if (\n        ((this.color === PieceColor.WHITE && toY === 7) ||\n          (this.color === PieceColor.BLACK && toY === 0)) &&\n        board.getPiece(toX, toY)?.type === PieceType.PAWN\n      ) {\n        this.handlePromotion(toX, toY, board);\n      }\n      return true;\n    }\n\n    if (\n      distanceX === 0 &&\n      distanceY === 2 &&\n      fromY === startRow &&\n      !board.getPiece(toX, toY) &&\n      !board.getPiece(fromX, fromY + direction)\n    ) {\n      board.updateEnPassantTarget(fromX, fromY, toX, toY, this);\n      return true;\n    }\n\n    if (distanceX === 1 && distanceY === 1) {\n      if (board.getPiece(toX, toY) && this.canCapture(toX, toY, board)) {\n        if (\n          (this.color === PieceColor.WHITE && toY === 7) ||\n          (this.color === PieceColor.BLACK &&\n            toY === 0 &&\n            board.getPiece(toX, toY)?.type === PieceType.PAWN)\n        ) {\n          this.handlePromotion(toX, toY, board);\n        }\n        return true;\n      }\n\n      if (board.isEnPassantMove(fromX, fromY, toX, toY)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private handlePromotion(\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): void {\n    const promotionDialog = document.getElementById(\n      'promotionDialog',\n    ) as HTMLDivElement;\n\n    if (promotionDialog) {\n      promotionDialog.style.display = 'block';\n\n      // Définir la fonction de promotion en capturant le contexte (x, y)\n      window.promote = (pieceType: string) => {\n        promotionDialog.style.display = 'none';\n        board.promotePawn(toX, toY, pieceType);\n      };\n    }\n  }\n}\n","// src/utils/utils.ts\n\nimport { PieceColor, PieceType } from '../piece';\n\nexport let capturedWhite: string[] = [];\nexport let capturedBlack: string[] = [];\n\nexport function showMessage(message: string) {\n  const gameMessageElement = document.getElementById(\n    'gameMessage',\n  ) as HTMLDivElement;\n  gameMessageElement.textContent = message;\n  gameMessageElement.style.display = 'block'; // Afficher le message\n}\n\nexport function getPieceSymbol(piece: PieceType, color: PieceColor): string {\n  switch (piece) {\n    case PieceType.PAWN:\n      return color === PieceColor.WHITE ? '♙' : '♟';\n    case PieceType.ROOK:\n      return color === PieceColor.WHITE ? '♖' : '♜';\n    case PieceType.KNIGHT:\n      return color === PieceColor.WHITE ? '♘' : '♞';\n    case PieceType.BISHOP:\n      return color === PieceColor.WHITE ? '♗' : '♝';\n    case PieceType.QUEEN:\n      return color === PieceColor.WHITE ? '♕' : '♛';\n    case PieceType.KING:\n      return color === PieceColor.WHITE ? '♔' : '♚';\n    default:\n      return '';\n  }\n}\n\nexport function updateCapturedPieces(piece: PieceType, color: PieceColor) {\n  const pieceSymbol = getPieceSymbol(piece, color);\n\n  if (color === PieceColor.WHITE) {\n    capturedWhite.push(pieceSymbol);\n  } else {\n    capturedBlack.push(pieceSymbol);\n  }\n\n  updateCapturedPiecesDOM();\n}\n\nexport function updateCapturedPiecesDOM() {\n  const capturedWhiteElement = document.getElementById(\n    'capturedWhite',\n  ) as HTMLDivElement;\n  const capturedBlackElement = document.getElementById(\n    'capturedBlack',\n  ) as HTMLDivElement;\n\n  if (capturedWhiteElement) {\n    capturedWhiteElement.textContent = capturedWhite.join(' ');\n  }\n  if (capturedBlackElement) {\n    capturedBlackElement.textContent = capturedBlack.join(' ');\n  }\n}\n","// src/board.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from './piece';\nimport { Rook } from './pieces/rook';\nimport { Knight } from './pieces/knight';\nimport { Bishop } from './pieces/bishop';\nimport { Queen } from './pieces/queen';\nimport { King } from './pieces/king';\nimport { Pawn } from './pieces/pawn';\nimport { updateCapturedPieces } from './utils/utils';\n\ntype BoardSquare = Piece | null;\n\nexport class Board implements BoardInterface {\n  private grid: BoardSquare[][];\n  private enPassantTarget: { x: number; y: number } | null = null;\n  private halfMoveCount: number = 0; // Compteur pour la règle des 50 coups\n\n  constructor() {\n    this.grid = this.initializeBoard();\n  }\n\n  public initializeBoard(): BoardSquare[][] {\n    const board: BoardSquare[][] = Array(8)\n      .fill(null)\n      .map(() => Array(8).fill(null));\n\n    // Ajouter les pièces blanches\n    board[0] = [\n      new Rook(PieceColor.WHITE),\n      new Knight(PieceColor.WHITE),\n      new Bishop(PieceColor.WHITE),\n      new Queen(PieceColor.WHITE),\n      new King(PieceColor.WHITE),\n      new Bishop(PieceColor.WHITE),\n      new Knight(PieceColor.WHITE),\n      new Rook(PieceColor.WHITE),\n    ];\n    board[1] = Array(8)\n      .fill(null)\n      .map(() => new Pawn(PieceColor.WHITE));\n\n    // Ajouter les pièces noires\n    board[7] = [\n      new Rook(PieceColor.BLACK),\n      new Knight(PieceColor.BLACK),\n      new Bishop(PieceColor.BLACK),\n      new Queen(PieceColor.BLACK),\n      new King(PieceColor.BLACK),\n      new Bishop(PieceColor.BLACK),\n      new Knight(PieceColor.BLACK),\n      new Rook(PieceColor.BLACK),\n    ];\n    board[6] = Array(8)\n      .fill(null)\n      .map(() => new Pawn(PieceColor.BLACK));\n\n    return board;\n  }\n\n  // Méthode générale pour vérifier les limites\n  public isWithinBounds(x: number, y: number): boolean {\n    return x >= 0 && x < 8 && y >= 0 && y < 8;\n  }\n\n  public getPiece(x: number, y: number): BoardSquare {\n    return this.grid[y][x];\n  }\n\n  public getValidMoves(x: number, y: number): { x: number; y: number }[] {\n    let piece = null;\n    if (this.isWithinBounds(x, y)) piece = this.getPiece(x, y);\n    if (!piece) return [];\n\n    const validMoves: { x: number; y: number }[] = [];\n\n    for (let toY = 0; toY < 8; toY++) {\n      for (let toX = 0; toX < 8; toX++) {\n        if (piece.isValidMove(x, y, toX, toY, this)) {\n          validMoves.push({ x: toX, y: toY });\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  public getKingInCheck(): { x: number; y: number } | null {\n    if (this.isKingInCheck(PieceColor.WHITE)) {\n      return this.findKing(PieceColor.WHITE);\n    } else if (this.isKingInCheck(PieceColor.BLACK)) {\n      return this.findKing(PieceColor.BLACK);\n    }\n    return null;\n  }\n\n  public movePiece(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (\n      !this.isWithinBounds(fromX, fromY) ||\n      !this.isWithinBounds(toX, toY) ||\n      ['__proto__', 'constructor', 'prototype'].includes(fromY.toString()) ||\n      ['__proto__', 'constructor', 'prototype'].includes(toY.toString())\n    ) {\n      return false; // Mouvement invalide en dehors des limites ou clé interdite\n    }\n\n    const piece = this.getPiece(fromX, fromY);\n    if (piece && piece.isValidMove(fromX, fromY, toX, toY, this)) {\n      const targetPiece = this.getPiece(toX, toY);\n\n      // Empêche de capturer le roi ennemi\n      if (targetPiece && targetPiece.type === PieceType.KING) {\n        return false;\n      }\n\n      // Gestion du roque\n      if (piece instanceof King && Math.abs(toX - fromX) === 2) {\n        if (this.isCastlingValid(piece, fromX, fromY, toX)) {\n          this.handleCastling(toX, fromY);\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      // Gestion de la prise en passant\n      if (\n        piece instanceof Pawn &&\n        this.isEnPassantMove(fromX, fromY, toX, toY)\n      ) {\n        this.captureEnPassant(fromX, fromY, toX, toY); // Capture le pion en passant\n      }\n\n      // Sauvegarde l'état avant de simuler le mouvement\n      this.grid[toY][toX] = piece;\n      this.grid[fromY][fromX] = null;\n\n      // Vérifie si le mouvement met le roi du joueur en échec\n      if (this.isKingInCheck(piece.color)) {\n        // Annule le mouvement si le roi est en échec\n        this.grid[fromY][fromX] = piece;\n        this.grid[toY][toX] = targetPiece;\n        return false;\n      }\n\n      // Mise à jour de l'état après un mouvement valide\n      if ('hasMoved' in piece) {\n        (piece as any).hasMoved = true;\n      }\n      this.updateEnPassantTarget(fromX, fromY, toX, toY, piece);\n\n      // Réinitialise le compteur pour la règle des 50 coups si un pion bouge ou une capture a lieu\n      this.halfMoveCount =\n        piece.type === PieceType.PAWN || targetPiece\n          ? 0\n          : this.halfMoveCount + 1;\n\n      // Vérifie si le mouvement met l'adversaire en échec et mat\n      const opponentColor =\n        piece.color === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n      if (this.isCheckmate(opponentColor)) {\n        return true; // Partie terminée\n      }\n\n      return true;\n    }\n\n    return false; // Mouvement invalide\n  }\n\n  private isCastlingValid(\n    king: King,\n    fromX: number,\n    fromY: number,\n    toX: number,\n  ): boolean {\n    const direction = toX > fromX ? 1 : -1;\n    const rookX = toX > fromX ? 7 : 0;\n    const rook = this.getPiece(rookX, fromY);\n\n    if (!(rook instanceof Rook) || rook.hasMoved || king.hasMoved) return false;\n\n    // Vérifie que les cases entre le roi et la tour sont libres\n    for (let x = fromX + direction; x !== toX; x += direction) {\n      if (\n        this.getPiece(x, fromY) ||\n        this.isSquareUnderAttack(x, fromY, king.color)\n      ) {\n        return false;\n      }\n    }\n\n    return (\n      !this.isSquareUnderAttack(fromX, fromY, king.color) &&\n      !this.isSquareUnderAttack(toX, fromY, king.color)\n    );\n  }\n\n  private handleCastling(kingX: number, kingY: number): void {\n    // Déplacement pour le petit roque (roi se déplace vers la droite)\n    if (kingX === 6) {\n      const rook = this.getPiece(7, kingY);\n      if (rook instanceof Rook) {\n        this.movePiece(7, kingY, 5, kingY);\n      }\n    }\n    // Déplacement pour le grand roque (roi se déplace vers la gauche)\n    else if (kingX === 2) {\n      const rook = this.getPiece(0, kingY);\n      if (rook instanceof Rook) {\n        this.movePiece(0, kingY, 3, kingY);\n      }\n    }\n  }\n\n  public updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    if (piece instanceof Pawn && Math.abs(toY - fromY) === 2 && fromX === toX) {\n      // Si le pion avance de deux cases, configure la cible pour la prise en passant\n      this.enPassantTarget = { x: toX, y: (fromY + toY) / 2 };\n    } else {\n      this.enPassantTarget = null;\n    }\n  }\n\n  public captureEnPassant(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): { capturedWhite: PieceType[]; capturedBlack: PieceType[] } | null {\n    const piece = this.getPiece(fromX, fromY);\n\n    if (this.isEnPassantMove(fromX, fromY, toX, toY) && piece instanceof Pawn) {\n      const direction = piece.color === PieceColor.WHITE ? -1 : 1;\n      const capturedPawnY = toY + direction;\n      const capturedPawn = this.getPiece(toX, capturedPawnY);\n\n      if (capturedPawn && capturedPawn.type === PieceType.PAWN) {\n        this.grid[capturedPawnY][toX] = null;\n\n        // Déclare explicitement le type de captureData pour éviter l'erreur\n        const captureData: {\n          capturedWhite: PieceType[];\n          capturedBlack: PieceType[];\n        } = {\n          capturedWhite: [],\n          capturedBlack: [],\n        };\n\n        if (capturedPawn.color === PieceColor.WHITE) {\n          captureData.capturedWhite.push(capturedPawn.type);\n        } else {\n          captureData.capturedBlack.push(capturedPawn.type);\n        }\n\n        // Appelle updateCapturedPieces pour mettre à jour le DOM\n        updateCapturedPieces(capturedPawn.type, capturedPawn.color);\n\n        return captureData;\n      }\n    }\n    return null;\n  }\n\n  public isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (!this.enPassantTarget) return false;\n\n    // Vérifie que le mouvement cible la bonne case pour la prise en passant\n    const piece = this.getPiece(fromX, fromY);\n    return (\n      piece instanceof Pawn &&\n      toX === this.enPassantTarget.x &&\n      toY === this.enPassantTarget.y &&\n      Math.abs(fromX - toX) === 1 &&\n      Math.abs(fromY - toY) === 1\n    );\n  }\n\n  public promotePawn(x: number, y: number, pieceType: string): void {\n    const color = this.getPiece(x, y)?.color;\n\n    if (!color) return;\n\n    switch (pieceType) {\n      case 'queen':\n        this.grid[y][x] = new Queen(color);\n        break;\n      case 'rook':\n        this.grid[y][x] = new Rook(color);\n        break;\n      case 'bishop':\n        this.grid[y][x] = new Bishop(color);\n        break;\n      case 'knight':\n        this.grid[y][x] = new Knight(color);\n        break;\n    }\n  }\n\n  public isKingInCheck(color: PieceColor): boolean {\n    const kingPosition = this.findKing(color);\n    if (!kingPosition) {\n      return false;\n    }\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(x, y, kingPosition.x, kingPosition.y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  public isCheckmate(color: PieceColor): boolean {\n    if (!this.isKingInCheck(color)) {\n      return false; // Pas de mat si le roi n'est pas en échec\n    }\n\n    // Parcourt chaque pièce de la couleur donnée pour trouver un mouvement légal\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          const moves = this.getValidMoves(x, y);\n\n          for (const move of moves) {\n            // Simule le mouvement\n            const originalPiece = this.getPiece(move.x, move.y);\n            this.grid[move.y][move.x] = piece;\n            this.grid[y][x] = null;\n\n            const kingSafe = !this.isKingInCheck(color);\n\n            // Annule le mouvement simulé\n            this.grid[y][x] = piece;\n            this.grid[move.y][move.x] = originalPiece;\n\n            if (kingSafe) {\n              return false; // Un mouvement légal existe pour sortir de l'échec\n            }\n          }\n        }\n      }\n    }\n\n    return true; // Aucun mouvement possible, échec et mat\n  }\n\n  public isStalemate(color: PieceColor): boolean {\n    // Pat uniquement si le roi n'est pas en échec et qu'il n'y a aucun coup légal disponible\n    if (this.isKingInCheck(color)) return false;\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          for (let toY = 0; toY < 8; toY++) {\n            for (let toX = 0; toX < 8; toX++) {\n              if (piece.isValidMove(x, y, toX, toY, this)) {\n                // Simuler le mouvement pour vérifier l'échec potentiel\n                const originalPiece = this.getPiece(toX, toY);\n                this.grid[toY][toX] = piece;\n                this.grid[y][x] = null;\n\n                const isKingSafe = !this.isKingInCheck(color);\n\n                // Annuler le mouvement simulé\n                this.grid[y][x] = piece;\n                this.grid[toY][toX] = originalPiece;\n\n                if (isKingSafe) return false; // Mouvement valide trouvé, pas de pat\n              }\n            }\n          }\n        }\n      }\n    }\n    return true; // Aucun coup légal trouvé, pat détecté\n  }\n\n  private findKing(color: PieceColor): { x: number; y: number } | null {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece instanceof King && piece.color === color) {\n          return { x, y };\n        }\n      }\n    }\n    return null;\n  }\n\n  public isKing(x: number, y: number): boolean {\n    const piece = this.getPiece(x, y);\n    return piece instanceof King;\n  }\n\n  public isSquareUnderAttack(x: number, y: number, color: PieceColor): boolean {\n    for (let fromY = 0; fromY < 8; fromY++) {\n      for (let fromX = 0; fromX < 8; fromX++) {\n        const piece = this.getPiece(fromX, fromY);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(fromX, fromY, x, y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Vérifie le matériel insuffisant pour un échec et mat\n  public isInsufficientMaterial(): boolean {\n    const pieces = this.grid.flat().filter((piece) => piece !== null);\n\n    // Cas les plus courants de matériel insuffisant\n    if (pieces.length <= 2) return true; // Seulement les rois sur le plateau\n    return (\n      pieces.length === 3 &&\n      pieces.some(\n        (piece) =>\n          piece?.type === PieceType.BISHOP || piece?.type === PieceType.KNIGHT,\n      )\n    );\n  }\n\n  // Vérifie si la règle des 50 coups est remplie\n  public isFiftyMoveRule(): boolean {\n    return this.halfMoveCount >= 50;\n  }\n\n  public setPiece(x: number, y: number, piece: Piece | null): void {\n    this.grid[y][x] = piece;\n  }\n\n  // Vérifie si un mouvement est valide\n  public isMoveValid(\n    fromRow: number,\n    fromCol: number,\n    toRow: number,\n    toCol: number,\n  ): boolean {\n    const piece = this.getPiece(fromRow, fromCol);\n\n    // Si aucune pièce n'est présente à l'emplacement source, le mouvement est invalide\n    if (!piece) {\n      return false;\n    }\n\n    // Si la destination est en dehors de l'échiquier, mouvement invalide\n    if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) {\n      return false;\n    }\n\n    // Vérifie si la pièce peut se déplacer à cette destination en utilisant la logique de mouvement de la pièce\n    if (!piece.isValidMove(fromRow, fromCol, toRow, toCol, this)) {\n      return false;\n    }\n\n    // Vérifie s'il y a une pièce à la destination et si elle est de la même couleur\n    const destinationPiece = this.getPiece(toRow, toCol);\n    return !(destinationPiece && destinationPiece.color === piece.color);\n  }\n\n  public isCapture(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    const piece = this.isWithinBounds(fromX, fromY)\n      ? this.getPiece(fromX, fromY)\n      : null;\n    const targetPiece = this.isWithinBounds(toX, toY)\n      ? this.getPiece(toX, toY)\n      : null;\n\n    // Vérifie qu'il y a une pièce à la position cible et qu'elle est d'une couleur opposée\n    return (\n      piece !== null &&\n      targetPiece !== null &&\n      piece.color !== targetPiece.color\n    );\n  }\n\n  public static async fromData(data: any): Promise<Board> {\n    const board = new Board();\n    board.grid = await Promise.all(\n      data.grid.map(async (row: any[]) =>\n        Promise.all(\n          row.map(async (pieceData) =>\n            pieceData ? await Piece.fromData(pieceData) : null,\n          ),\n        ),\n      ),\n    );\n    return board;\n  }\n\n  public toData(): any {\n    return {\n      grid: this.grid.map((row) =>\n        row.map((piece) => (piece ? piece.toData() : null)),\n      ),\n    };\n  }\n\n  public isAdjacentToAnotherKing(\n    x: number,\n    y: number,\n    color: PieceColor,\n  ): boolean {\n    const kingPositions = [\n      { dx: -1, dy: -1 },\n      { dx: -1, dy: 0 },\n      { dx: -1, dy: 1 },\n      { dx: 0, dy: -1 },\n      { dx: 0, dy: 1 },\n      { dx: 1, dy: -1 },\n      { dx: 1, dy: 0 },\n      { dx: 1, dy: 1 },\n    ];\n\n    for (const { dx, dy } of kingPositions) {\n      const nx = x + dx;\n      const ny = y + dy;\n      const piece = this.isWithinBounds(nx, ny) ? this.getPiece(nx, ny) : null;\n      if (piece instanceof King && piece.color !== color) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n","// game.ts\nimport { Board } from './board';\nimport { updateCapturedPieces } from './utils/utils';\nimport { PieceColor, PieceType } from './piece';\n\nexport class Game {\n  private readonly board: Board;\n  private aiWorker: Worker;\n\n  constructor() {\n    this.board = new Board();\n    this.aiWorker = new Worker(new URL('./ai.worker.ts', import.meta.url), {\n      type: 'module',\n    });\n\n    this.aiWorker.onmessage = (event) => {\n      const { bestMove, captureData } = event.data;\n\n      if (bestMove) {\n        const wasMoved = this.board.movePiece(\n          bestMove.fromX,\n          bestMove.fromY,\n          bestMove.toX,\n          bestMove.toY,\n        );\n\n        if (wasMoved && captureData) {\n          captureData.capturedWhite.forEach((piece: PieceType) =>\n            updateCapturedPieces(piece, PieceColor.WHITE),\n          );\n          captureData.capturedBlack.forEach((piece: PieceType) =>\n            updateCapturedPieces(piece, PieceColor.BLACK),\n          );\n        }\n      }\n    };\n  }\n\n  public getBoard(): Board {\n    return this.board;\n  }\n\n  public makeAIMove(): void {\n    const boardData = this.board.toData();\n    this.aiWorker.postMessage({ boardData });\n  }\n}\n","// src/canvas-renderer.ts\nimport { Board } from './board';\nimport { Piece, PieceColor } from './piece';\n\nexport class CanvasRenderer {\n  private canvas: HTMLCanvasElement;\n  private context: CanvasRenderingContext2D;\n  private readonly tileSize: number;\n  private draggingPiece: Piece | null = null;\n  private startX: number | null = null;\n  private startY: number | null = null;\n  private highlightedMoves: { x: number; y: number }[] = [];\n  private kingInCheckPosition: { x: number; y: number } | null = null;\n\n  constructor(\n    private board: Board,\n    canvasId: string,\n    private moveHandler: (\n      fromX: number,\n      fromY: number,\n      toX: number,\n      toY: number,\n    ) => boolean, // Utilisation d'un retour booléen pour vérifier si le mouvement est valide\n  ) {\n    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    this.context = this.canvas.getContext('2d')!;\n    this.tileSize = this.canvas.width / 8;\n\n    // Définir le curseur par défaut\n    this.canvas.style.cursor = 'default';\n\n    // Ajouter des écouteurs pour gérer les événements de glisser-déposer\n    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n  }\n\n  // Animation pour déplacer une pièce\n  public animateMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    const frames = 10;\n    let currentFrame = 0;\n\n    const startX = fromX * this.tileSize;\n    const startY = fromY * this.tileSize;\n    const deltaX = ((toX - fromX) * this.tileSize) / frames;\n    const deltaY = ((toY - fromY) * this.tileSize) / frames;\n\n    const animate = () => {\n      if (currentFrame <= frames) {\n        // Redessine l'échiquier pour effacer l'ancienne position de la pièce\n        this.drawBoard();\n\n        this.context.fillStyle =\n          piece.color === PieceColor.WHITE ? 'white' : 'black';\n        this.context.font = '48px Arial';\n        this.context.textAlign = 'center';\n        this.context.textBaseline = 'middle';\n\n        // Dessine la pièce en mouvement\n        this.context.fillText(\n          this.getPieceText(piece),\n          startX + deltaX * currentFrame + this.tileSize / 2,\n          startY + deltaY * currentFrame + this.tileSize / 2,\n        );\n\n        currentFrame++;\n        requestAnimationFrame(animate);\n      } else {\n        // Redessiner l'échiquier à la fin de l'animation pour afficher la pièce à la position finale\n        this.drawBoard();\n      }\n    };\n\n    animate();\n  }\n\n  // Surligne les mouvements valides pour une pièce sélectionnée\n  highlightValidMoves(moves: { x: number; y: number }[]): void {\n    this.context.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Couleur de surlignage (vert translucide)\n    moves.forEach((move) => {\n      this.context.fillRect(\n        move.x * this.tileSize,\n        move.y * this.tileSize,\n        this.tileSize,\n        this.tileSize,\n      );\n    });\n  }\n\n  // Dessiner l'échiquier et les pièces\n  public drawBoard(): void {\n    // Obtenir la position du roi en échec si elle existe\n    const kingInCheck = this.board.getKingInCheck();\n    this.kingInCheckPosition = kingInCheck\n      ? { x: kingInCheck.x, y: kingInCheck.y }\n      : null;\n\n    // Dessiner le plateau\n    this.drawTiles();\n    this.drawPieces();\n  }\n\n  // Dessiner les cases de l'échiquier\n  private drawTiles(): void {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const isDarkTile = (x + y) % 2 === 1;\n        let tileColor = isDarkTile ? '#769656' : '#eeeed2';\n\n        // Si la case contient le roi en échec, change la couleur\n        if (\n          this.kingInCheckPosition &&\n          this.kingInCheckPosition.x === x &&\n          this.kingInCheckPosition.y === y\n        ) {\n          tileColor = '#ff6347'; // Par exemple, une couleur rouge pour indiquer l'échec\n        }\n\n        this.context.fillStyle = tileColor;\n        this.context.fillRect(\n          x * this.tileSize,\n          y * this.tileSize,\n          this.tileSize,\n          this.tileSize,\n        );\n      }\n    }\n  }\n\n  // Dessiner toutes les pièces sur l'échiquier\n  private drawPieces(): void {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.board.getPiece(x, y);\n        if (piece) {\n          this.drawPiece(piece, x, y);\n        }\n      }\n    }\n  }\n\n  // Dessiner une pièce spécifique\n  private drawPiece(piece: Piece, x: number, y: number): void {\n    this.context.fillStyle = piece.color === 'white' ? 'white' : 'black';\n    this.context.font = '48px Arial';\n    this.context.textAlign = 'center';\n    this.context.textBaseline = 'middle';\n    const pieceText = this.getPieceText(piece);\n    this.context.fillText(\n      pieceText,\n      x * this.tileSize + this.tileSize / 2,\n      y * this.tileSize + this.tileSize / 2,\n    );\n  }\n\n  // Convertir le type de pièce en texte pour affichage\n  private getPieceText(piece: Piece): string {\n    switch (piece.type) {\n      case 'pawn':\n        return piece.color === 'white' ? '♙' : '♟';\n      case 'rook':\n        return piece.color === 'white' ? '♖' : '♜';\n      case 'knight':\n        return piece.color === 'white' ? '♘' : '♞';\n      case 'bishop':\n        return piece.color === 'white' ? '♗' : '♝';\n      case 'queen':\n        return piece.color === 'white' ? '♕' : '♛';\n      case 'king':\n        return piece.color === 'white' ? '♔' : '♚';\n      default:\n        return '';\n    }\n  }\n\n  // Gérer le début du glissement\n  private handleMouseDown(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    const piece = this.board.getPiece(x, y);\n    if (piece) {\n      this.draggingPiece = piece;\n      this.startX = x;\n      this.startY = y;\n      this.canvas.style.cursor = 'grabbing'; // Change le curseur pendant le drag\n\n      // Obtenez les mouvements légaux pour la pièce sélectionnée\n      this.highlightedMoves = this.board.getValidMoves(x, y);\n\n      // Redessinez le plateau avec les cases surlignées\n      this.drawBoard();\n      this.highlightValidMoves(this.highlightedMoves); // Surligne les mouvements valides\n    }\n  }\n\n  // Gérer le mouvement pendant le glissement\n  private handleMouseMove(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    // Changer le curseur lorsque la souris survole une pièce\n    let piece = null;\n    if (this.board.isWithinBounds(x, y)) piece = this.board.getPiece(x, y);\n    if (piece && !this.draggingPiece) {\n      this.canvas.style.cursor = 'pointer';\n    } else if (!this.draggingPiece) {\n      this.canvas.style.cursor = 'default';\n    }\n\n    if (!this.draggingPiece) return;\n\n    // Dessiner l'échiquier et les pièces\n    this.drawBoard();\n\n    // Assurez-vous que les mouvements valides restent visibles pendant le glissement\n    this.highlightValidMoves(this.highlightedMoves);\n\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n\n    // Dessiner la pièce en mouvement\n    this.context.fillStyle =\n      this.draggingPiece.color === 'white' ? 'white' : 'black';\n    this.context.font = '48px Arial';\n    this.context.textAlign = 'center';\n    this.context.textBaseline = 'middle';\n    const pieceText = this.getPieceText(this.draggingPiece);\n    this.context.fillText(pieceText, mouseX, mouseY);\n  }\n\n  // Gérer la fin du glissement\n  private handleMouseUp(event: MouseEvent): void {\n    if (!this.draggingPiece || this.startX === null || this.startY === null)\n      return;\n\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    // Utilise la fonction de rappel `moveHandler` pour déplacer la pièce\n    const moveSuccessful = this.moveHandler(this.startX, this.startY, x, y);\n\n    // Réinitialise l'état de glissement\n    this.draggingPiece = null;\n    this.startX = null;\n    this.startY = null;\n    this.canvas.style.cursor = 'default'; // Rétablir le curseur par défaut\n\n    // Efface les coups surlignés\n    this.highlightedMoves = [];\n\n    // Redessine le plateau après la fin du glissement\n    this.drawBoard();\n\n    // Si le mouvement est réussi, met à jour le tour\n    if (moveSuccessful) {\n      this.drawBoard();\n    }\n  }\n}\n","// src/timer.ts\nexport class Timer {\n  private intervalId: number | null = null;\n  private currentTime: number;\n  private readonly onTimeUpdate: (timeLeft: number) => void;\n  public isRunning: boolean = false;\n\n  constructor(\n    private initialTime: number,\n    onTimeUpdate: (timeLeft: number) => void,\n  ) {\n    this.currentTime = initialTime;\n    this.onTimeUpdate = onTimeUpdate;\n  }\n\n  // Démarrer le compte à rebours\n  public start(): void {\n    if (this.isRunning) return;\n\n    this.isRunning = true;\n    this.intervalId = window.setInterval(() => {\n      this.currentTime--;\n      this.onTimeUpdate(this.currentTime);\n\n      if (this.currentTime <= 0) {\n        this.currentTime = 0;\n        this.stop();\n        // Appel de la fonction onTimeUpdate une dernière fois pour garantir l'affichage du temps écoulé\n        this.onTimeUpdate(this.currentTime);\n      }\n    }, 1000);\n  }\n\n  // Arrêter le compte à rebours\n  public stop(): void {\n    if (!this.isRunning) {\n      return;\n    }\n\n    if (this.intervalId !== null) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    this.isRunning = false;\n  }\n\n  // Réinitialiser le temps\n  public reset(time: number): void {\n    this.stop();\n    this.currentTime = time;\n    this.onTimeUpdate(this.currentTime); // Appel immédiat pour la mise à jour du temps\n    this.start();\n  }\n}\n","// src/index.ts\nimport { Game } from './game';\nimport { CanvasRenderer } from './canvas-renderer';\nimport { Timer } from './timer';\nimport { PieceColor, PieceType } from './piece';\nimport {\n  getPieceSymbol,\n  showMessage,\n  updateCapturedPieces,\n} from './utils/utils';\n\nconst game = new Game();\nconst board = game.getBoard();\nconst moveHistoryElement = document.getElementById(\n  'moveHistory',\n) as HTMLUListElement;\nconst currentTurnElement = document.getElementById(\n  'currentTurn',\n) as HTMLDivElement;\nconst timerElement = document.getElementById('timer') as HTMLDivElement;\nconst passTurnButton = document.getElementById(\n  'passTurnButton',\n) as HTMLButtonElement;\nconst gameMessageElement = document.getElementById(\n  'gameMessage',\n) as HTMLDivElement;\nconst replayButton = document.getElementById(\n  'replayButton',\n) as HTMLButtonElement;\n\nlet currentPlayer: PieceColor = PieceColor.WHITE; // Les blancs commencent toujours\nlet gameState: 'playing' | 'waiting' = 'playing'; // Ajout de l'état pour la proposition de nullité\nlet hasMoved: boolean = false; // Indique si un mouvement a déjà été effectué dans ce tour\nlet moveHistory: {\n  fromX: number;\n  fromY: number;\n  toX: number;\n  toY: number;\n  pieceType: PieceType;\n}[][] = [[]]; // Historique des mouvements par tour\nlet isGameEnded = false;\n\n// Initialiser le timer avec 60 secondes pour chaque joueur\nlet whiteTimer = new Timer(60, (timeLeft) =>\n  updateTimerDisplay(timeLeft, PieceColor.WHITE),\n);\nlet blackTimer = new Timer(60, (timeLeft) =>\n  updateTimerDisplay(timeLeft, PieceColor.BLACK),\n);\n\n// Fonction pour mettre à jour l'affichage du timer\nexport function updateTimerDisplay(timeLeft: number, color: PieceColor) {\n  if (color === currentPlayer) {\n    timerElement.textContent = `Temps restant: ${timeLeft}s`;\n    if (timeLeft <= 0 && !isGameEnded) {\n      endGame(\n        `${currentPlayer === PieceColor.WHITE ? 'Noir' : 'Blanc'} gagne par temps écoulé !`,\n      );\n    }\n  }\n}\n\n// Démarrer le jeu et dessiner le plateau\nconst renderer = new CanvasRenderer(board, 'chessBoard', handleMove);\nrenderer.drawBoard();\nwhiteTimer.start();\n\nexport function endGame(message: string) {\n  showMessage(message);\n  isGameEnded = true;\n  replayButton.style.display = 'block';\n  if (whiteTimer.isRunning) whiteTimer.stop();\n  if (blackTimer.isRunning) blackTimer.stop();\n}\n\n// Fonction pour effacer le message d'erreur\nfunction clearMessage() {\n  gameMessageElement.textContent = '';\n  gameMessageElement.style.display = 'none';\n}\n\n// Fonction pour mettre à jour le tour et l'affichage\nfunction updateTurn() {\n  clearMessage();\n  currentPlayer =\n    currentPlayer === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n  currentTurnElement.textContent = `Tour actuel: ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`;\n  hasMoved = false;\n\n  // Gestion du bouton \"Passer son tour\"\n  passTurnButton.disabled = currentPlayer === PieceColor.BLACK;\n\n  // Gestion des timers\n  if (currentPlayer === PieceColor.WHITE) {\n    if (blackTimer.isRunning) blackTimer.stop();\n    whiteTimer.reset(60);\n  } else {\n    if (whiteTimer.isRunning) whiteTimer.stop();\n    blackTimer.reset(60);\n  }\n\n  if (\n    board.isKingInCheck(PieceColor.BLACK) ||\n    board.isKingInCheck(PieceColor.WHITE)\n  ) {\n    if (board.isCheckmate(PieceColor.BLACK)) {\n      endGame('Échec et Mat ! Blanc gagne !');\n    }\n\n    if (board.isCheckmate(PieceColor.WHITE)) {\n      endGame('Échec et Mat ! Noir gagne !');\n    }\n  }\n\n  // Vérifie les conditions de nullité\n  if (board.isStalemate(currentPlayer)) {\n    endGame('Pat ! La partie est nulle.');\n  }\n\n  if (board.isInsufficientMaterial()) {\n    endGame('Matériel insuffisant pour continuer, partie nulle !');\n  }\n\n  if (board.isFiftyMoveRule()) {\n    endGame('Règle des 50 coups, partie nulle !');\n  }\n\n  // Seul \"playing\" permet de jouer\n  if (gameState === 'playing') {\n    gameState = 'playing';\n  }\n\n  // Crée un nouveau tour dans l'historique des mouvements\n  moveHistory.push([]);\n\n  // Si c'est au tour de l'IA, faire jouer l'IA automatiquement\n  if (currentPlayer === PieceColor.BLACK) {\n    game.makeAIMove();\n    renderer.drawBoard();\n    updateTurn(); // Change de tour après que l'IA a joué\n  }\n}\n\n// Ajouter un mouvement à l'historique\nfunction addMoveToHistory(\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n  pieceType: PieceType,\n) {\n  const moveText = `${getPieceSymbol(pieceType, PieceColor.WHITE)} de (${fromX}, ${fromY}) à (${toX}, ${toY})`;\n  const listItem = document.createElement('li');\n  listItem.textContent = moveText;\n  moveHistoryElement.appendChild(listItem);\n\n  // Ajoutez le mouvement au tour actuel\n  moveHistory[moveHistory.length - 1].push({\n    fromX,\n    fromY,\n    toX,\n    toY,\n    pieceType,\n  });\n}\n\n// Fonction pour gérer un mouvement sur le plateau\nexport function handleMove(\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n): boolean {\n  if (gameState === 'waiting' || hasMoved || isGameEnded) {\n    showMessage('Veuillez attendre le prochain tour !');\n    return false;\n  }\n\n  const piece = board.getPiece(fromX, fromY);\n  const targetPiece = board.getPiece(toX, toY); // Ajout pour vérifier la cible\n\n  if (!piece || piece.color !== currentPlayer) {\n    showMessage(\n      `C'est le tour de ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`,\n    );\n    return false;\n  }\n\n  if (piece.isValidMove(fromX, fromY, toX, toY, board)) {\n    if (board.movePiece(fromX, fromY, toX, toY)) {\n      hasMoved = true; // Empêche les actions supplémentaires\n\n      // Enregistrement de la capture si une pièce est prise\n      if (targetPiece) {\n        updateCapturedPieces(targetPiece.type, targetPiece.color);\n      }\n\n      addMoveToHistory(fromX, fromY, toX, toY, piece.type);\n      renderer.animateMove(fromX, fromY, toX, toY, piece);\n      updateTurn();\n      return true;\n    }\n    showMessage('Mouvement invalide !');\n  }\n  return false;\n}\n\n// Gérer le clic sur \"Passer son tour\"\nif (passTurnButton) {\n  passTurnButton.addEventListener('click', (event) => {\n    event.preventDefault();\n    if (\n      gameState === 'playing' &&\n      currentPlayer === PieceColor.WHITE &&\n      !board.isKingInCheck(PieceColor.WHITE)\n    ) {\n      showMessage(\n        `Tour passé pour ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`,\n      );\n      updateTurn();\n    }\n  });\n}\n\n// Gérer le clic sur \"Rejouer\"\nif (replayButton) {\n  replayButton.addEventListener('click', () => {\n    location.reload();\n  });\n}\nexport { Game };\n"],"file":"assets/index-BRNtFCNF.js"}