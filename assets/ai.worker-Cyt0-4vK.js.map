{"version":3,"file":"ai.worker-Cyt0-4vK.js","sources":["../src/utils/pieceFactory.ts","../src/piece.ts","../src/pieces/rook.ts","../src/pieces/knight.ts","../src/pieces/bishop.ts","../src/pieces/queen.ts","../src/pieces/king.ts","../src/pieces/pawn.ts","../src/utils.ts","../src/board.ts","../src/evaluator.ts","../src/ai.ts","../src/ai.worker.ts"],"sourcesContent":["import { PieceColor, PieceType } from '../piece';\n\nexport async function createPiece(type: PieceType, color: PieceColor) {\n  switch (type) {\n    case PieceType.PAWN:\n      const { Pawn } = await import('../pieces/pawn');\n      return new Pawn(color);\n    case PieceType.ROOK:\n      const { Rook } = await import('../pieces/rook');\n      return new Rook(color);\n    case PieceType.KNIGHT:\n      const { Knight } = await import('../pieces/knight');\n      return new Knight(color);\n    case PieceType.BISHOP:\n      const { Bishop } = await import('../pieces/bishop');\n      return new Bishop(color);\n    case PieceType.QUEEN:\n      const { Queen } = await import('../pieces/queen');\n      return new Queen(color);\n    case PieceType.KING:\n      const { King } = await import('../pieces/king');\n      return new King(color);\n    default:\n      throw new Error(`Type de pièce inconnu : ${type}`);\n  }\n}\n","// src/piece.ts\nimport { createPiece } from './utils/pieceFactory';\n\nexport enum PieceColor {\n  WHITE = 'white',\n  BLACK = 'black',\n}\n\nexport enum PieceType {\n  PAWN = 'pawn',\n  ROOK = 'rook',\n  KNIGHT = 'knight',\n  BISHOP = 'bishop',\n  QUEEN = 'queen',\n  KING = 'king',\n}\n\nexport interface BoardInterface {\n  getPiece(x: number, y: number): Piece | null;\n\n  updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void;\n\n  isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean;\n\n  promotePawn(x: number, y: number, pieceType: string): void;\n}\n\nexport abstract class Piece {\n  protected constructor(\n    public color: PieceColor,\n    public type: PieceType,\n  ) {}\n\n  abstract isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean;\n\n  public isPathClear(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const dx = Math.sign(toX - fromX);\n    const dy = Math.sign(toY - fromY);\n\n    let x = fromX + dx;\n    let y = fromY + dy;\n    while (x !== toX || y !== toY) {\n      if (board.getPiece(x, y) !== null) return false;\n      x += dx;\n      y += dy;\n    }\n    return true;\n  }\n\n  // src/piece.ts\n  public canCapture(toX: number, toY: number, board: BoardInterface): boolean {\n    const targetPiece = board.getPiece(toX, toY);\n    return !targetPiece || targetPiece.color !== this.color;\n  }\n\n  // Sérialisation des données de la pièce\n  public toData(): any {\n    return {\n      color: this.color,\n      type: this.type,\n    };\n  }\n\n  static async fromData(data: any): Promise<Piece> {\n    return await createPiece(data.type, data.color);\n  }\n}\n","// src/pieces/rook.ts\n\nimport { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\n\nexport class Rook extends Piece {\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.ROOK);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const isStraightMove = fromX === toX || fromY === toY;\n    if (!isStraightMove) {\n      return false;\n    }\n\n    const isPathClear = this.isPathClear(fromX, fromY, toX, toY, board);\n    if (!isPathClear) {\n      return false;\n    }\n\n    return this.canCapture(toX, toY, board);\n  }\n\n  public toData(): any {\n    return {\n      ...super.toData(),\n      hasMoved: this.hasMoved,\n    };\n  }\n\n  // Ajuste le type de retour pour inclure Promise<Rook>\n  static async fromData(data: any): Promise<Rook> {\n    const rook = new Rook(data.color);\n    rook.hasMoved = data.hasMoved;\n    return rook;\n  }\n}\n","// src/pieces/knight.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\n\nexport class Knight extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.KNIGHT);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    // Le Cavalier se déplace en L : 2 cases dans une direction puis 1 case perpendiculairement\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n    return (\n      ((dx === 2 && dy === 1) || (dx === 1 && dy === 2)) &&\n      this.canCapture(toX, toY, board)\n    );\n  }\n}\n","// src/pieces/bishop.ts\nimport { PieceColor, PieceType } from '../piece';\nimport { BoardInterface } from '../piece';\n\nexport class Bishop extends (await import('../piece')).Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.BISHOP);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    // Le fou se déplace en diagonale\n    if (Math.abs(toX - fromX) === Math.abs(toY - fromY)) {\n      // Vérifie que la trajectoire est dégagée\n      if (this.isPathClear(fromX, fromY, toX, toY, board)) {\n        // Vérifie si la cible est vide ou contient une pièce ennemie\n        return this.canCapture(toX, toY, board);\n      }\n    }\n    return false;\n  }\n}\n","// src/pieces/queen.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\n\nexport class Queen extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.QUEEN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    // La reine peut se déplacer en ligne droite ou en diagonale\n    if (\n      fromX === toX || // Déplacement en colonne\n      fromY === toY || // Déplacement en ligne\n      Math.abs(toX - fromX) === Math.abs(toY - fromY) // Déplacement en diagonale\n    ) {\n      // Vérifie que la trajectoire est dégagée\n      if (this.isPathClear(fromX, fromY, toX, toY, board)) {\n        // Vérifie si la cible est vide ou contient une pièce ennemie\n        return this.canCapture(toX, toY, board);\n      }\n    }\n\n    return false;\n  }\n}\n","import { BoardInterface, Piece, PieceColor, PieceType } from '../piece';\nimport { Rook } from './rook';\n\nexport class King extends Piece {\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.KING);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n\n    // Vérification pour le mouvement classique du roi\n    if (dx <= 1 && dy <= 1) {\n      const targetPiece = board.getPiece(toX, toY);\n      return (\n        this.canCapture(toX, toY, board) &&\n        (!targetPiece || targetPiece.type !== PieceType.KING)\n      );\n    }\n\n    // Logique pour le roque (grand ou petit)\n    if (!this.hasMoved && dy === 0 && dx === 2) {\n      const direction = toX > fromX ? 1 : -1;\n      const rookX = toX > fromX ? 7 : 0;\n      const rook = board.getPiece(rookX, fromY);\n\n      if (rook && rook instanceof Rook && !rook.hasMoved) {\n        // Vérifie que les cases entre le roi et la tour sont libres\n        for (let x = fromX + direction; x !== rookX; x += direction) {\n          if (board.getPiece(x, fromY)) return false;\n        }\n\n        // Assure que le roi n'est pas en échec avant, pendant ou après le roque\n        if (\n          !board.isKingInCheck(this.color) &&\n          !board.isSquareUnderAttack(fromX + direction, fromY, this.color) &&\n          !board.isSquareUnderAttack(toX, fromY, this.color)\n        ) {\n          return true; // Roque valide\n        }\n      }\n    }\n\n    return false;\n  }\n}\n","// src/pieces/pawn.ts\nimport { Piece, PieceColor, PieceType, BoardInterface } from '../piece';\n\nexport class Pawn extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.PAWN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const direction = this.color === PieceColor.WHITE ? 1 : -1;\n    const startRow = this.color === PieceColor.WHITE ? 1 : 6;\n    const distanceY = (toY - fromY) * direction;\n    const distanceX = Math.abs(toX - fromX);\n\n    if (distanceX === 0 && distanceY === 1 && !board.getPiece(toX, toY)) {\n      if (\n        (this.color === PieceColor.WHITE && toY === 7) ||\n        (this.color === PieceColor.BLACK && toY === 0)\n      ) {\n        this.handlePromotion(toX, toY, board);\n      }\n      return true;\n    }\n\n    if (\n      distanceX === 0 &&\n      distanceY === 2 &&\n      fromY === startRow &&\n      !board.getPiece(toX, toY) &&\n      !board.getPiece(fromX, fromY + direction)\n    ) {\n      board.updateEnPassantTarget(fromX, fromY, toX, toY, this);\n      return true;\n    }\n\n    if (distanceX === 1 && distanceY === 1) {\n      if (board.getPiece(toX, toY) && this.canCapture(toX, toY, board)) {\n        if (\n          (this.color === PieceColor.WHITE && toY === 7) ||\n          (this.color === PieceColor.BLACK && toY === 0)\n        ) {\n          this.handlePromotion(toX, toY, board);\n        }\n        return true;\n      }\n\n      if (board.isEnPassantMove(fromX, fromY, toX, toY)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private handlePromotion(\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): void {\n    const promotionDialog = document.getElementById('promotionDialog');\n    if (promotionDialog) {\n      promotionDialog.style.display = 'block';\n      window.promote = (pieceType: string) => {\n        promotionDialog.style.display = 'none';\n        board.promotePawn(toX, toY, pieceType);\n      };\n    }\n  }\n}\n","// src/utils.ts\n\nimport { PieceColor, PieceType } from './piece';\n\nexport let capturedWhite: string[] = [];\nexport let capturedBlack: string[] = [];\n\nexport function showMessage(message: string) {\n  const gameMessageElement = document.getElementById('gameMessage')!;\n  gameMessageElement.textContent = message;\n  gameMessageElement.style.display = 'block'; // Afficher le message\n}\n\nfunction getPieceSymbol(piece: PieceType, color: PieceColor): string {\n  switch (piece) {\n    case PieceType.PAWN:\n      return color === PieceColor.WHITE ? '♙' : '♟';\n    case PieceType.ROOK:\n      return color === PieceColor.WHITE ? '♖' : '♜';\n    case PieceType.KNIGHT:\n      return color === PieceColor.WHITE ? '♘' : '♞';\n    case PieceType.BISHOP:\n      return color === PieceColor.WHITE ? '♗' : '♝';\n    case PieceType.QUEEN:\n      return color === PieceColor.WHITE ? '♕' : '♛';\n    case PieceType.KING:\n      return color === PieceColor.WHITE ? '♔' : '♚';\n    default:\n      return '';\n  }\n}\n\nexport function updateCapturedPieces(piece: PieceType, color: PieceColor) {\n  const pieceSymbol = getPieceSymbol(piece, color);\n\n  if (color === PieceColor.WHITE) {\n    capturedWhite.push(pieceSymbol);\n  } else {\n    capturedBlack.push(pieceSymbol);\n  }\n\n  updateCapturedPiecesDOM();\n}\n\nexport function updateCapturedPiecesDOM() {\n  const capturedWhiteElement = document.getElementById('capturedWhite');\n  const capturedBlackElement = document.getElementById('capturedBlack');\n\n  if (capturedWhiteElement) {\n    capturedWhiteElement.textContent = capturedWhite.join(' ');\n  }\n  if (capturedBlackElement) {\n    capturedBlackElement.textContent = capturedBlack.join(' ');\n  }\n}\n","// src/board.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from './piece';\nimport { Rook } from './pieces/rook';\nimport { Knight } from './pieces/knight';\nimport { Bishop } from './pieces/bishop';\nimport { Queen } from './pieces/queen';\nimport { King } from './pieces/king';\nimport { Pawn } from './pieces/pawn';\nimport { updateCapturedPieces } from './utils';\n\ntype BoardSquare = Piece | null;\n\nexport class Board implements BoardInterface {\n  private grid: BoardSquare[][];\n  private enPassantTarget: { x: number; y: number } | null = null;\n  private halfMoveCount: number = 0; // Compteur pour la règle des 50 coups\n\n  constructor() {\n    this.grid = this.initializeBoard();\n  }\n\n  public initializeBoard(): BoardSquare[][] {\n    const board: BoardSquare[][] = Array(8)\n      .fill(null)\n      .map(() => Array(8).fill(null));\n\n    // Ajouter les pièces blanches\n    board[0] = [\n      new Rook(PieceColor.WHITE),\n      new Knight(PieceColor.WHITE),\n      new Bishop(PieceColor.WHITE),\n      new Queen(PieceColor.WHITE),\n      new King(PieceColor.WHITE),\n      new Bishop(PieceColor.WHITE),\n      new Knight(PieceColor.WHITE),\n      new Rook(PieceColor.WHITE),\n    ];\n    board[1] = Array(8)\n      .fill(null)\n      .map(() => new Pawn(PieceColor.WHITE));\n\n    // Ajouter les pièces noires\n    board[7] = [\n      new Rook(PieceColor.BLACK),\n      new Knight(PieceColor.BLACK),\n      new Bishop(PieceColor.BLACK),\n      new Queen(PieceColor.BLACK),\n      new King(PieceColor.BLACK),\n      new Bishop(PieceColor.BLACK),\n      new Knight(PieceColor.BLACK),\n      new Rook(PieceColor.BLACK),\n    ];\n    board[6] = Array(8)\n      .fill(null)\n      .map(() => new Pawn(PieceColor.BLACK));\n\n    return board;\n  }\n\n  // Méthode générale pour vérifier les limites\n  public isWithinBounds(x: number, y: number): boolean {\n    return x >= 0 && x < 8 && y >= 0 && y < 8;\n  }\n\n  public getPiece(x: number, y: number): BoardSquare {\n    return this.grid[y][x];\n  }\n\n  public getValidMoves(x: number, y: number): { x: number; y: number }[] {\n    let piece = null;\n    if (this.isWithinBounds(x, y)) piece = this.getPiece(x, y);\n    if (!piece) return [];\n\n    const validMoves: { x: number; y: number }[] = [];\n\n    for (let toY = 0; toY < 8; toY++) {\n      for (let toX = 0; toX < 8; toX++) {\n        if (piece.isValidMove(x, y, toX, toY, this)) {\n          validMoves.push({ x: toX, y: toY });\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  public getKingInCheck(): { x: number; y: number } | null {\n    if (this.isKingInCheck(PieceColor.WHITE)) {\n      return this.findKing(PieceColor.WHITE);\n    } else if (this.isKingInCheck(PieceColor.BLACK)) {\n      return this.findKing(PieceColor.BLACK);\n    }\n    return null;\n  }\n\n  public movePiece(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (!this.isWithinBounds(fromX, fromY) || !this.isWithinBounds(toX, toY)) {\n      return false; // Mouvement invalide en dehors des limites\n    }\n\n    const piece = this.getPiece(fromX, fromY);\n    if (piece && piece.isValidMove(fromX, fromY, toX, toY, this)) {\n      const targetPiece = this.getPiece(toX, toY);\n\n      // Empêche de capturer le roi ennemi\n      if (targetPiece && targetPiece.type === PieceType.KING) {\n        return false;\n      }\n\n      // Gestion du roque\n      if (piece instanceof King && Math.abs(toX - fromX) === 2) {\n        if (this.isCastlingValid(piece, fromX, fromY, toX)) {\n          this.handleCastling(toX, fromY); // Appelle handleCastling pour déplacer la tour\n        } else {\n          return false; // Roque invalide\n        }\n      }\n\n      // Gestion de la prise en passant\n      if (\n        piece instanceof Pawn &&\n        this.isEnPassantMove(fromX, fromY, toX, toY)\n      ) {\n        this.captureEnPassant(fromX, fromY, toX, toY); // Capture le pion en passant\n      }\n\n      // Sauvegarde l'état avant de simuler le mouvement\n      this.grid[toY][toX] = piece;\n      this.grid[fromY][fromX] = null;\n\n      // Vérifie si le mouvement met le roi du joueur en échec\n      if (this.isKingInCheck(piece.color)) {\n        // Annule le mouvement si le roi est en échec\n        this.grid[fromY][fromX] = piece;\n        this.grid[toY][toX] = targetPiece;\n        return false;\n      }\n\n      // Mise à jour de l'état après un mouvement valide\n      piece.hasMoved = true;\n      this.updateEnPassantTarget(fromX, fromY, toX, toY, piece);\n\n      // Réinitialise le compteur pour la règle des 50 coups si un pion bouge ou une capture a lieu\n      this.halfMoveCount =\n        piece.type === PieceType.PAWN || targetPiece\n          ? 0\n          : this.halfMoveCount + 1;\n\n      // Vérifie si le mouvement met l'adversaire en échec et mat\n      const opponentColor =\n        piece.color === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n      if (this.isCheckmate(opponentColor)) {\n        return true; // Partie terminée\n      }\n\n      return true;\n    }\n\n    return false; // Mouvement invalide\n  }\n\n  private isCastlingValid(\n    king: King,\n    fromX: number,\n    fromY: number,\n    toX: number,\n  ): boolean {\n    const direction = toX > fromX ? 1 : -1;\n    const rookX = toX > fromX ? 7 : 0;\n    const rook = this.getPiece(rookX, fromY);\n\n    if (!(rook instanceof Rook) || rook.hasMoved || king.hasMoved) return false;\n\n    for (let x = fromX + direction; x !== toX; x += direction) {\n      if (\n        this.getPiece(x, fromY) ||\n        this.isSquareUnderAttack(x, fromY, king.color)\n      ) {\n        return false;\n      }\n    }\n\n    return !this.isSquareUnderAttack(toX, fromY, king.color); // vérifier la case de destination\n  }\n\n  private handleCastling(kingX: number, kingY: number): void {\n    // Déplacement pour le petit roque (roi se déplace vers la droite)\n    if (kingX === 6) {\n      const rook = this.getPiece(7, kingY);\n      if (rook instanceof Rook) {\n        this.movePiece(7, kingY, 5, kingY);\n      }\n    }\n    // Déplacement pour le grand roque (roi se déplace vers la gauche)\n    else if (kingX === 2) {\n      const rook = this.getPiece(0, kingY);\n      if (rook instanceof Rook) {\n        this.movePiece(0, kingY, 3, kingY);\n      }\n    }\n  }\n\n  public updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    if (piece instanceof Pawn && Math.abs(toY - fromY) === 2 && fromX === toX) {\n      // Si le pion avance de deux cases, configure la cible pour la prise en passant\n      this.enPassantTarget = { x: toX, y: (fromY + toY) / 2 };\n    } else {\n      this.enPassantTarget = null;\n    }\n  }\n\n  public captureEnPassant(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): { capturedWhite: PieceType[]; capturedBlack: PieceType[] } | null {\n    const piece = this.getPiece(fromX, fromY);\n\n    if (this.isEnPassantMove(fromX, fromY, toX, toY) && piece instanceof Pawn) {\n      const direction = piece.color === PieceColor.WHITE ? -1 : 1;\n      const capturedPawnY = toY + direction;\n      const capturedPawn = this.getPiece(toX, capturedPawnY);\n\n      if (capturedPawn && capturedPawn.type === PieceType.PAWN) {\n        this.grid[capturedPawnY][toX] = null;\n\n        // Déclare explicitement le type de captureData pour éviter l'erreur\n        const captureData: {\n          capturedWhite: PieceType[];\n          capturedBlack: PieceType[];\n        } = {\n          capturedWhite: [],\n          capturedBlack: [],\n        };\n\n        if (capturedPawn.color === PieceColor.WHITE) {\n          captureData.capturedWhite.push(capturedPawn.type);\n        } else {\n          captureData.capturedBlack.push(capturedPawn.type);\n        }\n\n        // Appelle updateCapturedPieces pour mettre à jour le DOM\n        updateCapturedPieces(capturedPawn.type, capturedPawn.color);\n\n        return captureData;\n      }\n    }\n    return null;\n  }\n\n  public isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (!this.enPassantTarget) return false;\n\n    // Vérifie que le mouvement cible la bonne case pour la prise en passant\n    const piece = this.getPiece(fromX, fromY);\n    return (\n      piece instanceof Pawn &&\n      toX === this.enPassantTarget.x &&\n      toY === this.enPassantTarget.y &&\n      Math.abs(fromX - toX) === 1 &&\n      Math.abs(fromY - toY) === 1\n    );\n  }\n\n  public promotePawn(x: number, y: number, pieceType: string): void {\n    const color = this.getPiece(x, y)?.color;\n\n    if (!color) return;\n\n    switch (pieceType) {\n      case 'queen':\n        this.grid[y][x] = new Queen(color);\n        break;\n      case 'rook':\n        this.grid[y][x] = new Rook(color);\n        break;\n      case 'bishop':\n        this.grid[y][x] = new Bishop(color);\n        break;\n      case 'knight':\n        this.grid[y][x] = new Knight(color);\n        break;\n    }\n  }\n\n  public isKingInCheck(color: PieceColor): boolean {\n    const kingPosition = this.findKing(color);\n    if (!kingPosition) {\n      return false;\n    }\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(x, y, kingPosition.x, kingPosition.y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  public isCheckmate(color: PieceColor): boolean {\n    if (!this.isKingInCheck(color)) {\n      return false; // Pas de mat si le roi n'est pas en échec\n    }\n\n    // Parcourt chaque pièce de la couleur donnée pour trouver un mouvement légal\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          const moves = this.getValidMoves(x, y);\n\n          for (const move of moves) {\n            // Simule le mouvement\n            const originalPiece = this.getPiece(move.x, move.y);\n            this.grid[move.y][move.x] = piece;\n            this.grid[y][x] = null;\n\n            const kingSafe = !this.isKingInCheck(color);\n\n            // Annule le mouvement simulé\n            this.grid[y][x] = piece;\n            this.grid[move.y][move.x] = originalPiece;\n\n            if (kingSafe) {\n              return false; // Un mouvement légal existe pour sortir de l'échec\n            }\n          }\n        }\n      }\n    }\n\n    return true; // Aucun mouvement possible, échec et mat\n  }\n\n  public isStalemate(color: PieceColor): boolean {\n    // Pat uniquement si le roi n'est pas en échec et qu'il n'y a aucun coup légal disponible\n    if (this.isKingInCheck(color)) return false;\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          for (let toY = 0; toY < 8; toY++) {\n            for (let toX = 0; toX < 8; toX++) {\n              if (piece.isValidMove(x, y, toX, toY, this)) {\n                // Simuler le mouvement pour vérifier l'échec potentiel\n                const originalPiece = this.getPiece(toX, toY);\n                this.grid[toY][toX] = piece;\n                this.grid[y][x] = null;\n\n                const isKingSafe = !this.isKingInCheck(color);\n\n                // Annuler le mouvement simulé\n                this.grid[y][x] = piece;\n                this.grid[toY][toX] = originalPiece;\n\n                if (isKingSafe) return false; // Mouvement valide trouvé, pas de pat\n              }\n            }\n          }\n        }\n      }\n    }\n    return true; // Aucun coup légal trouvé, pat détecté\n  }\n\n  private findKing(color: PieceColor): { x: number; y: number } | null {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece instanceof King && piece.color === color) {\n          return { x, y };\n        }\n      }\n    }\n    return null;\n  }\n\n  public isSquareUnderAttack(x: number, y: number, color: PieceColor): boolean {\n    for (let fromY = 0; fromY < 8; fromY++) {\n      for (let fromX = 0; fromX < 8; fromX++) {\n        const piece = this.getPiece(fromX, fromY);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(fromX, fromY, x, y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Vérifie le matériel insuffisant pour un échec et mat\n  public isInsufficientMaterial(): boolean {\n    const pieces = this.grid.flat().filter((piece) => piece !== null);\n\n    // Cas les plus courants de matériel insuffisant\n    if (pieces.length <= 2) return true; // Seulement les rois sur le plateau\n    return (\n      pieces.length === 3 &&\n      pieces.some(\n        (piece) =>\n          piece?.type === PieceType.BISHOP || piece?.type === PieceType.KNIGHT,\n      )\n    );\n  }\n\n  // Vérifie si la règle des 50 coups est remplie\n  public isFiftyMoveRule(): boolean {\n    return this.halfMoveCount >= 50;\n  }\n\n  public setPiece(x: number, y: number, piece: Piece | null): void {\n    this.grid[y][x] = piece;\n  }\n\n  // Vérifie si un mouvement est valide\n  public isMoveValid(\n    fromRow: number,\n    fromCol: number,\n    toRow: number,\n    toCol: number,\n  ): boolean {\n    const piece = this.getPiece(fromRow, fromCol);\n\n    // Si aucune pièce n'est présente à l'emplacement source, le mouvement est invalide\n    if (!piece) {\n      return false;\n    }\n\n    // Si la destination est en dehors de l'échiquier, mouvement invalide\n    if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) {\n      return false;\n    }\n\n    // Vérifie si la pièce peut se déplacer à cette destination en utilisant la logique de mouvement de la pièce\n    if (!piece.isValidMove(fromRow, fromCol, toRow, toCol, this)) {\n      return false;\n    }\n\n    // Vérifie s'il y a une pièce à la destination et si elle est de la même couleur\n    const destinationPiece = this.getPiece(toRow, toCol);\n    return !(destinationPiece && destinationPiece.color === piece.color);\n  }\n\n  public isCapture(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    const piece = this.isWithinBounds(fromX, fromY)\n      ? this.getPiece(fromX, fromY)\n      : null;\n    const targetPiece = this.isWithinBounds(toX, toY)\n      ? this.getPiece(toX, toY)\n      : null;\n\n    // Vérifie qu'il y a une pièce à la position cible et qu'elle est d'une couleur opposée\n    return (\n      piece !== null &&\n      targetPiece !== null &&\n      piece.color !== targetPiece.color\n    );\n  }\n\n  public static async fromData(data: any): Promise<Board> {\n    const board = new Board();\n    board.grid = await Promise.all(\n      data.grid.map(async (row: any[]) =>\n        Promise.all(\n          row.map(async (pieceData) =>\n            pieceData ? await Piece.fromData(pieceData) : null,\n          ),\n        ),\n      ),\n    );\n    return board;\n  }\n\n  public toData(): any {\n    return {\n      grid: this.grid.map((row) =>\n        row.map((piece) => (piece ? piece.toData() : null)),\n      ),\n    };\n  }\n}\n","import { Board } from './board';\nimport { Piece, PieceColor, PieceType } from './piece';\n\n// Valeurs des pièces (évaluation de base)\nconst pieceValues: { [key in PieceType]: number } = {\n  [PieceType.PAWN]: 1,\n  [PieceType.KNIGHT]: 3,\n  [PieceType.BISHOP]: 3.25,\n  [PieceType.ROOK]: 5,\n  [PieceType.QUEEN]: 9,\n  [PieceType.KING]: 0,\n};\n\n// Tables de positions pour améliorer l'évaluation\nconst pieceSquareTables: { [key in PieceType]: number[][] } = {\n  [PieceType.PAWN]: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n    [0.1, 0.1, 0.2, 0.3, 0.3, 0.2, 0.1, 0.1],\n    [0.05, 0.05, 0.1, 0.25, 0.25, 0.1, 0.05, 0.05],\n    [0, 0, 0, 0.2, 0.2, 0, 0, 0],\n    [0.05, -0.05, -0.1, 0, 0, -0.1, -0.05, 0.05],\n    [0.05, 0.1, 0.1, -0.2, -0.2, 0.1, 0.1, 0.05],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n  ],\n  [PieceType.KNIGHT]: [\n    [-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5],\n    [-0.4, -0.2, 0, 0, 0, 0, -0.2, -0.4],\n    [-0.3, 0, 0.1, 0.15, 0.15, 0.1, 0, -0.3],\n    [-0.3, 0.05, 0.15, 0.2, 0.2, 0.15, 0.05, -0.3],\n    [-0.3, 0, 0.15, 0.2, 0.2, 0.15, 0, -0.3],\n    [-0.3, 0.05, 0.1, 0.15, 0.15, 0.1, 0.05, -0.3],\n    [-0.4, -0.2, 0, 0.05, 0.05, 0, -0.2, -0.4],\n    [-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5],\n  ],\n  [PieceType.BISHOP]: [\n    [-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2],\n    [-0.1, 0, 0, 0, 0, 0, 0, -0.1],\n    [-0.1, 0, 0.05, 0.1, 0.1, 0.05, 0, -0.1],\n    [-0.1, 0.05, 0.05, 0.1, 0.1, 0.05, 0.05, -0.1],\n    [-0.1, 0, 0.1, 0.1, 0.1, 0.1, 0, -0.1],\n    [-0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, -0.1],\n    [-0.1, 0.05, 0, 0, 0, 0, 0.05, -0.1],\n    [-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2],\n  ],\n  [PieceType.ROOK]: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [-0.05, 0, 0, 0, 0, 0, 0, -0.05],\n    [0, 0, 0, 0.05, 0.05, 0, 0, 0],\n  ],\n  [PieceType.QUEEN]: [\n    [-0.2, -0.1, -0.1, -0.05, -0.05, -0.1, -0.1, -0.2],\n    [-0.1, 0, 0, 0, 0, 0, 0, -0.1],\n    [-0.1, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.1],\n    [-0.05, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.05],\n    [0, 0, 0.05, 0.05, 0.05, 0.05, 0, -0.05],\n    [-0.1, 0.05, 0.05, 0.05, 0.05, 0.05, 0, -0.1],\n    [-0.1, 0, 0.05, 0, 0, 0, 0, -0.1],\n    [-0.2, -0.1, -0.1, -0.05, -0.05, -0.1, -0.1, -0.2],\n  ],\n  [PieceType.KING]: [\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3],\n    [-0.2, -0.3, -0.3, -0.4, -0.4, -0.3, -0.3, -0.2],\n    [-0.1, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.1],\n    [0.2, 0.2, 0, 0, 0, 0, 0.2, 0.2],\n    [0.2, 0.3, 0, 0, 0, 0, 0.3, 0.2],\n  ],\n};\n\n// Bonus pour le contrôle du centre du plateau (cases centrales plus précieuses)\nexport const centerControlBonus: { [key: string]: number } = {\n  '3,3': 0.5,\n  '3,4': 0.5,\n  '4,3': 0.5,\n  '4,4': 0.5, // Cases centrales\n  '2,3': 0.25,\n  '2,4': 0.25,\n  '3,2': 0.25,\n  '4,2': 0.25,\n  '4,5': 0.25,\n  '3,5': 0.25,\n  '5,3': 0.25,\n  '5,4': 0.25, // Cases autour\n};\n\n// Fonction d'évaluation principale\nexport function evaluateBoard(board: Board, color: PieceColor): number {\n  let score = 0;\n\n  for (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n      const piece = board.getPiece(x, y);\n      if (piece) {\n        let pieceScore = pieceValues[piece.type];\n\n        const pieceTable = pieceSquareTables[piece.type];\n        if (pieceTable) {\n          pieceScore += pieceTable[y][x];\n        }\n\n        const positionKey = `${x},${y}`;\n        if (centerControlBonus[positionKey]) {\n          pieceScore += centerControlBonus[positionKey];\n        }\n\n        if (piece.type === PieceType.PAWN) {\n          pieceScore += evaluatePawnStructure(board, x, y, piece.color);\n        }\n\n        if (\n          piece.type === PieceType.BISHOP &&\n          hasBishopPair(board, piece.color)\n        ) {\n          pieceScore += 0.5;\n        }\n\n        if (isKingExposed(board, x, y, piece.color)) {\n          pieceScore -= 0.5;\n        }\n\n        score += piece.color === color ? pieceScore : -pieceScore;\n      }\n    }\n  }\n\n  return score;\n}\n\n// Évaluer la structure des pions\nfunction evaluatePawnStructure(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  let score = 0;\n\n  // Vérifier les pions doublés et isolés avec une pénalité plus importante\n  score -= checkDoubledPawns(board, x, y, color) * 1.5; // Pénalité augmentée pour les pions doublés\n  score -= checkIsolatedPawns(board, x, y, color) * 1.5; // Pénalité augmentée pour les pions isolés\n\n  return score;\n}\n\nfunction checkDoubledPawns(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  for (let i = 0; i < 8; i++) {\n    if (\n      i !== y &&\n      board.getPiece(x, i)?.type === PieceType.PAWN &&\n      board.getPiece(x, i)?.color === color\n    ) {\n      return 0.5;\n    }\n  }\n  return 0;\n}\n\nfunction checkIsolatedPawns(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): number {\n  const leftColumn = x - 1 >= 0 ? board.getPiece(x - 1, y) : null;\n  const rightColumn = x + 1 < 8 ? board.getPiece(x + 1, y) : null;\n\n  if (\n    (!leftColumn ||\n      leftColumn.type !== PieceType.PAWN ||\n      leftColumn.color !== color) &&\n    (!rightColumn ||\n      rightColumn.type !== PieceType.PAWN ||\n      rightColumn.color !== color)\n  ) {\n    return 1.5; // Augmentation de la pénalité pour les pions isolés\n  }\n\n  return 0;\n}\n\nfunction hasBishopPair(board: Board, color: PieceColor): boolean {\n  const bishops = getPieces(board, color).filter(\n    (piece) => piece.type === PieceType.BISHOP,\n  );\n  return bishops.length === 2;\n}\n\nfunction isKingExposed(\n  board: Board,\n  x: number,\n  y: number,\n  color: PieceColor,\n): boolean {\n  const piece = board.getPiece(x, y);\n  if (piece && piece.type === PieceType.KING) {\n    const surroundingSquares = [\n      { dx: -1, dy: 0 },\n      { dx: 1, dy: 0 },\n      { dx: 0, dy: -1 },\n      { dx: 0, dy: 1 },\n    ];\n\n    return surroundingSquares.some(({ dx, dy }) => {\n      const newX = x + dx;\n      const newY = y + dy;\n\n      // Utilise `isWithinBounds` pour vérifier que les coordonnées sont valides avant d'accéder à la pièce\n      if (board.isWithinBounds(newX, newY)) {\n        const adjPiece = board.getPiece(newX, newY);\n        return (\n          !adjPiece ||\n          adjPiece.color !== color ||\n          adjPiece.type === PieceType.KING\n        );\n      }\n\n      // Si la case est hors des limites, considère que le roi est exposé\n      return true;\n    });\n  }\n  return false;\n}\n\n// Nouvelle méthode pour obtenir toutes les pièces d'une certaine couleur sur le plateau\nexport function getPieces(board: Board, color: PieceColor): Piece[] {\n  const pieces: Piece[] = [];\n\n  for (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n      const piece = board.getPiece(x, y);\n      if (piece && piece.color === color) {\n        pieces.push(piece);\n      }\n    }\n  }\n\n  return pieces;\n}\n","import { Board } from './board';\nimport { PieceColor } from './piece';\nimport { evaluateBoard, centerControlBonus } from './evaluator';\n\n// Classe AI utilisant l'algorithme Minimax avec Alpha-Beta Pruning et Transposition Table\nexport class AI {\n  private transpositionTable: Map<string, number>; // Table de transposition\n  private readonly maxTime: number; // Temps maximum de réflexion en millisecondes\n  private startTime: number; // Temps de début pour gestion du temps\n  private readonly killerMoves: {\n    [depth: number]: {\n      fromX: number;\n      fromY: number;\n      toX: number;\n      toY: number;\n    }[];\n  }; // Heuristic des coups efficaces\n\n  constructor(\n    private color: PieceColor,\n    maxTime: number = 5000,\n  ) {\n    this.transpositionTable = new Map();\n    this.maxTime = maxTime;\n    this.killerMoves = {};\n    this.startTime = 0;\n  }\n\n  // Méthode principale pour faire un mouvement\n  public makeMove(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number } | null {\n    let bestMove = null;\n    let bestValue = -Infinity;\n    const maxDepth = 7; // Augmentation de la profondeur maximale de recherche\n    this.startTime = Date.now();\n\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      let moves = this.getAllValidMoves(board);\n\n      // Trie les mouvements pour optimiser la recherche\n      moves = this.sortMoves(moves, board, depth);\n\n      for (const move of moves) {\n        const piece = board.getPiece(move.fromX, move.fromY);\n        const originalPiece = board.getPiece(move.toX, move.toY);\n        board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n        // Appelle la recherche Minimax avec Alpha-Beta Pruning\n        const boardValue = this.minimax(\n          board,\n          depth - 1,\n          -Infinity,\n          Infinity,\n          false,\n        );\n\n        board.setPiece(move.fromX, move.fromY, piece);\n        board.setPiece(move.toX, move.toY, originalPiece);\n\n        if (boardValue > bestValue) {\n          bestValue = boardValue;\n          bestMove = move;\n        }\n\n        // Limite le temps de réflexion\n        if (Date.now() - this.startTime > this.maxTime) {\n          break;\n        }\n      }\n\n      // Limite le temps de réflexion\n      if (Date.now() - this.startTime > this.maxTime) {\n        break;\n      }\n    }\n\n    return bestMove;\n  }\n\n  // Fonction Minimax avec Alpha-Beta Pruning et table de transposition\n  private minimax(\n    board: Board,\n    depth: number,\n    alpha: number,\n    beta: number,\n    isMaximizing: boolean,\n  ): number {\n    const boardKey = board.toString();\n\n    if (Date.now() - this.startTime > this.maxTime) {\n      return evaluateBoard(board, this.color);\n    }\n\n    if (this.transpositionTable.has(boardKey)) {\n      return this.transpositionTable.get(boardKey)!;\n    }\n\n    if (\n      depth === 0 ||\n      board.isCheckmate(this.color) ||\n      board.isCheckmate(this.getOpponentColor()) ||\n      Date.now() - this.startTime > this.maxTime\n    ) {\n      const evaluation = this.quiescenceSearch(board, alpha, beta);\n      this.transpositionTable.set(boardKey, evaluation);\n      return evaluation;\n    }\n\n    if (\n      board.isKingInCheck(this.color) &&\n      this.getAllValidMoves(board).length === 0\n    ) {\n      return -Infinity;\n    }\n\n    if (isMaximizing) {\n      let maxEval = -Infinity;\n      let moves = this.getAllValidMoves(board);\n      moves = this.sortMoves(moves, board, depth);\n\n      for (const move of moves) {\n        const fromPiece = board.getPiece(move.fromX, move.fromY);\n        const toPiece = board.getPiece(move.toX, move.toY);\n\n        board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n        const evaluation = this.minimax(board, depth - 1, alpha, beta, false);\n\n        board.setPiece(move.fromX, move.fromY, fromPiece);\n        board.setPiece(move.toX, move.toY, toPiece);\n\n        maxEval = Math.max(maxEval, evaluation);\n        alpha = Math.max(alpha, evaluation);\n\n        if (beta <= alpha) {\n          this.addKillerMove(depth, move);\n          break;\n        }\n      }\n\n      this.transpositionTable.set(boardKey, maxEval);\n      return maxEval;\n    } else {\n      let minEval = Infinity;\n      let moves = this.getAllValidMoves(board);\n      moves = this.sortMoves(moves, board, depth);\n\n      for (const move of moves) {\n        const fromPiece = board.getPiece(move.fromX, move.fromY);\n        const toPiece = board.getPiece(move.toX, move.toY);\n\n        board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n        const evaluation = this.minimax(board, depth - 1, alpha, beta, true);\n\n        board.setPiece(move.fromX, move.fromY, fromPiece);\n        board.setPiece(move.toX, move.toY, toPiece);\n\n        minEval = Math.min(minEval, evaluation);\n        beta = Math.min(beta, evaluation);\n\n        if (beta <= alpha) {\n          this.addKillerMove(depth, move);\n          break;\n        }\n      }\n\n      this.transpositionTable.set(boardKey, minEval);\n      return minEval;\n    }\n  }\n\n  // Ajout d'un coup prometteur dans les killer moves\n  private addKillerMove(\n    depth: number,\n    move: { fromX: number; fromY: number; toX: number; toY: number },\n  ) {\n    if (!this.killerMoves[depth]) {\n      this.killerMoves[depth] = [];\n    }\n    this.killerMoves[depth].push(move);\n  }\n\n  // Recherche de quiescence pour améliorer l'évaluation des positions\n  private quiescenceSearch(\n    board: Board,\n    alpha: number,\n    beta: number,\n    depth: number = 0,\n  ): number {\n    const maxQuiescenceDepth = 10; // Définissez une profondeur maximale pour la recherche de quiescence\n\n    // Condition de sortie basée sur la profondeur maximale\n    if (depth >= maxQuiescenceDepth) {\n      return evaluateBoard(board, this.color);\n    }\n\n    const standPat = evaluateBoard(board, this.color);\n\n    if (standPat >= beta) return beta;\n    if (alpha < standPat) alpha = standPat;\n\n    const moves = this.getAllValidMoves(board).filter((move) =>\n      board.isCapture(move.fromX, move.fromY, move.toX, move.toY),\n    );\n\n    for (const move of moves) {\n      const fromPiece = board.getPiece(move.fromX, move.fromY);\n      const toPiece = board.getPiece(move.toX, move.toY);\n\n      board.movePiece(move.fromX, move.fromY, move.toX, move.toY);\n\n      // Vérifiez si le roi est en sécurité après le mouvement\n      const kingSafe = !board.isKingInCheck(this.color);\n      if (kingSafe) {\n        const score = -this.quiescenceSearch(board, -beta, -alpha, depth + 1);\n\n        board.setPiece(move.fromX, move.fromY, fromPiece);\n        board.setPiece(move.toX, move.toY, toPiece);\n\n        if (score >= beta) return beta;\n        if (score > alpha) alpha = score;\n      } else {\n        // Annuler le mouvement si le roi est en échec\n        board.setPiece(move.fromX, move.fromY, fromPiece);\n        board.setPiece(move.toX, move.toY, toPiece);\n      }\n    }\n\n    return alpha;\n  }\n\n  private getOpponentColor(): PieceColor {\n    return this.color === PieceColor.WHITE\n      ? PieceColor.BLACK\n      : PieceColor.WHITE;\n  }\n\n  private getAllValidMoves(\n    board: Board,\n  ): { fromX: number; fromY: number; toX: number; toY: number }[] {\n    const validMoves = [];\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = board.getPiece(x, y);\n\n        if (piece && piece.color === this.color) {\n          const moves = board.getValidMoves(x, y);\n\n          for (const move of moves) {\n            if (board.isMoveValid(x, y, move.x, move.y)) {\n              const originalPiece = board.getPiece(move.x, move.y);\n              board.setPiece(move.x, move.y, piece);\n              board.setPiece(x, y, null);\n\n              const kingSafe = !board.isKingInCheck(this.color);\n\n              board.setPiece(x, y, piece);\n              board.setPiece(move.x, move.y, originalPiece);\n\n              if (kingSafe) {\n                validMoves.push({\n                  fromX: x,\n                  fromY: y,\n                  toX: move.x,\n                  toY: move.y,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  private sortMoves(\n    moves: { fromX: number; fromY: number; toX: number; toY: number }[],\n    board: Board,\n    depth: number,\n  ): {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n  }[] {\n    return moves.sort((a, b) => {\n      if (\n        this.killerMoves[depth] &&\n        this.killerMoves[depth].some(\n          (move) => move.fromX === a.fromX && move.fromY === a.fromY,\n        )\n      )\n        return -1;\n\n      const pieceA = board.getPiece(a.toX, a.toY);\n      const pieceB = board.getPiece(b.toX, b.toY);\n\n      if (pieceA && !pieceB) return -1;\n      if (!pieceA && pieceB) return 1;\n\n      const centerControlA = centerControlBonus[`${a.toX},${a.toY}`] || 0;\n      const centerControlB = centerControlBonus[`${b.toX},${b.toY}`] || 0;\n\n      return centerControlB - centerControlA;\n    });\n  }\n}\n","// ai.worker.ts\nimport { Board } from './board';\nimport { AI } from './ai';\nimport { PieceColor, PieceType } from './piece';\n\nconst ai = new AI(PieceColor.BLACK);\n\nself.onmessage = async (event) => {\n  const { boardData } = event.data;\n  const board = await Board.fromData(boardData);\n\n  const bestMove = ai.makeMove(board);\n\n  // Définit explicitement le type de captureData\n  let captureData: {\n    capturedWhite: PieceType[];\n    capturedBlack: PieceType[];\n  } | null = null;\n\n  if (\n    bestMove &&\n    board.isCapture(bestMove.fromX, bestMove.fromY, bestMove.toX, bestMove.toY)\n  ) {\n    const targetPiece = board.getPiece(bestMove.toX, bestMove.toY);\n    if (targetPiece) {\n      captureData = {\n        capturedWhite: [],\n        capturedBlack: [],\n      };\n      // Remplissage du tableau de capture selon la couleur de la pièce capturée\n      if (targetPiece.color === PieceColor.WHITE) {\n        captureData.capturedWhite.push(targetPiece.type);\n      } else {\n        captureData.capturedBlack.push(targetPiece.type);\n      }\n    }\n  }\n\n  self.postMessage({ bestMove, captureData });\n};\n"],"names":["createPiece","type","color","PieceType","Pawn","Rook","Knight","Bishop","Queen","King","PieceColor","Piece","fromX","fromY","toX","toY","board","dx","dy","x","y","targetPiece","data","rook","direction","rookX","startRow","distanceY","distanceX","promotionDialog","pieceType","capturedWhite","capturedBlack","getPieceSymbol","piece","updateCapturedPieces","pieceSymbol","updateCapturedPiecesDOM","capturedWhiteElement","capturedBlackElement","Board","validMoves","opponentColor","king","kingX","kingY","capturedPawnY","capturedPawn","captureData","kingPosition","moves","move","originalPiece","kingSafe","isKingSafe","pieces","fromRow","fromCol","toRow","toCol","destinationPiece","row","pieceData","pieceValues","pieceSquareTables","centerControlBonus","evaluateBoard","score","pieceScore","pieceTable","positionKey","evaluatePawnStructure","hasBishopPair","isKingExposed","checkDoubledPawns","checkIsolatedPawns","i","leftColumn","rightColumn","getPieces","newX","newY","adjPiece","AI","maxTime","bestMove","bestValue","maxDepth","depth","boardValue","alpha","beta","isMaximizing","boardKey","evaluation","maxEval","fromPiece","toPiece","minEval","standPat","a","b","pieceA","pieceB","centerControlA","ai","event","boardData"],"mappings":"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"}