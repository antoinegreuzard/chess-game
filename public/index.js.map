{"version":3,"file":"index.js","sources":["../src/piece.ts","../src/rook.ts","../src/king.ts","../src/knight.ts","../src/bishop.ts","../src/queen.ts","../src/pawn.ts","../src/board.ts","../src/game.ts","../src/canvas-renderer.ts","../src/timer.ts","../src/index.ts"],"sourcesContent":["// src/piece.ts\nimport { Board } from './board';\n\nexport enum PieceColor {\n  WHITE = 'white',\n  BLACK = 'black',\n}\n\nexport enum PieceType {\n  PAWN = 'pawn',\n  ROOK = 'rook',\n  KNIGHT = 'knight',\n  BISHOP = 'bishop',\n  QUEEN = 'queen',\n  KING = 'king',\n}\n\nexport abstract class Piece {\n  protected constructor(\n    public color: PieceColor,\n    public type: PieceType,\n  ) {}\n\n  // Mise à jour pour inclure le paramètre 'board'\n  abstract isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean;\n\n  // Vérifie si le chemin est dégagé pour certaines pièces\n  protected isPathClear(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    const dx = Math.sign(toX - fromX);\n    const dy = Math.sign(toY - fromY);\n\n    let x = fromX + dx;\n    let y = fromY + dy;\n\n    while (x !== toX || y !== toY) {\n      if (board.getPiece(x, y)) return false;\n      x += dx;\n      y += dy;\n    }\n\n    return true;\n  }\n\n  // Vérifie si une pièce peut capturer une autre\n  protected canCapture(toX: number, toY: number, board: Board): boolean {\n    const targetPiece = board.getPiece(toX, toY);\n    return targetPiece !== null && targetPiece.color !== this.color;\n  }\n}\n","// src/rook.ts\nimport { Piece, PieceColor, PieceType } from './piece';\nimport { Board } from './board';\n\nexport class Rook extends Piece {\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.ROOK);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    // Vérifie si le mouvement est en ligne droite et que le chemin est dégagé\n    if (\n      (fromX === toX || fromY === toY) &&\n      this.isPathClear(fromX, fromY, toX, toY, board)\n    ) {\n      // Vérifie si la case cible est vide ou contient une pièce ennemie\n      const targetPiece = board.getPiece(toX, toY);\n      return targetPiece === null || this.canCapture(toX, toY, board);\n    }\n    return false;\n  }\n}\n","// src/king.ts\nimport { Piece, PieceColor, PieceType } from './piece';\nimport { Board } from './board';\nimport { Rook } from './rook';\n\nexport class King extends Piece {\n  public hasMoved: boolean = false;\n\n  constructor(color: PieceColor) {\n    super(color, PieceType.KING);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n\n    // Le Roi se déplace d'une case dans n'importe quelle direction\n    if (dx <= 1 && dy <= 1) {\n      // Vérifie que la case cible n'est pas occupée par un roi adverse\n      const targetPiece = board.getPiece(toX, toY);\n      return !(targetPiece && targetPiece.type === PieceType.KING);\n    }\n\n    // Logique pour le roque\n    if (!this.hasMoved && dy === 0 && dx === 2) {\n      const direction = toX > fromX ? 1 : -1;\n      const rookX = toX > fromX ? 7 : 0;\n      const rook = board.getPiece(rookX, fromY);\n\n      if (rook && rook instanceof Rook && !rook.hasMoved) {\n        // Vérifie que les cases entre le roi et la tour sont libres\n        for (let x = fromX + direction; x !== rookX; x += direction) {\n          if (board.getPiece(x, fromY)) return false;\n        }\n\n        // Assure que le roi n'est pas en échec avant, pendant ou après le roque\n        if (!board.isKingInCheck(this.color)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n","// src/knight.ts\nimport { Piece, PieceColor, PieceType } from './piece';\n\nexport class Knight extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.KNIGHT);\n  }\n\n  isValidMove(fromX: number, fromY: number, toX: number, toY: number): boolean {\n    // Le Cavalier se déplace en L : 2 cases dans une direction puis 1 case perpendiculairement\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n    return (dx === 2 && dy === 1) || (dx === 1 && dy === 2);\n  }\n}\n","// src/bishop.ts\nimport { Piece, PieceColor, PieceType } from './piece';\nimport { Board } from './board';\n\nexport class Bishop extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.BISHOP);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    if (Math.abs(toX - fromX) === Math.abs(toY - fromY)) {\n      return this.isPathClear(fromX, fromY, toX, toY, board);\n    }\n    return false;\n  }\n}\n","// src/queen.ts\nimport { Piece, PieceColor, PieceType } from './piece';\nimport { Board } from './board';\n\nexport class Queen extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.QUEEN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    if (\n      fromX === toX ||\n      fromY === toY ||\n      Math.abs(toX - fromX) === Math.abs(toY - fromY)\n    ) {\n      return this.isPathClear(fromX, fromY, toX, toY, board);\n    }\n    return false;\n  }\n}\n","// src/pawn.ts\nimport { Piece, PieceColor, PieceType } from './piece';\nimport { Board } from './board';\n\nexport class Pawn extends Piece {\n  constructor(color: PieceColor) {\n    super(color, PieceType.PAWN);\n  }\n\n  isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: Board,\n  ): boolean {\n    // Corrige la direction : 1 pour les blancs, -1 pour les noirs\n    const direction = this.color === PieceColor.WHITE ? 1 : -1; // Inverser la logique\n    const startRow = this.color === PieceColor.WHITE ? 1 : 6; // Ajuster la ligne de départ pour correspondre à la direction\n    const distanceY = (toY - fromY) * direction; // Déplacement vertical en tenant compte de la couleur\n    const distanceX = Math.abs(toX - fromX); // Déplacement horizontal\n\n    // 1. Déplacement d'une case vers l'avant\n    if (distanceX === 0 && distanceY === 1) {\n      if (!board.getPiece(toX, toY)) {\n        return true;\n      }\n    }\n\n    // 2. Déplacement de deux cases vers l'avant depuis la ligne de départ\n    if (distanceX === 0 && distanceY === 2 && fromY === startRow) {\n      if (\n        !board.getPiece(toX, toY) &&\n        !board.getPiece(fromX, fromY + direction)\n      ) {\n        return true;\n      }\n    }\n\n    // 3. Capture en diagonale\n    if (distanceX === 1 && distanceY === 1) {\n      const targetPiece = board.getPiece(toX, toY);\n      if (targetPiece && targetPiece.color !== this.color) {\n        return true;\n      }\n    }\n\n    // Si aucune condition n'est remplie, le mouvement est invalide\n    return false;\n  }\n}\n","// src/board.ts\nimport { Piece, PieceColor, PieceType } from './piece';\nimport { King } from './king';\nimport { Rook } from './rook';\nimport { Knight } from './knight';\nimport { Bishop } from './bishop';\nimport { Queen } from './queen';\nimport { Pawn } from './pawn';\n\ntype BoardSquare = Piece | null;\n\nexport class Board {\n  private readonly grid: BoardSquare[][];\n\n  constructor() {\n    this.grid = this.initializeBoard();\n  }\n\n  private initializeBoard(): BoardSquare[][] {\n    const board: BoardSquare[][] = Array(8)\n      .fill(null)\n      .map(() => Array(8).fill(null));\n\n    // Ajouter les pièces blanches\n    board[0] = [\n      new Rook(PieceColor.WHITE),\n      new Knight(PieceColor.WHITE),\n      new Bishop(PieceColor.WHITE),\n      new Queen(PieceColor.WHITE),\n      new King(PieceColor.WHITE),\n      new Bishop(PieceColor.WHITE),\n      new Knight(PieceColor.WHITE),\n      new Rook(PieceColor.WHITE),\n    ];\n    board[1] = Array(8)\n      .fill(null)\n      .map(() => new Pawn(PieceColor.WHITE));\n\n    // Ajouter les pièces noires\n    board[7] = [\n      new Rook(PieceColor.BLACK),\n      new Knight(PieceColor.BLACK),\n      new Bishop(PieceColor.BLACK),\n      new Queen(PieceColor.BLACK),\n      new King(PieceColor.BLACK),\n      new Bishop(PieceColor.BLACK),\n      new Knight(PieceColor.BLACK),\n      new Rook(PieceColor.BLACK),\n    ];\n    board[6] = Array(8)\n      .fill(null)\n      .map(() => new Pawn(PieceColor.BLACK));\n\n    return board;\n  }\n\n  // Récupérer une pièce à une position spécifique\n  public getPiece(x: number, y: number): BoardSquare {\n    return this.grid[y][x];\n  }\n\n  // Déplacer une pièce sur l'échiquier (capture incluse)\n  public movePiece(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    const piece = this.getPiece(fromX, fromY);\n\n    if (piece && piece.isValidMove(fromX, fromY, toX, toY, this)) {\n      // Interdit de capturer le roi\n      const targetPiece = this.getPiece(toX, toY);\n      if (targetPiece && targetPiece.type === PieceType.KING) {\n        return false; // Mouvement invalide si la cible est un roi\n      }\n\n      // Capturer la pièce adverse si présente\n      if (targetPiece && targetPiece.color !== piece.color) {\n        this.grid[toY][toX] = null; // Capture de la pièce\n      }\n\n      // Déplace la pièce\n      this.grid[toY][toX] = piece;\n      this.grid[fromY][fromX] = null;\n\n      // Met à jour l'état du roi et des tours pour le roque\n      if (piece instanceof King) {\n        piece.hasMoved = true;\n        // Roque\n        if (Math.abs(toX - fromX) === 2) {\n          this.handleCastling(toX, toY);\n        }\n      } else if (piece instanceof Rook) {\n        piece.hasMoved = true;\n      }\n\n      return true;\n    }\n    return false;\n  }\n\n  // Gérer le roque (déplacement de la tour)\n  private handleCastling(kingX: number, kingY: number): void {\n    // Si le roi se déplace de 2 cases (roque), déplace la tour correspondante\n    if (kingX === 6) {\n      // Roque du côté roi\n      const rook = this.getPiece(7, kingY);\n      if (rook instanceof Rook) {\n        this.grid[5][kingY] = rook;\n        this.grid[7][kingY] = null;\n      }\n    } else if (kingX === 2) {\n      // Roque du côté dame\n      const rook = this.getPiece(0, kingY);\n      if (rook instanceof Rook) {\n        this.grid[3][kingY] = rook;\n        this.grid[0][kingY] = null;\n      }\n    }\n  }\n\n  // Vérifie si le Roi de la couleur donnée est en échec\n  public isKingInCheck(color: PieceColor): boolean {\n    const kingPosition = this.findKing(color);\n    if (!kingPosition) return false;\n\n    // Parcourt toutes les pièces adverses pour voir si elles peuvent atteindre le Roi\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(x, y, kingPosition.x, kingPosition.y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Vérifie si le Roi est en échec et mat\n  public isCheckmate(color: PieceColor): boolean {\n    if (!this.isKingInCheck(color)) {\n      return false;\n    }\n\n    // Parcourt toutes les pièces du joueur\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          // Essaye chaque mouvement possible pour voir si l'échec peut être évité\n          for (let toY = 0; toY < 8; toY++) {\n            for (let toX = 0; toX < 8; toX++) {\n              if (piece.isValidMove(x, y, toX, toY, this)) {\n                // Sauvegarde l'état actuel de l'échiquier\n                const originalPiece = this.getPiece(toX, toY);\n                this.grid[toY][toX] = piece;\n                this.grid[y][x] = null;\n\n                const kingSafe = !this.isKingInCheck(color);\n\n                // Restaure l'état initial de l'échiquier\n                this.grid[y][x] = piece;\n                this.grid[toY][toX] = originalPiece;\n\n                if (kingSafe) {\n                  return false; // Si un mouvement légal est trouvé, pas d'échec et mat\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return true; // Si aucun mouvement légal n'est trouvé, c'est un échec et mat\n  }\n\n  // Trouve la position du roi d'une couleur spécifique\n  private findKing(color: PieceColor): { x: number; y: number } | null {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece instanceof King && piece.color === color) {\n          return { x, y };\n        }\n      }\n    }\n    return null;\n  }\n}\n","// src/game.ts\nimport { Board } from './board';\n\nexport class Game {\n  private readonly board: Board;\n\n  constructor() {\n    this.board = new Board();\n  }\n\n  // Commencer une nouvelle partie (initialisation de la logique du jeu)\n  public start(): void {\n    console.log(\"Nouvelle partie d'échecs démarrée !\");\n  }\n\n  // Retourner l'état actuel de l'échiquier\n  public getBoard(): Board {\n    return this.board;\n  }\n}\n","// src/canvas-renderer.ts\nimport { Board } from './board';\nimport { Piece, PieceColor } from './piece';\n\nexport class CanvasRenderer {\n  private canvas: HTMLCanvasElement;\n  private context: CanvasRenderingContext2D;\n  private readonly tileSize: number;\n  private selectedPiece: { x: number; y: number } | null = null;\n\n  constructor(\n    private board: Board,\n    canvasId: string,\n    private moveHandler: (\n      fromX: number,\n      fromY: number,\n      toX: number,\n      toY: number,\n    ) => void,\n  ) {\n    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    this.context = this.canvas.getContext('2d')!;\n    this.tileSize = this.canvas.width / 8;\n\n    // Ajouter un écouteur pour gérer les clics de la souris\n    this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));\n  }\n\n  // Dessiner l'échiquier et les pièces\n  public drawBoard(): void {\n    this.drawTiles();\n    this.drawPieces();\n  }\n\n  // Dessiner les cases de l'échiquier\n  private drawTiles(): void {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const isDarkTile = (x + y) % 2 === 1;\n        this.context.fillStyle = isDarkTile ? '#769656' : '#eeeed2';\n        this.context.fillRect(\n          x * this.tileSize,\n          y * this.tileSize,\n          this.tileSize,\n          this.tileSize,\n        );\n      }\n    }\n  }\n\n  // Dessiner toutes les pièces sur l'échiquier\n  private drawPieces(): void {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.board.getPiece(x, y);\n        if (piece) {\n          this.drawPiece(piece, x, y);\n        }\n      }\n    }\n  }\n\n  // Dessiner une pièce spécifique\n  private drawPiece(piece: Piece, x: number, y: number): void {\n    this.context.fillStyle = piece.color === 'white' ? 'white' : 'black';\n    this.context.font = '48px Arial';\n    this.context.textAlign = 'center';\n    this.context.textBaseline = 'middle';\n    const pieceText = this.getPieceText(piece);\n    this.context.fillText(\n      pieceText,\n      x * this.tileSize + this.tileSize / 2,\n      y * this.tileSize + this.tileSize / 2,\n    );\n  }\n\n  // Convertir le type de pièce en texte pour affichage\n  private getPieceText(piece: Piece): string {\n    switch (piece.type) {\n      case 'pawn':\n        return piece.color === 'white' ? '♙' : '♟';\n      case 'rook':\n        return piece.color === 'white' ? '♖' : '♜';\n      case 'knight':\n        return piece.color === 'white' ? '♘' : '♞';\n      case 'bishop':\n        return piece.color === 'white' ? '♗' : '♝';\n      case 'queen':\n        return piece.color === 'white' ? '♕' : '♛';\n      case 'king':\n        return piece.color === 'white' ? '♔' : '♚';\n      default:\n        return '';\n    }\n  }\n\n  // Animation pour déplacer une pièce\n  animateMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    const frames = 10;\n    let currentFrame = 0;\n\n    const startX = fromX * this.tileSize;\n    const startY = fromY * this.tileSize;\n    const deltaX = ((toX - fromX) * this.tileSize) / frames;\n    const deltaY = ((toY - fromY) * this.tileSize) / frames;\n\n    const animate = () => {\n      if (currentFrame <= frames) {\n        this.drawBoard();\n        this.context.fillStyle =\n          piece.color === PieceColor.WHITE ? 'white' : 'black';\n        this.context.font = '48px Arial';\n        this.context.textAlign = 'center';\n        this.context.textBaseline = 'middle';\n\n        // Dessiner la pièce en mouvement\n        this.context.fillText(\n          this.getPieceText(piece),\n          startX + deltaX * currentFrame + this.tileSize / 2,\n          startY + deltaY * currentFrame + this.tileSize / 2,\n        );\n\n        currentFrame++;\n        requestAnimationFrame(animate);\n      } else {\n        // Redessiner la grille finale\n        this.drawBoard();\n      }\n    };\n\n    animate();\n  }\n\n  // Gérer les clics sur le canevas pour déplacer les pièces\n  private handleCanvasClick(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    if (this.selectedPiece) {\n      // Si une pièce est déjà sélectionnée, tente de la déplacer\n      const fromX = this.selectedPiece.x;\n      const fromY = this.selectedPiece.y;\n\n      // Utilise la fonction de rappel `moveHandler` pour déplacer la pièce\n      this.moveHandler(fromX, fromY, x, y);\n\n      this.selectedPiece = null;\n    } else {\n      // Sélectionne une nouvelle pièce\n      this.selectedPiece = { x, y };\n    }\n  }\n}\n","// src/timer.ts\nexport class Timer {\n  private intervalId: number | null = null;\n  private currentTime: number;\n  private readonly onTimeUpdate: (timeLeft: number) => void;\n\n  constructor(\n    private initialTime: number,\n    onTimeUpdate: (timeLeft: number) => void,\n  ) {\n    this.currentTime = initialTime;\n    this.onTimeUpdate = onTimeUpdate;\n  }\n\n  // Démarrer le compte à rebours\n  public start(): void {\n    this.intervalId = window.setInterval(() => {\n      this.currentTime--;\n      this.onTimeUpdate(this.currentTime);\n\n      if (this.currentTime <= 0) {\n        this.stop();\n      }\n    }, 1000);\n  }\n\n  // Arrêter le compte à rebours\n  public stop(): void {\n    if (this.intervalId !== null) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n  }\n\n  // Réinitialiser le temps\n  public reset(time: number): void {\n    this.stop();\n    this.currentTime = time;\n    this.start();\n  }\n}\n","// src/index.ts\nimport { Game } from './game';\nimport { CanvasRenderer } from './canvas-renderer';\nimport { Timer } from './timer';\nimport { PieceColor, PieceType } from './piece';\n\nconst game = new Game();\nconst board = game.getBoard();\nconst moveHistoryElement = document.getElementById('moveHistory')!;\nconst currentTurnElement = document.getElementById('currentTurn')!;\nconst timerElement = document.getElementById('timer')!;\nconst capturedWhiteElement = document.getElementById('capturedWhite')!;\nconst capturedBlackElement = document.getElementById('capturedBlack')!;\nconst passTurnButton = document.getElementById('passTurnButton')!;\nconst gameMessageElement = document.getElementById('gameMessage')!;\nconst replayButton = document.getElementById('replayButton')!;\n\nlet currentPlayer: PieceColor = PieceColor.WHITE; // Les blancs commencent toujours\nlet gameState: 'playing' | 'waiting' = 'playing'; // Contrôle du statut de jeu\nlet hasMoved: boolean = false; // Indique si un mouvement a déjà été effectué dans ce tour\nlet capturedWhite: string[] = []; // Liste des pièces capturées par les Blancs\nlet capturedBlack: string[] = []; // Liste des pièces capturées par les Noirs\n\n// Initialiser le timer avec 60 secondes pour chaque joueur\nlet whiteTimer = new Timer(60, (timeLeft) =>\n  updateTimerDisplay(timeLeft, PieceColor.WHITE),\n);\nlet blackTimer = new Timer(60, (timeLeft) =>\n  updateTimerDisplay(timeLeft, PieceColor.BLACK),\n);\n\n// Fonction pour mettre à jour l'affichage du timer\nfunction updateTimerDisplay(timeLeft: number, color: PieceColor) {\n  if (color === currentPlayer) {\n    timerElement.textContent = `Temps restant: ${timeLeft}s`;\n    if (timeLeft <= 0) {\n      showMessage(\n        `${currentPlayer === PieceColor.WHITE ? 'Noir' : 'Blanc'} gagne par temps écoulé !`,\n      );\n      endGame();\n    }\n  }\n}\n\n// Démarrer le jeu et dessiner le plateau\nconst renderer = new CanvasRenderer(board, 'chessBoard', handleMove); // Passe handleMove comme callback\nrenderer.drawBoard();\nwhiteTimer.start(); // Démarre le timer pour les blancs au début\n\n// Fonction pour terminer la partie\nfunction endGame() {\n  whiteTimer.stop();\n  blackTimer.stop();\n  gameState = 'waiting'; // Empêcher les mouvements après la fin du jeu\n  showMessage('La partie est terminée !');\n\n  // Afficher le bouton \"Rejouer\"\n  replayButton.style.display = 'block';\n}\n\n// Fonction pour afficher un message dans l'élément gameMessage\nfunction showMessage(message: string) {\n  gameMessageElement.textContent = message;\n  gameMessageElement.style.display = 'block'; // Afficher le message\n}\n\n// Fonction pour effacer le message d'erreur\nfunction clearMessage() {\n  gameMessageElement.textContent = '';\n  gameMessageElement.style.display = 'none'; // Masquer le message\n}\n\n// Fonction pour mettre à jour le tour et l'affichage\nfunction updateTurn() {\n  clearMessage(); // Efface le message d'erreur au début de chaque tour\n  currentPlayer =\n    currentPlayer === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n  currentTurnElement.textContent = `Tour actuel: ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`;\n  hasMoved = false; // Réinitialise l'état de mouvement pour le prochain tour\n\n  // Gérer le changement de timer\n  if (currentPlayer === PieceColor.WHITE) {\n    blackTimer.stop();\n    whiteTimer.reset(60);\n    whiteTimer.start();\n  } else {\n    whiteTimer.stop();\n    blackTimer.reset(60);\n    blackTimer.start();\n  }\n\n  gameState = 'playing'; // Réactive les mouvements pour le prochain joueur\n}\n\n// Ajouter un mouvement à l'historique\nfunction addMoveToHistory(\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n  pieceType: PieceType,\n) {\n  const moveText = `${pieceType} de (${fromX}, ${fromY}) à (${toX}, ${toY})`;\n  const listItem = document.createElement('li');\n  listItem.textContent = moveText;\n  moveHistoryElement.appendChild(listItem);\n}\n\n// Fonction pour mettre à jour l'affichage des pièces capturées\nfunction updateCapturedPieces(piece: PieceType, color: PieceColor) {\n  const pieceSymbol = getPieceSymbol(piece, color);\n  if (color === PieceColor.WHITE) {\n    capturedWhite.push(pieceSymbol);\n    capturedWhiteElement.textContent = capturedWhite.join(' ');\n  } else {\n    capturedBlack.push(pieceSymbol);\n    capturedBlackElement.textContent = capturedBlack.join(' ');\n  }\n}\n\n// Fonction pour obtenir le symbole de la pièce capturée\nfunction getPieceSymbol(piece: PieceType, color: PieceColor): string {\n  switch (piece) {\n    case 'pawn':\n      return color === PieceColor.WHITE ? '♙' : '♟';\n    case 'rook':\n      return color === PieceColor.WHITE ? '♖' : '♜';\n    case 'knight':\n      return color === PieceColor.WHITE ? '♘' : '♞';\n    case 'bishop':\n      return color === PieceColor.WHITE ? '♗' : '♝';\n    case 'queen':\n      return color === PieceColor.WHITE ? '♕' : '♛';\n    case 'king':\n      return color === PieceColor.WHITE ? '♔' : '♚';\n    default:\n      return '';\n  }\n}\n\n// Fonction pour gérer un mouvement sur le plateau\nexport function handleMove(\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n): void {\n  if (gameState === 'waiting' || hasMoved) {\n    showMessage('Veuillez attendre le prochain tour !');\n    return;\n  }\n\n  const piece = board.getPiece(fromX, fromY);\n  const targetPiece = board.getPiece(toX, toY);\n\n  // Vérifie que c'est bien le tour du joueur qui joue\n  if (!piece || piece.color !== currentPlayer) {\n    showMessage(\n      `Ce n'est pas le tour de ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`,\n    );\n    return;\n  }\n\n  // Vérifie si le mouvement est valide pour la pièce et respecte les règles des échecs\n  if (piece.isValidMove(fromX, fromY, toX, toY, board)) {\n    // Effectue le mouvement uniquement si valide\n    if (board.movePiece(fromX, fromY, toX, toY)) {\n      // Marquer que le joueur a effectué son coup\n      hasMoved = true;\n\n      // Si une pièce est capturée, l'ajouter aux pièces capturées\n      if (targetPiece) {\n        updateCapturedPieces(targetPiece.type, targetPiece.color);\n      }\n\n      // Ajoute le mouvement à l'historique\n      addMoveToHistory(fromX, fromY, toX, toY, piece.type);\n\n      // Utilise l'animation pour le déplacement\n      renderer.animateMove(fromX, fromY, toX, toY, piece);\n\n      // Vérifie si cela met le roi adverse en échec\n      const opponentColor =\n        currentPlayer === PieceColor.WHITE\n          ? PieceColor.BLACK\n          : PieceColor.WHITE;\n      if (board.isKingInCheck(opponentColor)) {\n        if (board.isCheckmate(opponentColor)) {\n          showMessage(\n            `Échec et Mat ! ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'} gagne !`,\n          );\n          endGame();\n        } else {\n          showMessage(\n            `Échec au ${opponentColor === PieceColor.WHITE ? 'Blanc' : 'Noir'} !`,\n          );\n        }\n      }\n\n      // Change de tour après un mouvement valide\n      gameState = 'waiting'; // Bloque les mouvements jusqu'à ce que le tour change\n      updateTurn();\n    } else {\n      showMessage('Mouvement invalide !');\n    }\n  } else {\n    showMessage('Mouvement invalide !');\n  }\n}\n\n// Gérer le clic sur \"Passer son tour\"\npassTurnButton.addEventListener('click', (event) => {\n  event.preventDefault(); // Empêche tout comportement par défaut\n  if (gameState === 'playing') {\n    showMessage(\n      `Tour passé pour ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`,\n    );\n    updateTurn();\n  }\n});\n\n// Gérer le clic sur \"Rejouer\"\nreplayButton.addEventListener('click', () => {\n  location.reload(); // Recharge la page pour redémarrer la partie\n});\n"],"names":["PieceColor","PieceType","Piece","color","type","fromX","fromY","toX","toY","board","dx","dy","x","y","targetPiece","Rook","__publicField","King","direction","rookX","rook","Knight","Bishop","Queen","Pawn","startRow","distanceY","distanceX","Board","piece","kingX","kingY","kingPosition","originalPiece","kingSafe","Game","CanvasRenderer","canvasId","moveHandler","isDarkTile","pieceText","currentFrame","startX","startY","deltaX","deltaY","animate","event","rect","Timer","initialTime","onTimeUpdate","time","game","moveHistoryElement","currentTurnElement","timerElement","capturedWhiteElement","capturedBlackElement","passTurnButton","gameMessageElement","replayButton","currentPlayer","gameState","hasMoved","capturedWhite","capturedBlack","whiteTimer","timeLeft","updateTimerDisplay","blackTimer","showMessage","endGame","renderer","handleMove","message","clearMessage","updateTurn","addMoveToHistory","pieceType","moveText","listItem","updateCapturedPieces","pieceSymbol","getPieceSymbol","opponentColor"],"mappings":"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"}