{"version":3,"mappings":"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","names":["createPiece","type","color","PieceType","Pawn","__vitePreload","Rook","Knight","Bishop","Queen","King","PieceColor","Piece","fromX","fromY","toX","toY","board","dx","dy","x","y","piece","targetPiece","data","capturedWhite","capturedBlack","showMessage","message","gameMessageElement","getPieceSymbol","updateCapturedPieces","pieceSymbol","updateCapturedPiecesDOM","capturedWhiteElement","capturedBlackElement","Board","flip","validMoves","movingPawn","capturedPawnY","isSimulation","opponentColor","king","direction","rookX","rook","kingX","kingY","capturedPawn","captureData","pieceType","kingPosition","moves","move","originalPiece","kingSafe","isKingSafe","pieces","fromRow","fromCol","toRow","toCol","destinationPiece","row","pieceData","kingPositions","nx","ny","hash","emptyCount","pieceChar","symbolMap","boardString","Game","playerColor","resolve","event","bestMove","promotionRequired","isMoveLegal","attempts","newEvent","res","boardData","testBoard","isStillInCheck","CanvasRenderer","canvasId","moveHandler","currentFrame","startX","startY","endX","endY","deltaX","deltaY","animate","kingInCheck","letters","newX","newY","tileColor","i","letterX","letterY","numberX","numberY","pieceText","rect","boardX","boardY","mouseX","mouseY","rawX","rawY","Timer","initialTime","onTimeUpdate","time","startImmediately","initializeGame","moveHistory","game","whiteMovesElement","blackMovesElement","currentTurnElement","timerElement","passTurnButton","replayButton","currentPlayer","hasMoved","isGameEnded","isAITurn","whiteTimer","timeLeft","updateTimerDisplay","blackTimer","endGame","renderer","handleMove","triggerAIMove","clearMessage","showPromotionDialog","promotionDialog","addMoveToHistory","updateTurn","lastMove","moveText","listItem"],"ignoreList":[],"sources":["../../src/utils/pieceFactory.ts","../../src/piece.ts","../../src/utils/utils.ts","../../src/board.ts","../../src/game.ts","../../src/canvas-renderer.ts","../../src/timer.ts","../../src/index.ts"],"sourcesContent":["import { PieceColor, PieceType } from '../piece';\n\nexport async function createPiece(type: PieceType, color: PieceColor) {\n  switch (type) {\n    case PieceType.PAWN:\n      const { Pawn } = await import('../pieces/pawn');\n      return new Pawn(color);\n    case PieceType.ROOK:\n      const { Rook } = await import('../pieces/rook');\n      return new Rook(color);\n    case PieceType.KNIGHT:\n      const { Knight } = await import('../pieces/knight');\n      return new Knight(color);\n    case PieceType.BISHOP:\n      const { Bishop } = await import('../pieces/bishop');\n      return new Bishop(color);\n    case PieceType.QUEEN:\n      const { Queen } = await import('../pieces/queen');\n      return new Queen(color);\n    case PieceType.KING:\n      const { King } = await import('../pieces/king');\n      return new King(color);\n    default:\n      throw new Error(`Type de pièce inconnu : ${type}`);\n  }\n}\n","// src/piece.ts\nimport { createPiece } from './utils/pieceFactory';\nimport { King } from './pieces/king';\n\nexport enum PieceColor {\n  WHITE = 'white',\n  BLACK = 'black',\n}\n\nexport enum PieceType {\n  PAWN = 'pawn',\n  ROOK = 'rook',\n  KNIGHT = 'knight',\n  BISHOP = 'bishop',\n  QUEEN = 'queen',\n  KING = 'king',\n}\n\nexport interface BoardInterface {\n  getPiece(x: number, y: number): Piece | null;\n\n  updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void;\n\n  isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean;\n\n  promotePawn(\n    x: number,\n    y: number,\n    pieceType: PieceType | string,\n  ): Promise<void>;\n\n  isSquareUnderAttack(x: number, y: number, color: PieceColor): boolean;\n\n  isKing(x: number, y: number): boolean;\n\n  isAdjacentToAnotherKing(x: number, y: number, color: PieceColor): boolean;\n\n  getPlayerColor(): PieceColor;\n\n  captureEnPassantIfValid(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): void;\n}\n\nexport abstract class Piece {\n  public hasMoved: boolean = false;\n\n  protected constructor(\n    public color: PieceColor,\n    public type: PieceType,\n  ) {}\n\n  abstract isValidMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean;\n\n  public isPathClear(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    board: BoardInterface,\n  ): boolean {\n    const dx = Math.sign(toX - fromX);\n    const dy = Math.sign(toY - fromY);\n\n    let x = fromX + dx;\n    let y = fromY + dy;\n    while (x !== toX || y !== toY) {\n      if (board.getPiece(x, y) !== null) return false;\n      x += dx;\n      y += dy;\n    }\n    return true;\n  }\n\n  static isKing(piece: Piece): piece is King {\n    return piece.type === PieceType.KING;\n  }\n\n  public canCapture(toX: number, toY: number, board: BoardInterface): boolean {\n    const targetPiece = board.getPiece(toX, toY);\n    return !targetPiece || targetPiece.color !== this.color;\n  }\n\n  // Sérialisation des données de la pièce\n  public toData(): any {\n    return {\n      color: this.color,\n      type: this.type,\n    };\n  }\n\n  static async fromData(data: any): Promise<Piece> {\n    return await createPiece(data.type, data.color);\n  }\n\n  // Nouvelle méthode pour vérifier les menaces sans règles spécifiques du roi\n  public isThreatenedMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    const dx = Math.abs(toX - fromX);\n    const dy = Math.abs(toY - fromY);\n    return dx <= 1 && dy <= 1;\n  }\n}\n","// src/utils/utils.ts\n\nimport { PieceColor, PieceType } from '../piece';\nimport { Board } from '../board';\nimport { Move } from '../ai/openingBook';\n\nexport let capturedWhite: string[] = [];\nexport let capturedBlack: string[] = [];\n\nexport function showMessage(message: string) {\n  const gameMessageElement = document.getElementById(\n    'gameMessage',\n  ) as HTMLDivElement;\n  if (gameMessageElement) {\n    gameMessageElement.textContent = message;\n    gameMessageElement.style.display = 'block'; // Afficher le message\n  }\n}\n\nexport function getPieceSymbol(piece: PieceType, color: PieceColor): string {\n  switch (piece) {\n    case PieceType.PAWN:\n      return color === PieceColor.WHITE ? '♙' : '♟';\n    case PieceType.ROOK:\n      return color === PieceColor.WHITE ? '♖' : '♜';\n    case PieceType.KNIGHT:\n      return color === PieceColor.WHITE ? '♘' : '♞';\n    case PieceType.BISHOP:\n      return color === PieceColor.WHITE ? '♗' : '♝';\n    case PieceType.QUEEN:\n      return color === PieceColor.WHITE ? '♕' : '♛';\n    case PieceType.KING:\n      return color === PieceColor.WHITE ? '♔' : '♚';\n    default:\n      return '';\n  }\n}\n\nexport function updateCapturedPieces(piece: PieceType, color: PieceColor) {\n  const pieceSymbol = getPieceSymbol(piece, color);\n\n  if (color === PieceColor.WHITE) {\n    capturedWhite.push(pieceSymbol);\n  } else {\n    capturedBlack.push(pieceSymbol);\n  }\n\n  updateCapturedPiecesDOM();\n}\n\nexport function updateCapturedPiecesDOM(): void {\n  const capturedWhiteElement = document.getElementById(\n    'capturedWhite',\n  ) as HTMLDivElement;\n  const capturedBlackElement = document.getElementById(\n    'capturedBlack',\n  ) as HTMLDivElement;\n\n  if (capturedWhiteElement) {\n    capturedWhiteElement.textContent = capturedWhite.join(' ');\n  }\n  if (capturedBlackElement) {\n    capturedBlackElement.textContent = capturedBlack.join(' ');\n  }\n}\n\nexport function describeMove(board: Board, move: Move): string {\n  const piece = board.getPiece(move.fromX, move.fromY);\n  if (!piece) {\n    return `❗ Erreur : aucune pièce à (${move.fromX}, ${move.fromY})`;\n  }\n\n  const symbols = {\n    [PieceType.PAWN]: '♟',\n    [PieceType.KNIGHT]: '♞',\n    [PieceType.BISHOP]: '♝',\n    [PieceType.ROOK]: '♜',\n    [PieceType.QUEEN]: '♛',\n    [PieceType.KING]: '♚',\n  };\n\n  const from = `${String.fromCharCode(97 + move.fromX)}${8 - move.fromY}`;\n  const to = `${String.fromCharCode(97 + move.toX)}${8 - move.toY}`;\n\n  return `${piece.color === PieceColor.WHITE ? 'Blanc' : 'Noir'} joue ${symbols[piece.type]} de ${from} à ${to}`;\n}\n","// src/board.ts\nimport { BoardInterface, Piece, PieceColor, PieceType } from './piece';\nimport { King } from './pieces/king';\nimport { updateCapturedPieces } from './utils/utils';\nimport { createPiece } from './utils/pieceFactory';\n\ntype BoardSquare = Piece | null;\n\nexport class Board implements BoardInterface {\n  private grid: (Piece | null)[][];\n  private enPassantTarget: { x: number; y: number } | null = null;\n  private halfMoveCount: number = 0; // Compteur pour la règle des 50 coups\n  private currentPlayer: PieceColor = PieceColor.WHITE;\n\n  public flipBoard: boolean = false;\n\n  constructor() {\n    this.grid = Array(8)\n      .fill(null)\n      .map(() => Array(8).fill(null));\n  }\n\n  public async init(): Promise<void> {\n    this.grid = await this.initializeBoard();\n  }\n\n  public setFlipBoard(flip: boolean): void {\n    this.flipBoard = flip;\n  }\n\n  private async initializeBoard(): Promise<(Piece | null)[][]> {\n    const board: (Piece | null)[][] = Array(8)\n      .fill(null)\n      .map(() => Array(8).fill(null));\n\n    // Pièces noires en haut (rangée 8 = y=0)\n    board[0] = [\n      await createPiece(PieceType.ROOK, PieceColor.BLACK),\n      await createPiece(PieceType.KNIGHT, PieceColor.BLACK),\n      await createPiece(PieceType.BISHOP, PieceColor.BLACK),\n      await createPiece(PieceType.QUEEN, PieceColor.BLACK),\n      await createPiece(PieceType.KING, PieceColor.BLACK),\n      await createPiece(PieceType.BISHOP, PieceColor.BLACK),\n      await createPiece(PieceType.KNIGHT, PieceColor.BLACK),\n      await createPiece(PieceType.ROOK, PieceColor.BLACK),\n    ];\n    board[1] = await Promise.all(\n      Array(8)\n        .fill(null)\n        .map(() => createPiece(PieceType.PAWN, PieceColor.BLACK)),\n    );\n\n    // Pièces blanches en bas (rangée 1 = y=7)\n    board[7] = [\n      await createPiece(PieceType.ROOK, PieceColor.WHITE),\n      await createPiece(PieceType.KNIGHT, PieceColor.WHITE),\n      await createPiece(PieceType.BISHOP, PieceColor.WHITE),\n      await createPiece(PieceType.QUEEN, PieceColor.WHITE),\n      await createPiece(PieceType.KING, PieceColor.WHITE),\n      await createPiece(PieceType.BISHOP, PieceColor.WHITE),\n      await createPiece(PieceType.KNIGHT, PieceColor.WHITE),\n      await createPiece(PieceType.ROOK, PieceColor.WHITE),\n    ];\n    board[6] = await Promise.all(\n      Array(8)\n        .fill(null)\n        .map(() => createPiece(PieceType.PAWN, PieceColor.WHITE)),\n    );\n\n    return board;\n  }\n\n  // Méthode générale pour vérifier les limites\n  public isWithinBounds(x: number, y: number): boolean {\n    return x >= 0 && x < 8 && y >= 0 && y < 8;\n  }\n\n  public getPiece(x: number, y: number): BoardSquare {\n    return this.grid[y][x];\n  }\n\n  public getValidMoves(x: number, y: number): { x: number; y: number }[] {\n    let piece = null;\n    if (this.isWithinBounds(x, y)) piece = this.getPiece(x, y);\n    if (!piece) return [];\n\n    const validMoves: { x: number; y: number }[] = [];\n\n    for (let toY = 0; toY < 8; toY++) {\n      for (let toX = 0; toX < 8; toX++) {\n        if (piece.isValidMove(x, y, toX, toY, this)) {\n          validMoves.push({ x: toX, y: toY });\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  public captureEnPassantIfValid(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): void {\n    if (this.isEnPassantMove(fromX, fromY, toX, toY)) {\n      const movingPawn = this.getPiece(fromX, fromY);\n      if (!movingPawn) return;\n\n      // Détermine la position du pion capturé en fonction de la couleur\n      const capturedPawnY =\n        toY + (movingPawn.color === PieceColor.WHITE ? -1 : 1);\n\n      if (this.grid[capturedPawnY][toX]) {\n        this.grid[capturedPawnY][toX] = null;\n      }\n    }\n  }\n\n  public getKingInCheck(): { x: number; y: number } | null {\n    if (this.isKingInCheck(PieceColor.WHITE)) {\n      return this.findKing(PieceColor.WHITE);\n    } else if (this.isKingInCheck(PieceColor.BLACK)) {\n      return this.findKing(PieceColor.BLACK);\n    }\n    return null;\n  }\n\n  public movePiece(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    isSimulation: boolean = true,\n  ): boolean {\n    if (\n      !this.isWithinBounds(fromX, fromY) ||\n      !this.isWithinBounds(toX, toY) ||\n      ['__proto__', 'constructor', 'prototype'].includes(fromY.toString()) ||\n      ['__proto__', 'constructor', 'prototype'].includes(toY.toString())\n    ) {\n      return false; // Mouvement invalide en dehors des limites ou clé interdite\n    }\n\n    const piece = this.getPiece(fromX, fromY);\n    if (piece && piece.isValidMove(fromX, fromY, toX, toY, this)) {\n      const targetPiece = this.getPiece(toX, toY);\n\n      // Empêche de capturer le roi ennemi\n      if (targetPiece && targetPiece.type === PieceType.KING) {\n        return false;\n      }\n\n      // Gestion du roque pour le roi\n      if (piece.type === PieceType.KING && Math.abs(toX - fromX) === 2) {\n        if (this.isCastlingValid(piece, fromX, fromY, toX)) {\n          this.handleCastling(toX, fromY);\n          piece.hasMoved = true; // Met à jour le statut de mouvement du roi\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      // Gestion de la prise en passant\n      if (\n        piece?.type === PieceType.PAWN &&\n        this.isEnPassantMove(fromX, fromY, toX, toY)\n      ) {\n        this.captureEnPassant(fromX, fromY, toX, toY); // Capture le pion en passant\n      }\n\n      // Sauvegarde l'état avant de simuler le mouvement\n      this.grid[toY][toX] = piece;\n      this.grid[fromY][fromX] = null;\n      if (!isSimulation) {\n        piece.hasMoved = true;\n      }\n\n      // Vérifie si le mouvement met le roi du joueur en échec\n      if (this.isKingInCheck(piece.color)) {\n        // Annule le mouvement si le roi est en échec\n        this.grid[fromY][fromX] = piece;\n        this.grid[toY][toX] = targetPiece;\n        return false;\n      }\n\n      // Mise à jour de `hasMoved` pour les rois et tours\n      if (piece.type === PieceType.KING || piece.type === PieceType.ROOK) {\n        piece.hasMoved = true;\n      }\n\n      // Mise à jour de l'état après un mouvement valide\n      this.updateEnPassantTarget(fromX, fromY, toX, toY, piece);\n\n      // Réinitialise le compteur pour la règle des 50 coups si un pion bouge ou une capture a lieu\n      this.halfMoveCount =\n        piece.type === PieceType.PAWN || targetPiece\n          ? 0\n          : this.halfMoveCount + 1;\n\n      // Vérifie si le mouvement met l'adversaire en échec et mat\n      const opponentColor =\n        piece.color === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n      if (this.isCheckmate(opponentColor)) {\n        return true; // Partie terminée\n      }\n\n      return true;\n    }\n\n    return false; // Mouvement invalide\n  }\n\n  private isCastlingValid(\n    king: King,\n    fromX: number,\n    fromY: number,\n    toX: number,\n  ): boolean {\n    const direction = toX > fromX ? 1 : -1;\n    const rookX = toX > fromX ? 7 : 0;\n    const rook = this.getPiece(rookX, fromY);\n\n    // Vérification des conditions de roque : roi et tour n'ont pas bougé, et la tour est présente\n    if (!(rook?.type === PieceType.ROOK) || rook.hasMoved || king.hasMoved)\n      return false;\n\n    // Vérifie que les cases entre le roi et la tour sont libres et non attaquées\n    for (let x = fromX + direction; x !== toX + direction; x += direction) {\n      if (\n        this.getPiece(x, fromY) ||\n        this.isSquareUnderAttack(x, fromY, king.color)\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private handleCastling(kingX: number, kingY: number): void {\n    // Petit roque (roi vers la droite)\n    if (kingX === 6) {\n      const rook = this.getPiece(7, kingY);\n      const king = this.getPiece(4, kingY);\n      if (\n        rook?.type === PieceType.ROOK &&\n        !rook.hasMoved &&\n        king?.type === PieceType.KING &&\n        !king.hasMoved\n      ) {\n        // Déplace la tour et le roi pour le petit roque\n        this.setPiece(5, kingY, rook); // Déplace la tour\n        this.setPiece(7, kingY, null); // Enlève la tour de sa position initiale\n        this.setPiece(6, kingY, king); // Déplace le roi vers sa nouvelle position\n        this.setPiece(4, kingY, null); // Enlève le roi de sa position initiale\n\n        // Marque le roi et la tour comme ayant bougé\n        king.hasMoved = true;\n        rook.hasMoved = true;\n      }\n    }\n    // Grand roque (roi vers la gauche)\n    else if (kingX === 2) {\n      const rook = this.getPiece(0, kingY);\n      const king = this.getPiece(4, kingY);\n      if (\n        rook?.type === PieceType.ROOK &&\n        !rook.hasMoved &&\n        king?.type === PieceType.KING &&\n        !king.hasMoved\n      ) {\n        // Déplace la tour et le roi pour le grand roque\n        this.setPiece(3, kingY, rook); // Déplace la tour\n        this.setPiece(0, kingY, null); // Enlève la tour de sa position initiale\n        this.setPiece(2, kingY, king); // Déplace le roi vers sa nouvelle position\n        this.setPiece(4, kingY, null); // Enlève le roi de sa position initiale\n\n        // Marque le roi et la tour comme ayant bougé\n        king.hasMoved = true;\n        rook.hasMoved = true;\n      }\n    }\n  }\n\n  public updateEnPassantTarget(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    // Vérifie que la pièce est un pion et qu'il avance de deux cases\n    if (\n      piece?.type === PieceType.PAWN &&\n      Math.abs(toY - fromY) === 2 &&\n      fromX === toX\n    ) {\n      // Si le pion avance de deux cases, configure `enPassantTarget`\n      // pour permettre une prise en passant lors du tour suivant\n      this.enPassantTarget = { x: toX, y: (fromY + toY) / 2 };\n    } else {\n      // Réinitialise `enPassantTarget` si aucune condition de prise en passant n'est remplie\n      this.enPassantTarget = null;\n    }\n  }\n\n  public captureEnPassant(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): { capturedWhite: PieceType[]; capturedBlack: PieceType[] } | null {\n    const piece = this.getPiece(fromX, fromY);\n\n    if (\n      this.isEnPassantMove(fromX, fromY, toX, toY) &&\n      piece?.type === PieceType.PAWN\n    ) {\n      const direction = piece.color === PieceColor.WHITE ? -1 : 1;\n      const capturedPawnY = toY + direction;\n      const capturedPawn = this.getPiece(toX, capturedPawnY);\n\n      if (capturedPawn && capturedPawn.type === PieceType.PAWN) {\n        // Supprime le pion capturé de la grille\n        this.grid[capturedPawnY][toX] = null;\n\n        // Initialise les données de capture\n        const captureData: {\n          capturedWhite: PieceType[];\n          capturedBlack: PieceType[];\n        } = {\n          capturedWhite: [],\n          capturedBlack: [],\n        };\n\n        // Met à jour les données de capture selon la couleur du pion capturé\n        if (capturedPawn.color === PieceColor.WHITE) {\n          captureData.capturedWhite.push(capturedPawn.type);\n        } else {\n          captureData.capturedBlack.push(capturedPawn.type);\n        }\n\n        // Appelle updateCapturedPieces pour mettre à jour l'interface\n        updateCapturedPieces(capturedPawn.type, capturedPawn.color);\n\n        return captureData;\n      }\n    }\n    return null;\n  }\n\n  public isEnPassantMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    if (!this.enPassantTarget) return false;\n\n    // Vérifie que le mouvement cible la bonne case pour la prise en passant\n    const piece = this.getPiece(fromX, fromY);\n    return (\n      piece?.type === PieceType.PAWN &&\n      toX === this.enPassantTarget.x &&\n      toY === this.enPassantTarget.y &&\n      Math.abs(fromX - toX) === 1 &&\n      Math.abs(fromY - toY) === 1\n    );\n  }\n\n  public async promotePawn(\n    x: number,\n    y: number,\n    pieceType: string,\n  ): Promise<void> {\n    const color = this.getPiece(x, y)?.color;\n\n    if (!color) return;\n\n    switch (pieceType) {\n      case 'queen':\n        this.grid[y][x] = await createPiece(PieceType.QUEEN, color);\n        break;\n      case 'rook':\n        this.grid[y][x] = await createPiece(PieceType.ROOK, color);\n        break;\n      case 'bishop':\n        this.grid[y][x] = await createPiece(PieceType.BISHOP, color);\n        break;\n      case 'knight':\n        this.grid[y][x] = await createPiece(PieceType.KNIGHT, color);\n        break;\n    }\n  }\n\n  public isKingInCheck(color: PieceColor): boolean {\n    const kingPosition = this.findKing(color);\n    if (!kingPosition) {\n      return false;\n    }\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color !== color) {\n          if (piece.isValidMove(x, y, kingPosition.x, kingPosition.y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  public isCheckmate(color: PieceColor): boolean {\n    // Vérifie si le roi de la couleur donnée est en échec\n    const kingInCheck = this.isKingInCheck(color);\n\n    // Si le roi n'est pas en échec, ce n'est pas un échec et mat\n    if (!kingInCheck) {\n      return false;\n    }\n\n    // Parcourt chaque pièce de la couleur donnée pour trouver un mouvement légal\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          const moves = this.getValidMoves(x, y);\n\n          for (const move of moves) {\n            // Simule le mouvement\n            const originalPiece = this.getPiece(move.x, move.y);\n            this.grid[move.y][move.x] = piece;\n            this.grid[y][x] = null;\n\n            const kingSafe = !this.isKingInCheck(color);\n\n            // Annule le mouvement simulé\n            this.grid[y][x] = piece;\n            this.grid[move.y][move.x] = originalPiece;\n\n            if (kingSafe) {\n              return false; // Un mouvement légal existe pour sortir de l'échec\n            }\n          }\n        }\n      }\n    }\n\n    return true; // Aucun mouvement possible, échec et mat\n  }\n\n  public isStalemate(color: PieceColor): boolean {\n    // Pat uniquement si le roi n'est pas en échec et qu'il n'y a aucun coup légal disponible\n    if (this.isKingInCheck(color)) return false;\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece.color === color) {\n          for (let toY = 0; toY < 8; toY++) {\n            for (let toX = 0; toX < 8; toX++) {\n              if (piece.isValidMove(x, y, toX, toY, this)) {\n                // Simuler le mouvement pour vérifier l'échec potentiel\n                const originalPiece = this.getPiece(toX, toY);\n                this.grid[toY][toX] = piece;\n                this.grid[y][x] = null;\n\n                const isKingSafe = !this.isKingInCheck(color);\n\n                // Annuler le mouvement simulé\n                this.grid[y][x] = piece;\n                this.grid[toY][toX] = originalPiece;\n\n                if (isKingSafe) return false; // Mouvement valide trouvé, pas de pat\n              }\n            }\n          }\n        }\n      }\n    }\n    return true; // Aucun coup légal trouvé, pat détecté\n  }\n\n  findKing(color: PieceColor): { x: number; y: number } | null {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece && piece?.type === PieceType.KING && piece.color === color) {\n          return { x, y };\n        }\n      }\n    }\n    return null;\n  }\n\n  public isKing(x: number, y: number): boolean {\n    const piece = this.getPiece(x, y);\n    return piece?.type === PieceType.KING;\n  }\n\n  public isSquareUnderAttack(x: number, y: number, color: PieceColor): boolean {\n    for (let fromY = 0; fromY < 8; fromY++) {\n      for (let fromX = 0; fromX < 8; fromX++) {\n        const piece = this.getPiece(fromX, fromY);\n        if (piece && piece.color !== color) {\n          // Utilise `isThreatenedMove` pour éviter la récursion infinie\n          if (piece.type === PieceType.KING) {\n            if (piece.isThreatenedMove(fromX, fromY, x, y)) {\n              return true;\n            }\n          } else if (piece.isValidMove(fromX, fromY, x, y, this)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Vérifie le matériel insuffisant pour un échec et mat\n  public isInsufficientMaterial(): boolean {\n    const pieces = this.grid.flat().filter((piece) => piece !== null);\n\n    // Cas les plus courants de matériel insuffisant\n    if (pieces.length <= 2) return true; // Seulement les rois sur le plateau\n    return (\n      pieces.length === 3 &&\n      pieces.some(\n        (piece) =>\n          piece?.type === PieceType.BISHOP || piece?.type === PieceType.KNIGHT,\n      )\n    );\n  }\n\n  // Vérifie si la règle des 50 coups est remplie\n  public isFiftyMoveRule(): boolean {\n    return this.halfMoveCount >= 50;\n  }\n\n  public setPiece(x: number, y: number, piece: Piece | null): void {\n    this.grid[y][x] = piece;\n  }\n\n  // Vérifie si un mouvement est valide\n  public isMoveValid(\n    fromRow: number,\n    fromCol: number,\n    toRow: number,\n    toCol: number,\n  ): boolean {\n    const piece = this.getPiece(fromRow, fromCol);\n\n    // Si aucune pièce n'est présente à l'emplacement source, le mouvement est invalide\n    if (!piece) {\n      return false;\n    }\n\n    // Si la destination est en dehors de l'échiquier, mouvement invalide\n    if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) {\n      return false;\n    }\n\n    // Vérifie si la pièce peut se déplacer à cette destination en utilisant la logique de mouvement de la pièce\n    if (!piece.isValidMove(fromRow, fromCol, toRow, toCol, this)) {\n      return false;\n    }\n\n    // Vérifie s'il y a une pièce à la destination et si elle est de la même couleur\n    const destinationPiece = this.getPiece(toRow, toCol);\n    return !(destinationPiece && destinationPiece.color === piece.color);\n  }\n\n  public isCapture(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): boolean {\n    const piece = this.isWithinBounds(fromX, fromY)\n      ? this.getPiece(fromX, fromY)\n      : null;\n    const targetPiece = this.isWithinBounds(toX, toY)\n      ? this.getPiece(toX, toY)\n      : null;\n\n    // Vérifie qu'il y a une pièce à la position cible et qu'elle est d'une couleur opposée\n    return (\n      piece !== null &&\n      targetPiece !== null &&\n      piece.color !== targetPiece.color\n    );\n  }\n\n  public static async fromData(data: any): Promise<Board> {\n    const board = new Board();\n    await board.init();\n    board.grid = await Promise.all(\n      data.grid.map(async (row: any[]) =>\n        Promise.all(\n          row.map(async (pieceData) =>\n            pieceData ? await Piece.fromData(pieceData) : null,\n          ),\n        ),\n      ),\n    );\n    return board;\n  }\n\n  public toData(): any {\n    return {\n      grid: this.grid.map((row) =>\n        row.map((piece) => (piece ? piece.toData() : null)),\n      ),\n    };\n  }\n\n  public isAdjacentToAnotherKing(\n    x: number,\n    y: number,\n    color: PieceColor,\n  ): boolean {\n    const kingPositions = [\n      { dx: -1, dy: -1 },\n      { dx: -1, dy: 0 },\n      { dx: -1, dy: 1 },\n      { dx: 0, dy: -1 },\n      { dx: 0, dy: 1 },\n      { dx: 1, dy: -1 },\n      { dx: 1, dy: 0 },\n      { dx: 1, dy: 1 },\n    ];\n\n    for (const { dx, dy } of kingPositions) {\n      const nx = x + dx;\n      const ny = y + dy;\n      const piece = this.isWithinBounds(nx, ny) ? this.getPiece(nx, ny) : null;\n      if (piece?.type === PieceType.KING && piece.color !== color) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public getPieceCount(): number {\n    return this.grid.flat().filter((piece) => piece !== null).length;\n  }\n\n  public setPlayerColor(color: PieceColor): void {\n    this.currentPlayer = color;\n  }\n\n  public getPlayerColor(): PieceColor {\n    return this.currentPlayer;\n  }\n\n  public getCurrentMovesHash(): string {\n    let hash = '';\n\n    for (let y = 0; y < 8; y++) {\n      let emptyCount = 0;\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece) {\n          // If there were empty squares, add their count to the hash\n          if (emptyCount > 0) {\n            hash += emptyCount.toString();\n            emptyCount = 0;\n          }\n          // Use standard FEN notation for pieces\n          const pieceChar = this.getPieceSymbol(piece);\n          hash += pieceChar;\n        } else {\n          // Count empty squares\n          emptyCount++;\n        }\n      }\n      // Add any remaining empty squares in the row\n      if (emptyCount > 0) hash += emptyCount.toString();\n      // Add row separator, except for the last row\n      if (y < 7) hash += '/';\n    }\n\n    // Append the current player's turn\n    hash += ` ${this.currentPlayer === PieceColor.WHITE ? 'w' : 'b'}`;\n\n    return hash;\n  }\n\n  private getPieceSymbol(piece: Piece): string {\n    const symbolMap: { [key in PieceType]: string } = {\n      [PieceType.PAWN]: 'p',\n      [PieceType.ROOK]: 'r',\n      [PieceType.KNIGHT]: 'n', // Use 'n' for knight to avoid confusion with king\n      [PieceType.BISHOP]: 'b',\n      [PieceType.QUEEN]: 'q',\n      [PieceType.KING]: 'k',\n    };\n    // Return the symbol in uppercase for White, lowercase for Black\n    return piece.color === PieceColor.WHITE\n      ? symbolMap[piece.type].toUpperCase()\n      : symbolMap[piece.type];\n  }\n\n  // Méthode toString pour représenter le plateau et état de jeu actuel\n  public toString(): string {\n    let boardString = '';\n\n    // Inclure chaque pièce et sa position sur le plateau\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.getPiece(x, y);\n        if (piece) {\n          boardString += `${piece.color[0]}${piece.type[0]}`;\n        } else {\n          boardString += '__'; // Place vide pour chaque case\n        }\n      }\n    }\n\n    // Ajouter l'état d'en passant, demi-coups, et joueur actuel\n    boardString += this.enPassantTarget\n      ? `e${this.enPassantTarget.x}${this.enPassantTarget.y}`\n      : 'e--';\n    boardString += `h${this.halfMoveCount}`;\n    boardString += `p${this.currentPlayer[0]}`;\n\n    return boardString;\n  }\n}\n","// game.ts\nimport { Board } from './board';\nimport { updateCapturedPieces } from './utils/utils';\nimport { PieceColor, PieceType } from './piece';\n\nexport class Game {\n  private readonly board: Board;\n  private aiWorker: Worker;\n  private readonly aiColor: PieceColor;\n  private lastAIMove: {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n  } | null = null;\n\n  constructor(playerColor: PieceColor) {\n    this.board = new Board();\n    this.aiWorker = new Worker(new URL('./ai.worker.ts', import.meta.url), {\n      type: 'module',\n    });\n    this.aiColor =\n      playerColor === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n\n    this.board.setFlipBoard(false);\n  }\n\n  public async getBoard(): Promise<Board> {\n    await this.board.init();\n    return this.board;\n  }\n\n  public makeAIMove(): Promise<void> {\n    return new Promise((resolve) => {\n      this.aiWorker.onmessage = async (event) => {\n        let { bestMove, captureData, promotionRequired } = event.data;\n\n        let isMoveLegal = await this.isAIMoveLegal(bestMove);\n        let attempts = 0;\n\n        while (!isMoveLegal && attempts < 50) {\n          this.aiWorker.postMessage({ invalidMove: bestMove });\n\n          const newEvent = await new Promise((res) => {\n            this.aiWorker.onmessage = res;\n          });\n\n          bestMove = newEvent.data.bestMove;\n          captureData = newEvent.data.captureData;\n          promotionRequired = newEvent.data.promotionRequired;\n\n          isMoveLegal = await this.isAIMoveLegal(bestMove);\n          attempts++;\n        }\n\n        if (isMoveLegal && bestMove) {\n        this.lastAIMove = bestMove;\n\n        // Vérification et mise à jour des pièces capturées\n        const targetPiece = this.board.getPiece(bestMove.toX, bestMove.toY);\n          if (targetPiece) {\n            updateCapturedPieces(targetPiece.type, targetPiece.color);\n          }\n\n          this.board.movePiece(bestMove.fromX, bestMove.fromY, bestMove.toX, bestMove.toY, false);\n        } else {\n          console.warn(\"Aucun coup valide trouvé par l'IA après plusieurs tentatives.\");\n        }\n\n        resolve();\n      };\n\n      const boardData = this.board.toData();\n      this.aiWorker.postMessage({ boardData, aiColor: this.aiColor });\n    });\n  }\n\n  private async isAIMoveLegal(bestMove: { fromX: number, fromY: number, toX: number, toY: number }): Promise<boolean> {\n    const testBoard = await Board.fromData(this.board.toData());\n\n    // Simuler le coup sur un plateau temporaire\n    const piece = testBoard.getPiece(bestMove.fromX, bestMove.fromY);\n    const targetPiece = testBoard.getPiece(bestMove.toX, bestMove.toY);\n\n    testBoard.setPiece(bestMove.toX, bestMove.toY, piece);\n    testBoard.setPiece(bestMove.fromX, bestMove.fromY, null);\n\n    const isStillInCheck = testBoard.isKingInCheck(this.aiColor);\n\n    // Restaurer les positions (inutile si plateau temporaire est jetable)\n    testBoard.setPiece(bestMove.fromX, bestMove.fromY, piece);\n    testBoard.setPiece(bestMove.toX, bestMove.toY, targetPiece);\n\n    return !isStillInCheck;\n  }\n\n  public getLastAIMove() {\n    return this.lastAIMove;\n  }\n}\n","import { Board } from './board';\nimport { Piece, PieceColor } from './piece';\n\nexport class CanvasRenderer {\n  private readonly canvas: HTMLCanvasElement;\n  private readonly context: CanvasRenderingContext2D;\n  private readonly tileSize: number;\n  private get flipBoard(): boolean {\n    return this.playerColor === PieceColor.BLACK;\n  }\n  private draggingPiece: Piece | null = null;\n  private startX: number | null = null;\n  private startY: number | null = null;\n  private highlightedMoves: { x: number; y: number }[] = [];\n  private kingInCheckPosition: { x: number; y: number } | null = null;\n\n  constructor(\n    private readonly board: Board,\n    canvasId: string,\n    private readonly moveHandler: (\n      fromX: number,\n      fromY: number,\n      toX: number,\n      toY: number,\n    ) => Promise<boolean>,\n    private readonly playerColor: PieceColor\n  ) {\n    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    if (!this.canvas) throw new Error(`Canvas with id ${canvasId} not found`);\n    this.context = this.canvas.getContext('2d') as CanvasRenderingContext2D;\n    if (!this.context)\n      throw new Error(`Canvas context could not be initialized`);\n    this.tileSize = this.canvas.width / 8;\n\n    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n  }\n\n  private getCoordinates(x: number, y: number): { x: number; y: number } {\n    return this.flipBoard ? { x: 7 - x, y: 7 - y } : { x, y };\n  }\n\n  // Animation pour déplacer une pièce\n  public animateMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    piece: Piece,\n  ): void {\n    const frames = 10;\n    let currentFrame = 0;\n\n    const { x: startX, y: startY } = this.getCoordinates(fromX, fromY);\n    const { x: endX, y: endY } = this.getCoordinates(toX, toY);\n    const deltaX = ((endX - startX) * this.tileSize) / frames;\n    const deltaY = ((endY - startY) * this.tileSize) / frames;\n\n    const animate = () => {\n      if (currentFrame <= frames) {\n        this.drawBoard();\n        this.context.fillStyle =\n          piece.color === PieceColor.WHITE ? 'white' : 'black';\n        this.context.font = '48px Arial';\n        this.context.textAlign = 'center';\n        this.context.textBaseline = 'middle';\n\n        this.context.fillText(\n          this.getPieceText(piece),\n          startX * this.tileSize + deltaX * currentFrame + this.tileSize / 2,\n          startY * this.tileSize + deltaY * currentFrame + this.tileSize / 2,\n        );\n\n        currentFrame++;\n        requestAnimationFrame(animate);\n      } else {\n        this.drawBoard();\n      }\n    };\n\n    animate();\n  }\n\n  // Surligne les mouvements valides\n  highlightValidMoves(moves: { x: number; y: number }[]): void {\n    this.context.fillStyle = 'rgba(0, 255, 0, 0.5)';\n    moves.forEach((move) => {\n      const { x, y } = this.getCoordinates(move.x, move.y);\n      this.context.fillRect(\n        x * this.tileSize,\n        y * this.tileSize,\n        this.tileSize,\n        this.tileSize,\n      );\n    });\n  }\n\n  // Dessiner l'échiquier et les pièces\n  public drawBoard(): void {\n    const kingInCheck = this.board.getKingInCheck();\n    this.kingInCheckPosition = kingInCheck\n      ? this.getCoordinates(kingInCheck.x, kingInCheck.y)\n      : null;\n    this.drawTiles();\n    this.drawPieces();\n  }\n\n  // Dessiner les cases de l'échiquier\n  private drawTiles(): void {\n    const letters = 'abcdefgh';\n\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const { x: newX, y: newY } = this.getCoordinates(x, y);\n        const isDarkTile = (x + y) % 2 === 1;\n        let tileColor = isDarkTile ? '#769656' : '#eeeed2';\n\n        // Vérification de la position du roi en échec après conversion\n        if (\n          this.kingInCheckPosition &&\n          this.kingInCheckPosition.x === newX &&\n          this.kingInCheckPosition.y === newY\n        ) {\n          tileColor = '#ff6347';\n        }\n\n        this.context.fillStyle = tileColor;\n        this.context.fillRect(\n          newX * this.tileSize,\n          newY * this.tileSize,\n          this.tileSize,\n          this.tileSize,\n        );\n      }\n    }\n\n    // Dessiner les indicateurs a-h et 1-8\n    this.context.font = '16px Arial';\n    this.context.fillStyle = 'black';\n    for (let i = 0; i < 8; i++) {\n      // Afficher les lettres a-h en bas\n      const letterX =\n        this.getCoordinates(i, 0).x * this.tileSize + this.tileSize / 2;\n      const letterY = this.canvas.height - 5;\n      this.context.textAlign = 'center';\n      this.context.fillText(letters[i], letterX, letterY);\n\n      // Afficher les numéros 1-8 sur le côté\n      const numberX = 5;\n      const numberY =\n        this.getCoordinates(0, i).y * this.tileSize + this.tileSize / 2;\n      this.context.textBaseline = 'middle';\n      this.context.fillText(`${8 - i}`, numberX, numberY);\n    }\n  }\n\n  // Dessiner toutes les pièces sur l'échiquier\n  private drawPieces(): void {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        const piece = this.board.getPiece(x, y);\n        if (piece) {\n          const { x: newX, y: newY } = this.getCoordinates(x, y);\n          this.drawPiece(piece, newX, newY);\n        }\n      }\n    }\n  }\n\n  // Dessiner une pièce spécifique\n  private drawPiece(piece: Piece, x: number, y: number): void {\n    this.context.fillStyle = piece.color === 'white' ? 'white' : 'black';\n    this.context.font = '48px Arial';\n    this.context.textAlign = 'center';\n    this.context.textBaseline = 'middle';\n    const pieceText = this.getPieceText(piece);\n    this.context.fillText(\n      pieceText,\n      x * this.tileSize + this.tileSize / 2,\n      y * this.tileSize + this.tileSize / 2,\n    );\n  }\n\n  // Convertir le type de pièce en texte pour affichage\n  private getPieceText(piece: Piece): string {\n    switch (piece.type) {\n      case 'pawn':\n        return piece.color === 'white' ? '♙' : '♟';\n      case 'rook':\n        return piece.color === 'white' ? '♖' : '♜';\n      case 'knight':\n        return piece.color === 'white' ? '♘' : '♞';\n      case 'bishop':\n        return piece.color === 'white' ? '♗' : '♝';\n      case 'queen':\n        return piece.color === 'white' ? '♕' : '♛';\n      case 'king':\n        return piece.color === 'white' ? '♔' : '♚';\n      default:\n        return '';\n    }\n  }\n\n  // Gestion de début du glissement\n  private handleMouseDown(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    const boardX = this.flipBoard ? 7 - x : x;\n    const boardY = this.flipBoard ? 7 - y : y;\n\n    const piece = this.board.getPiece(boardX, boardY);\n    if (piece && piece.color === this.playerColor) {\n      this.draggingPiece = piece;\n      this.startX = boardX;\n      this.startY = boardY;\n      this.canvas.style.cursor = 'grabbing';\n\n      this.highlightedMoves = this.board.getValidMoves(boardX, boardY);\n      this.drawBoard();\n      this.highlightValidMoves(this.highlightedMoves);\n    } else {\n      this.draggingPiece = null;\n    }\n  }\n\n  // Gestion du mouvement pendant le glissement\n  private handleMouseMove(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const y = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    let piece = null;\n    if (this.board.isWithinBounds(x, y))\n      piece = this.board.getPiece(x, y);\n\n    this.canvas.style.cursor =\n      piece && piece.color === this.playerColor && !this.draggingPiece\n        ? 'pointer'\n        : 'default';    \n\n    if (!this.draggingPiece) return;\n\n    this.drawBoard();\n    this.highlightValidMoves(this.highlightedMoves);\n\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n\n    this.context.fillStyle =\n      this.draggingPiece.color === 'white' ? 'white' : 'black';\n    this.context.font = '48px Arial';\n    this.context.textAlign = 'center';\n    this.context.textBaseline = 'middle';\n    const pieceText = this.getPieceText(this.draggingPiece);\n    this.context.fillText(pieceText, mouseX, mouseY);\n  }\n\n  // Gestion de la fin du glissement\n  private async handleMouseUp(event: MouseEvent): Promise<void> {\n    if (!this.draggingPiece || this.startX === null || this.startY === null)\n      return;\n\n    const rect = this.canvas.getBoundingClientRect();\n    const rawX = Math.floor((event.clientX - rect.left) / this.tileSize);\n    const rawY = Math.floor((event.clientY - rect.top) / this.tileSize);\n\n    const fromX = this.startX;\n    const fromY = this.startY;\n    const toX = this.flipBoard ? 7 - rawX : rawX;\n    const toY = this.flipBoard ? 7 - rawY : rawY;\n\n    this.draggingPiece = null;\n    this.startX = null;\n    this.startY = null;\n    this.canvas.style.cursor = 'default';\n\n    await this.moveHandler(fromX, fromY, toX, toY);\n    this.highlightedMoves = [];\n\n    this.drawBoard();\n  }\n}\n","// src/timer.ts\nexport class Timer {\n  private intervalId: NodeJS.Timeout | null = null;\n  private currentTime: number;\n  private readonly onTimeUpdate: (timeLeft: number) => void;\n  public isRunning: boolean = false;\n\n  constructor(initialTime: number, onTimeUpdate: (timeLeft: number) => void) {\n    this.currentTime = Math.max(0, initialTime);\n    this.onTimeUpdate = onTimeUpdate;\n  }\n\n  // Démarrer le compte à rebours\n  public start(): void {\n    if (this.isRunning) return;\n\n    this.isRunning = true;\n    this.intervalId = setInterval(() => {\n      this.currentTime = Math.max(this.currentTime - 1, 0);\n      this.onTimeUpdate(this.currentTime);\n\n      if (this.currentTime <= 0) {\n        this.currentTime = 0;\n        this.stop();\n        // Appel de la fonction onTimeUpdate une dernière fois pour garantir l'affichage du temps écoulé\n        this.onTimeUpdate(this.currentTime);\n      }\n    }, 1000);\n  }\n\n  // Arrêter le compte à rebours\n  public stop(): void {\n    if (!this.isRunning) {\n      return;\n    }\n\n    if (this.intervalId !== null) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    this.isRunning = false;\n  }\n\n  // Réinitialiser le temps\n  public reset(time: number, startImmediately: boolean = true): void {\n    this.stop();\n    this.currentTime = Math.max(0, time);\n    this.onTimeUpdate(this.currentTime);\n    if (startImmediately) {\n      this.start();\n    }\n  }\n}\n","// src/index.ts\nimport { Game } from './game';\nimport { CanvasRenderer } from './canvas-renderer';\nimport { Timer } from './timer';\nimport { BoardInterface, PieceColor, PieceType } from './piece';\nimport {\n  getPieceSymbol,\n  showMessage,\n  updateCapturedPieces,\n} from './utils/utils';\n\n// Fonction asynchrone pour initialiser le jeu\nexport async function initializeGame(playerColor: PieceColor) {\n  let moveHistory: {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n    pieceType: PieceType;\n  }[][] = [[]];\n  const game = new Game(playerColor);\n  const board = await game.getBoard();\n\n  board.flipBoard = false;\n\n  const whiteMovesElement = document.getElementById(\n    'whiteMoves',\n  ) as HTMLUListElement;\n  const blackMovesElement = document.getElementById(\n    'blackMoves',\n  ) as HTMLUListElement;\n  const currentTurnElement = document.getElementById(\n    'currentTurn',\n  ) as HTMLDivElement;\n  const timerElement = document.getElementById('timer') as HTMLDivElement;\n  const passTurnButton = document.getElementById(\n    'passTurnButton',\n  ) as HTMLButtonElement;\n  const gameMessageElement = document.getElementById(\n    'gameMessage',\n  ) as HTMLDivElement;\n  const replayButton = document.getElementById(\n    'replayButton',\n  ) as HTMLDivElement;\n\n  let currentPlayer: PieceColor = PieceColor.WHITE;\n  let gameState: 'playing' | 'waiting' = 'playing';\n  let hasMoved = false;\n  let isGameEnded = false;\n  let isAITurn = false;\n\n  let whiteTimer = new Timer(60, (timeLeft) =>\n    updateTimerDisplay(timeLeft, PieceColor.WHITE),\n  );\n  let blackTimer = new Timer(60, (timeLeft) =>\n    updateTimerDisplay(timeLeft, PieceColor.BLACK),\n  );\n\n  function updateTimerDisplay(timeLeft: number, color: PieceColor) {\n    if (color === currentPlayer) {\n      timerElement.textContent = `Temps restant: ${timeLeft}s`;\n      if (timeLeft <= 0 && !isGameEnded) {\n        endGame(\n          `${currentPlayer === PieceColor.WHITE ? 'Noir' : 'Blanc'} gagne par temps écoulé !`,\n        );\n      }\n    }\n  }\n\n  board.flipBoard = false;\n\n  const renderer = new CanvasRenderer(\n    board,\n    'chessBoard',\n    async (fromX, fromY, toX, toY) => await handleMove(fromX, fromY, toX, toY),\n    playerColor\n  );\n  renderer.drawBoard();\n\n  // Ajuste le début de la partie selon la couleur sélectionnée par le joueur\n  if (playerColor === PieceColor.WHITE) {\n    whiteTimer.start();\n  } else {\n    blackTimer.start();\n    await triggerAIMove(); // L'IA commence si le joueur choisit Noir\n  }\n\n  function endGame(message: string) {\n    showMessage(message);\n    isGameEnded = true;\n    replayButton.style.display = 'block';\n    if (whiteTimer.isRunning) whiteTimer.stop();\n    if (blackTimer.isRunning) blackTimer.stop();\n  }\n\n  function clearMessage() {\n    gameMessageElement.textContent = '';\n    gameMessageElement.style.display = 'none';\n  }\n\n  function showPromotionDialog(x: number, y: number, board: BoardInterface) {\n    const promotionDialog = document.getElementById('promotionDialog');\n    if (promotionDialog) {\n      promotionDialog.style.display = 'block';\n\n      // Définir le callback de promotion pour gérer la sélection de pièce\n      window.promote = (pieceType: string) => {\n        board.promotePawn(x, y, pieceType); // Promouvoir le pion\n        promotionDialog.style.display = 'none'; // Masquer la boîte de dialogue\n\n        // Met à jour l'affichage de l'historique et du plateau après la promotion\n        addMoveToHistory(\n          x,\n          y,\n          x,\n          y,\n          PieceType[pieceType.toUpperCase() as keyof typeof PieceType],\n        );\n        renderer.drawBoard();\n        updateTurn();\n      };\n    }\n  }\n\n  async function updateTurn() {\n    clearMessage();\n    currentPlayer =\n      currentPlayer === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;\n    currentTurnElement.textContent = `Tour actuel: ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`;\n    hasMoved = false;\n\n    passTurnButton.disabled = currentPlayer !== playerColor;\n\n    if (currentPlayer === PieceColor.WHITE) {\n      if (blackTimer.isRunning) blackTimer.stop();\n      whiteTimer.reset(60);\n    } else {\n      if (whiteTimer.isRunning) whiteTimer.stop();\n      blackTimer.reset(60);\n    }\n\n    // Vérification de l'état de la partie avant de passer le tour\n    if (board.isKingInCheck(currentPlayer)) {\n      if (board.isCheckmate(currentPlayer)) {\n        endGame(\n          `${currentPlayer === PieceColor.WHITE ? 'Noir' : 'Blanc'} gagne par échec et mat !`,\n        );\n        return;\n      }\n    } else if (board.isStalemate(currentPlayer)) {\n      endGame('Pat ! La partie est nulle.');\n      return;\n    } else if (board.isInsufficientMaterial()) {\n      endGame('Matériel insuffisant pour continuer, partie nulle !');\n      return;\n    } else if (board.isFiftyMoveRule()) {\n      endGame('Règle des 50 coups, partie nulle !');\n      return;\n    }\n\n    moveHistory.push([]);\n\n    if (currentPlayer !== playerColor) {\n      await triggerAIMove();\n    }\n  }\n\n  async function triggerAIMove() {\n    isAITurn = true;\n    await game.makeAIMove();\n\n    // Obtenez le dernier mouvement effectué par l'IA à partir du plateau\n    const lastMove = game.getLastAIMove(); // Assurez-vous d'avoir une méthode pour récupérer ce mouvement\n\n    if (lastMove) {\n      // Ajoute le mouvement de l'IA dans l'historique\n      addMoveToHistory(\n        lastMove.fromX,\n        lastMove.fromY,\n        lastMove.toX,\n        lastMove.toY,\n        board.getPiece(lastMove.toX, lastMove.toY)?.type || PieceType.PAWN,\n      );\n    }\n\n    renderer.drawBoard();\n    isAITurn = false;\n    await updateTurn();\n  }\n\n  function addMoveToHistory(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n    pieceType: PieceType,\n  ) {\n    const letters = 'abcdefgh';\n    const moveText = `${getPieceSymbol(pieceType, currentPlayer)} de (${letters[fromX]}${8 - fromY}) à (${letters[toX]}${8 - toY})`;\n    const listItem = document.createElement('li');\n    listItem.textContent = moveText;\n\n    // Ajoute le mouvement dans la liste appropriée selon la couleur\n    if (currentPlayer === PieceColor.WHITE && whiteMovesElement) {\n      whiteMovesElement.appendChild(listItem);\n    } else if (currentPlayer === PieceColor.BLACK && blackMovesElement) {\n      blackMovesElement.appendChild(listItem);\n    }\n\n    moveHistory[moveHistory.length - 1].push({\n      fromX,\n      fromY,\n      toX,\n      toY,\n      pieceType,\n    });\n  }\n\n  async function handleMove(\n    fromX: number,\n    fromY: number,\n    toX: number,\n    toY: number,\n  ): Promise<boolean> {\n    if (gameState === 'waiting' || hasMoved || isGameEnded) {\n      showMessage('Veuillez attendre le prochain tour !');\n      return false;\n    }\n\n    const piece = board.getPiece(fromX, fromY);\n\n    if (!piece) {\n      return false;\n    }\n\n    if (piece.color !== playerColor) {\n      return false; // tu n'as pas cliqué sur une de tes pièces\n    }\n\n    if (currentPlayer !== playerColor) {\n      if (!isAITurn) {\n        showMessage(\n          `C'est le tour de ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`,\n        );\n      }\n      return false;\n    }    \n\n    const isValid = piece.isValidMove(fromX, fromY, toX, toY, board);\n    if (!isValid) {\n      showMessage('Mouvement invalide !');\n      return false;\n    }\n\n    const moved = board.movePiece(fromX, fromY, toX, toY, false);\n    if (!moved) {\n      showMessage('Mouvement impossible !');\n      return false;\n    }\n\n    hasMoved = true;\n    piece.hasMoved = true;\n\n    const targetPiece = board.getPiece(toX, toY);\n    if (targetPiece && targetPiece !== piece) {\n      updateCapturedPieces(targetPiece.type, targetPiece.color);\n    }\n\n    if (piece.type === PieceType.PAWN && (toY === 0 || toY === 7)) {\n      showPromotionDialog(toX, toY, board);\n      await updateTurn();\n    } else {\n      addMoveToHistory(fromX, fromY, toX, toY, piece.type);\n      renderer.animateMove(fromX, fromY, toX, toY, piece);\n      await updateTurn();\n    }\n\n    return true;\n  }\n\n  if (passTurnButton) {\n    passTurnButton.addEventListener('click', async (event) => {\n      event.preventDefault();\n      if (\n        gameState === 'playing' &&\n        currentPlayer === playerColor &&\n        !board.isKingInCheck(playerColor)\n      ) {\n        showMessage(\n          `Tour passé pour ${currentPlayer === PieceColor.WHITE ? 'Blanc' : 'Noir'}`,\n        );\n        await updateTurn();\n      }\n    });\n  }\n\n  if (replayButton) {\n    replayButton.addEventListener('click', () => {\n      location.reload();\n    });\n  }\n}\n\n// Export pour permettre à index.html d'appeler initializeGame avec la couleur choisie\n(window as any).startGame = (playerColor: PieceColor) =>\n  initializeGame(playerColor);\n"],"file":"assets/index-BxkcdxSC.js"}