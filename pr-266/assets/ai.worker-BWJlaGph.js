async function g(u,e){switch(u){case c.PAWN:const{Pawn:t}=await Promise.resolve().then(function(){return $});return new t(e);case c.ROOK:const{Rook:s}=await import("./rook-AeLkla-b.js");return new s(e);case c.KNIGHT:const{Knight:i}=await import("./knight-BX4fgOOq.js");return new i(e);case c.BISHOP:const{Bishop:n}=await import("./bishop-CRNsG5su.js");return new n(e);case c.QUEEN:const{Queen:o}=await import("./queen-Bum2ubYC.js");return new o(e);case c.KING:const{King:l}=await import("./king-BvA_Qjkp.js");return new l(e);default:throw new Error(`Type de pièce inconnu : ${u}`)}}var f=(u=>(u.WHITE="white",u.BLACK="black",u))(f||{}),c=(u=>(u.PAWN="pawn",u.ROOK="rook",u.KNIGHT="knight",u.BISHOP="bishop",u.QUEEN="queen",u.KING="king",u))(c||{});class E{constructor(e,t){this.color=e,this.type=t}hasMoved=!1;isPathClear(e,t,s,i,n){const o=Math.sign(s-e),l=Math.sign(i-t);let r=e+o,a=t+l;for(;r!==s||a!==i;){if(n.getPiece(r,a)!==null)return!1;r+=o,a+=l}return!0}static isKing(e){return e.type==="king"}canCapture(e,t,s){const i=s.getPiece(e,t);return!i||i.color!==this.color}toData(){return{color:this.color,type:this.type}}static async fromData(e){return await g(e.type,e.color)}isThreatenedMove(e,t,s,i){const n=Math.abs(s-e),o=Math.abs(i-t);return n<=1&&o<=1}}let X=[],Y=[];function B(u,e){switch(u){case c.PAWN:return e===f.WHITE?"♙":"♟";case c.ROOK:return e===f.WHITE?"♖":"♜";case c.KNIGHT:return e===f.WHITE?"♘":"♞";case c.BISHOP:return e===f.WHITE?"♗":"♝";case c.QUEEN:return e===f.WHITE?"♕":"♛";case c.KING:return e===f.WHITE?"♔":"♚";default:return""}}function T(u,e){const t=B(u,e);e===f.WHITE?X.push(t):Y.push(t),C()}function C(){const u=document.getElementById("capturedWhite"),e=document.getElementById("capturedBlack");u&&(u.textContent=X.join(" ")),e&&(e.textContent=Y.join(" "))}class y{grid;enPassantTarget=null;halfMoveCount=0;currentPlayer=f.WHITE;flipBoard=!1;constructor(){this.grid=Array(8).fill(null).map(()=>Array(8).fill(null))}async init(){this.grid=await this.initializeBoard()}setFlipBoard(e){this.flipBoard=e}async initializeBoard(){const e=Array(8).fill(null).map(()=>Array(8).fill(null));return e[0]=[await g(c.ROOK,f.BLACK),await g(c.KNIGHT,f.BLACK),await g(c.BISHOP,f.BLACK),await g(c.QUEEN,f.BLACK),await g(c.KING,f.BLACK),await g(c.BISHOP,f.BLACK),await g(c.KNIGHT,f.BLACK),await g(c.ROOK,f.BLACK)],e[1]=await Promise.all(Array(8).fill(null).map(()=>g(c.PAWN,f.BLACK))),e[7]=[await g(c.ROOK,f.WHITE),await g(c.KNIGHT,f.WHITE),await g(c.BISHOP,f.WHITE),await g(c.QUEEN,f.WHITE),await g(c.KING,f.WHITE),await g(c.BISHOP,f.WHITE),await g(c.KNIGHT,f.WHITE),await g(c.ROOK,f.WHITE)],e[6]=await Promise.all(Array(8).fill(null).map(()=>g(c.PAWN,f.WHITE))),e}isWithinBounds(e,t){return e>=0&&e<8&&t>=0&&t<8}getPiece(e,t){return this.grid[t][e]}getValidMoves(e,t){let s=null;if(this.isWithinBounds(e,t)&&(s=this.getPiece(e,t)),!s)return[];const i=[];for(let n=0;n<8;n++)for(let o=0;o<8;o++)s.isValidMove(e,t,o,n,this)&&i.push({x:o,y:n});return i}captureEnPassantIfValid(e,t,s,i){if(this.isEnPassantMove(e,t,s,i)){const n=this.getPiece(e,t);if(!n)return;const o=i+(n.color===f.WHITE?-1:1);this.grid[o][s]&&(this.grid[o][s]=null)}}getKingInCheck(){return this.isKingInCheck(f.WHITE)?this.findKing(f.WHITE):this.isKingInCheck(f.BLACK)?this.findKing(f.BLACK):null}movePiece(e,t,s,i,n=!0){if(!this.isWithinBounds(e,t)||!this.isWithinBounds(s,i)||["__proto__","constructor","prototype"].includes(t.toString())||["__proto__","constructor","prototype"].includes(i.toString()))return!1;const o=this.getPiece(e,t);if(o&&o.isValidMove(e,t,s,i,this)){const l=this.getPiece(s,i);if(l&&l.type===c.KING)return!1;if(o.type===c.KING&&Math.abs(s-e)===2)return this.isCastlingValid(o,e,t,s)?(this.handleCastling(s,t),o.hasMoved=!0,!0):!1;if(o?.type===c.PAWN&&this.isEnPassantMove(e,t,s,i)&&this.captureEnPassant(e,t,s,i),this.grid[i][s]=o,this.grid[t][e]=null,n||(o.hasMoved=!0),this.isKingInCheck(o.color))return this.grid[t][e]=o,this.grid[i][s]=l,!1;(o.type===c.KING||o.type===c.ROOK)&&(o.hasMoved=!0),this.updateEnPassantTarget(e,t,s,i,o),this.halfMoveCount=o.type===c.PAWN||l?0:this.halfMoveCount+1;const r=o.color===f.WHITE?f.BLACK:f.WHITE;return this.isCheckmate(r),!0}return!1}isCastlingValid(e,t,s,i){const n=i>t?1:-1,o=i>t?7:0,l=this.getPiece(o,s);if(l?.type!==c.ROOK||l.hasMoved||e.hasMoved)return!1;for(let r=t+n;r!==i+n;r+=n)if(this.getPiece(r,s)||this.isSquareUnderAttack(r,s,e.color))return!1;return!0}handleCastling(e,t){if(e===6){const s=this.getPiece(7,t),i=this.getPiece(4,t);s?.type===c.ROOK&&!s.hasMoved&&i?.type===c.KING&&!i.hasMoved&&(this.setPiece(5,t,s),this.setPiece(7,t,null),this.setPiece(6,t,i),this.setPiece(4,t,null),i.hasMoved=!0,s.hasMoved=!0)}else if(e===2){const s=this.getPiece(0,t),i=this.getPiece(4,t);s?.type===c.ROOK&&!s.hasMoved&&i?.type===c.KING&&!i.hasMoved&&(this.setPiece(3,t,s),this.setPiece(0,t,null),this.setPiece(2,t,i),this.setPiece(4,t,null),i.hasMoved=!0,s.hasMoved=!0)}}updateEnPassantTarget(e,t,s,i,n){n?.type===c.PAWN&&Math.abs(i-t)===2&&e===s?this.enPassantTarget={x:s,y:(t+i)/2}:this.enPassantTarget=null}captureEnPassant(e,t,s,i){const n=this.getPiece(e,t);if(this.isEnPassantMove(e,t,s,i)&&n?.type===c.PAWN){const o=n.color===f.WHITE?-1:1,l=i+o,r=this.getPiece(s,l);if(r&&r.type===c.PAWN){this.grid[l][s]=null;const a={capturedWhite:[],capturedBlack:[]};return r.color===f.WHITE?a.capturedWhite.push(r.type):a.capturedBlack.push(r.type),T(r.type,r.color),a}}return null}isEnPassantMove(e,t,s,i){return this.enPassantTarget?this.getPiece(e,t)?.type===c.PAWN&&s===this.enPassantTarget.x&&i===this.enPassantTarget.y&&Math.abs(e-s)===1&&Math.abs(t-i)===1:!1}async promotePawn(e,t,s){const i=this.getPiece(e,t)?.color;if(i)switch(s){case"queen":this.grid[t][e]=await g(c.QUEEN,i);break;case"rook":this.grid[t][e]=await g(c.ROOK,i);break;case"bishop":this.grid[t][e]=await g(c.BISHOP,i);break;case"knight":this.grid[t][e]=await g(c.KNIGHT,i);break}}isKingInCheck(e){const t=this.findKing(e);if(!t)return!1;for(let s=0;s<8;s++)for(let i=0;i<8;i++){const n=this.getPiece(i,s);if(n&&n.color!==e&&n.isValidMove(i,s,t.x,t.y,this))return!0}return!1}isCheckmate(e){if(!this.isKingInCheck(e))return!1;for(let s=0;s<8;s++)for(let i=0;i<8;i++){const n=this.getPiece(i,s);if(n&&n.color===e){const o=this.getValidMoves(i,s);for(const l of o){const r=this.getPiece(l.x,l.y);this.grid[l.y][l.x]=n,this.grid[s][i]=null;const a=!this.isKingInCheck(e);if(this.grid[s][i]=n,this.grid[l.y][l.x]=r,a)return!1}}}return!0}isStalemate(e){if(this.isKingInCheck(e))return!1;for(let t=0;t<8;t++)for(let s=0;s<8;s++){const i=this.getPiece(s,t);if(i&&i.color===e){for(let n=0;n<8;n++)for(let o=0;o<8;o++)if(i.isValidMove(s,t,o,n,this)){const l=this.getPiece(o,n);this.grid[n][o]=i,this.grid[t][s]=null;const r=!this.isKingInCheck(e);if(this.grid[t][s]=i,this.grid[n][o]=l,r)return!1}}}return!0}findKing(e){for(let t=0;t<8;t++)for(let s=0;s<8;s++){const i=this.getPiece(s,t);if(i&&i?.type===c.KING&&i.color===e)return{x:s,y:t}}return null}isKing(e,t){return this.getPiece(e,t)?.type===c.KING}isSquareUnderAttack(e,t,s){for(let i=0;i<8;i++)for(let n=0;n<8;n++){const o=this.getPiece(n,i);if(o&&o.color!==s){if(o.type===c.KING){if(o.isThreatenedMove(n,i,e,t))return!0}else if(o.isValidMove(n,i,e,t,this))return!0}}return!1}isInsufficientMaterial(){const e=this.grid.flat().filter(t=>t!==null);return e.length<=2?!0:e.length===3&&e.some(t=>t?.type===c.BISHOP||t?.type===c.KNIGHT)}isFiftyMoveRule(){return this.halfMoveCount>=50}setPiece(e,t,s){this.grid[t][e]=s}isMoveValid(e,t,s,i){const n=this.getPiece(e,t);if(!n||s<0||s>=8||i<0||i>=8||!n.isValidMove(e,t,s,i,this))return!1;const o=this.getPiece(s,i);return!(o&&o.color===n.color)}isCapture(e,t,s,i){const n=this.isWithinBounds(e,t)?this.getPiece(e,t):null,o=this.isWithinBounds(s,i)?this.getPiece(s,i):null;return n!==null&&o!==null&&n.color!==o.color}static async fromData(e){const t=new y;return await t.init(),t.grid=await Promise.all(e.grid.map(async s=>Promise.all(s.map(async i=>i?await E.fromData(i):null)))),t}toData(){return{grid:this.grid.map(e=>e.map(t=>t?t.toData():null))}}isAdjacentToAnotherKing(e,t,s){const i=[{dx:-1,dy:-1},{dx:-1,dy:0},{dx:-1,dy:1},{dx:0,dy:-1},{dx:0,dy:1},{dx:1,dy:-1},{dx:1,dy:0},{dx:1,dy:1}];for(const{dx:n,dy:o}of i){const l=e+n,r=t+o,a=this.isWithinBounds(l,r)?this.getPiece(l,r):null;if(a?.type===c.KING&&a.color!==s)return!0}return!1}getPieceCount(){return this.grid.flat().filter(e=>e!==null).length}setPlayerColor(e){this.currentPlayer=e}getPlayerColor(){return this.currentPlayer}getCurrentMovesHash(){let e="";for(let t=0;t<8;t++){let s=0;for(let i=0;i<8;i++){const n=this.getPiece(i,t);if(n){s>0&&(e+=s.toString(),s=0);const o=this.getPieceSymbol(n);e+=o}else s++}s>0&&(e+=s.toString()),t<7&&(e+="/")}return e+=` ${this.currentPlayer===f.WHITE?"w":"b"}`,e}getPieceSymbol(e){const t={[c.PAWN]:"p",[c.ROOK]:"r",[c.KNIGHT]:"n",[c.BISHOP]:"b",[c.QUEEN]:"q",[c.KING]:"k"};return e.color===f.WHITE?t[e.type].toUpperCase():t[e.type]}toString(){let e="";for(let t=0;t<8;t++)for(let s=0;s<8;s++){const i=this.getPiece(s,t);i?e+=`${i.color[0]}${i.type[0]}`:e+="__"}return e+=this.enPassantTarget?`e${this.enPassantTarget.x}${this.enPassantTarget.y}`:"e--",e+=`h${this.halfMoveCount}`,e+=`p${this.currentPlayer[0]}`,e}}const N={[c.PAWN]:1,[c.KNIGHT]:3,[c.BISHOP]:3.25,[c.ROOK]:5,[c.QUEEN]:9,[c.KING]:0},A={[c.PAWN]:[[0,0,0,0,0,0,0,0],[.5,.5,.5,.5,.5,.5,.5,.5],[.1,.1,.2,.3,.3,.2,.1,.1],[.05,.05,.1,.25,.25,.1,.05,.05],[0,0,0,.2,.2,0,0,0],[.05,-.05,-.1,0,0,-.1,-.05,.05],[.05,.1,.1,-.2,-.2,.1,.1,.05],[0,0,0,0,0,0,0,0]],[c.KNIGHT]:[[-.5,-.4,-.3,-.3,-.3,-.3,-.4,-.5],[-.4,-.2,0,0,0,0,-.2,-.4],[-.3,0,.1,.15,.15,.1,0,-.3],[-.3,.05,.15,.2,.2,.15,.05,-.3],[-.3,0,.15,.2,.2,.15,0,-.3],[-.3,.05,.1,.15,.15,.1,.05,-.3],[-.4,-.2,0,.05,.05,0,-.2,-.4],[-.5,-.4,-.3,-.3,-.3,-.3,-.4,-.5]],[c.BISHOP]:[[-.2,-.1,-.1,-.1,-.1,-.1,-.1,-.2],[-.1,0,0,0,0,0,0,-.1],[-.1,0,.05,.1,.1,.05,0,-.1],[-.1,.05,.05,.1,.1,.05,.05,-.1],[-.1,0,.1,.1,.1,.1,0,-.1],[-.1,.1,.1,.1,.1,.1,.1,-.1],[-.1,.05,0,0,0,0,.05,-.1],[-.2,-.1,-.1,-.1,-.1,-.1,-.1,-.2]],[c.ROOK]:[[0,0,0,0,0,0,0,0],[.05,.1,.1,.1,.1,.1,.1,.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[-.05,0,0,0,0,0,0,-.05],[0,0,0,.05,.05,0,0,0]],[c.QUEEN]:[[-.2,-.1,-.1,-.05,-.05,-.1,-.1,-.2],[-.1,0,0,0,0,0,0,-.1],[-.1,0,.05,.05,.05,.05,0,-.1],[-.05,0,.05,.05,.05,.05,0,-.05],[0,0,.05,.05,.05,.05,0,-.05],[-.1,.05,.05,.05,.05,.05,0,-.1],[-.1,0,.05,0,0,0,0,-.1],[-.2,-.1,-.1,-.05,-.05,-.1,-.1,-.2]],[c.KING]:[[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.3,-.4,-.4,-.5,-.5,-.4,-.4,-.3],[-.2,-.3,-.3,-.4,-.4,-.3,-.3,-.2],[-.1,-.2,-.2,-.2,-.2,-.2,-.2,-.1],[.2,.2,0,0,0,0,.2,.2],[.2,.3,0,0,0,0,.3,.2]]},H={"3,3":.5,"3,4":.5,"4,3":.5,"4,4":.5,"2,3":.25,"2,4":.25,"3,2":.25,"4,2":.25,"4,5":.25,"3,5":.25,"5,3":.25,"5,4":.25};function S(u,e){const t=u.findKing(e);return t&&u.isSquareUnderAttack(t.x,t.y,e)?-.5:0}function R(u,e,t,s,i,n){const o=A[u];return o?u===c.PAWN&&k(i,e,t,n)>0?0:s?o[7-t][7-e]:o[t][e]:0}function K(u,e,t=!1){let s=0;for(let i=0;i<8;i++)for(let n=0;n<8;n++){const o=u.getPiece(n,i);if(!o)continue;let l=N[o.type];if(l+=R(o.type,n,i,t,u,o.color),o.type===c.PAWN){l+=q(u,n,i,o.color),l+=x(u,n,i,o.color),l+=G(u,n,i,o.color);const r=H[`${n},${i}`];r&&k(u,n,i,o.color)===0&&(l+=r)}l+=O(u,n,i,o.color),o.type===c.KING&&(l+=D(u,n,i,o.color)),s+=o.color===e?l:-l}return parseFloat(s.toFixed(2))}function O(u,e,t,s){const i=u.findKing(s===f.WHITE?f.BLACK:f.WHITE);if(!i)return 0;const n=Math.abs(i.x-e),o=Math.abs(i.y-t);let l=n<=1&&o<=1||n===0&&o<=2?.5:0;const r=u.getPiece(e,t);return r&&N[r.type]>3&&(e===3||e===4||t===3||t===4)&&(l+=.25),l}function D(u,e,t,s){const i=[[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,1],[-1,1],[1,-1]];let n=0;for(const[o,l]of i){const r=e+o,a=t+l;if(!u.isWithinBounds(r,a))continue;const h=u.getPiece(r,a);if(h&&h.color!==s&&(h.type===c.ROOK||h.type===c.QUEEN)){const P=Math.abs(r-e)+Math.abs(a-t);n-=.5/P}}return n}function G(u,e,t,s){const i=e>0&&u.getPiece(e-1,t),n=e<7&&u.getPiece(e+1,t);return i&&i.color===s&&i.type===c.PAWN||n&&n.color===s&&n.type===c.PAWN?.3:0}function x(u,e,t,s){const i=s===f.WHITE?-1:1;let n=!1;const o=e-1,l=e+1,r=t+i;if(u.isWithinBounds(o,r)){const a=u.getPiece(o,r);a&&a.color===s&&a.type===c.PAWN&&(n=!0)}if(u.isWithinBounds(l,r)){const a=u.getPiece(l,r);a&&a.color===s&&a.type===c.PAWN&&(n=!0)}return n?.5:0}function q(u,e,t,s){const i=Q(u,e,t,s)?4.5:0,n=V(u,e,t,s)*.25,o=k(u,e,t,s)*4;return i-n-o}function V(u,e,t,s){for(let i=0;i<8;i++)if(i!==t&&u.getPiece(e,i)?.type===c.PAWN&&u.getPiece(e,i)?.color===s)return .5;return 0}function k(u,e,t,s){const i=e-1>=0?u.getPiece(e-1,t):null,n=e+1<8?u.getPiece(e+1,t):null;return i&&i.type===c.PAWN&&i.color===s||n&&n.type===c.PAWN&&n.color===s?0:1.5}function Q(u,e,t,s){const i=s===f.WHITE?1:-1;for(let o=t+i;o>=0&&o<8;o+=i){const l=u.getPiece(e,o);if(l&&l.type===c.PAWN&&l.color!==s)return!1}const n=[e-1,e+1];for(const o of n)if(o>=0&&o<8)for(let l=t+i;l>=0&&l<8;l+=i){const r=u.getPiece(o,l);if(r&&r.type===c.PAWN&&r.color!==s)return!1}return!0}class j{static endgames={kqkEndgame:{moves:[{fromX:7,fromY:1,toX:6,toY:1},{fromX:6,fromY:1,toX:5,toY:1},{fromX:5,fromY:1,toX:4,toY:2},{fromX:4,fromY:2,toX:3,toY:2},{fromX:3,fromY:2,toX:2,toY:3},{fromX:2,fromY:3,toX:1,toY:3},{fromX:1,fromY:3,toX:0,toY:4}]},krkEndgame:{moves:[{fromX:7,fromY:0,toX:5,toY:0},{fromX:5,fromY:0,toX:4,toY:0},{fromX:4,fromY:0,toX:4,toY:1},{fromX:4,fromY:1,toX:4,toY:2},{fromX:4,fromY:2,toX:3,toY:2},{fromX:3,fromY:2,toX:2,toY:3}]},kpEndgame:{moves:[{fromX:6,fromY:5,toX:6,toY:6},{fromX:6,fromY:6,toX:6,toY:7}]},krkpEndgame:{moves:[{fromX:6,fromY:0,toX:6,toY:1},{fromX:6,fromY:1,toX:6,toY:2},{fromX:6,fromY:2,toX:6,toY:3}]},kqkrEndgame:{moves:[{fromX:7,fromY:2,toX:6,toY:2},{fromX:6,fromY:2,toX:5,toY:2},{fromX:5,fromY:2,toX:4,toY:3},{fromX:4,fromY:3,toX:3,toY:4}]},kbkpEndgame:{moves:[{fromX:3,fromY:3,toX:4,toY:2},{fromX:4,fromY:2,toX:5,toY:1},{fromX:5,fromY:1,toX:6,toY:0}]},krrkEndgame:{moves:[{fromX:7,fromY:4,toX:5,toY:4},{fromX:5,fromY:4,toX:4,toY:4},{fromX:4,fromY:4,toX:3,toY:4},{fromX:3,fromY:4,toX:2,toY:4}]},kbbkEndgame:{moves:[{fromX:5,fromY:3,toX:3,toY:1},{fromX:3,fromY:1,toX:2,toY:0},{fromX:2,fromY:0,toX:1,toY:1},{fromX:1,fromY:1,toX:0,toY:0}]}};static getEndgameMoves(e){return this.endgames[e]?.moves||null}static isEndgame(e){return!!this.endgames[e]}static suggestNextMove(e,t=0){const s=this.getEndgameMoves(e);return s&&t<s.length?s[t]:null}static validateEndgame(e,t){switch(e){case"kqkEndgame":return t.sort().join("")==="KkQ";case"krkEndgame":return t.sort().join("")==="KkR";case"kpEndgame":return t.sort().join("")==="KkP";case"krkpEndgame":return t.sort().join("")==="KkPR";case"kqkrEndgame":return t.sort().join("")==="KkQR";case"kbkpEndgame":return t.sort().join("")==="KkBP";case"krrkEndgame":return t.sort().join("")==="KkRR";case"kbbkEndgame":return t.sort().join("")==="KkBB";default:return!1}}}class L{static openings={"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w":[{fromX:1,fromY:7,toX:3,toY:7,weight:.6},{fromX:6,fromY:7,toX:5,toY:5,weight:.4}],"rnbqkbnr/pppppppp/8/8/8/8/PPP1PPPP/RNBQKBNR w":[{fromX:2,fromY:7,toX:4,toY:7,weight:.5},{fromX:4,fromY:6,toX:4,toY:4,weight:.5}],"rnbqkbnr/pppppp1p/8/8/8/8/PPPP1PPP/RNBQKBNR w":[{fromX:4,fromY:7,toX:4,toY:5,weight:1}],"rnbqkbnr/pppppppp/8/8/8/8/PP1PPPPP/RNBQKBNR w":[{fromX:4,fromY:7,toX:4,toY:5}],"rnbqkbnr/pppp1ppp/4p3/8/3P4/8/PPP1PPPP/RNBQKBNR b":[{fromX:1,fromY:0,toX:2,toY:2,weight:.8},{fromX:6,fromY:0,toX:5,toY:2,weight:.2}],"rnbqkbnr/pp1ppppp/2p5/8/4P3/5N2/PPPP1PPP/RNBQKB1R b":[{fromX:5,fromY:0,toX:2,toY:3,weight:1}],"rnbqk1nr/pppp1ppp/4p3/8/2B1P3/8/PPPP1PPP/RNBQK1NR b":[{fromX:6,fromY:0,toX:5,toY:2,weight:1}],"r1bqkbnr/pppppppp/2n5/8/2B1P3/5N2/PPPP1PPP/RNBQK2R b":[{fromX:7,fromY:0,toX:5,toY:0,weight:1}],"rnbqkbnr/ppp1pppp/8/3p4/4P3/5N2/PPPP1PPP/RNBQKB1R w":[{fromX:3,fromY:7,toX:3,toY:6,weight:1}]};static getOpeningMove(e){const t=this.openings[e];if(t&&t.length>0){const s=t.reduce((n,o)=>n+(o.weight??1),0);let i=Math.random()*s;for(const n of t)if(i-=n.weight??1,i<=0)return n}return null}static addOpeningMove(e,t){this.openings[e]||(this.openings[e]=[]),this.openings[e].push(t)}}class _{gamePatterns=new Map;async loadGamesData(){const t=await(await fetch("/chess-game/games.json")).json();this.loadGames(t)}loadGames(e){e.forEach(t=>{const s=t.Moves,i=t.Result;let n="";s.forEach(o=>{this.gamePatterns.has(n)||this.gamePatterns.set(n,[]);const l=this.gamePatterns.get(n),r=i==="1-0"?1:i==="0-1"?0:.5,a=l.find(h=>h.move===o);a?(a.successRate=(a.successRate*a.games+r)/(a.games+1),a.games+=1):l.push({move:o,successRate:r,games:1}),n+=o+" "})})}getBestMove(e){const t=this.gamePatterns.get(e);return!t||t.length===0?null:(t.sort((s,i)=>i.successRate-s.successRate),t[0].move)}}class z{moveData=new Map;maxMovesStored=1e3;recordMove(e,t){const s=this.normalizeKey(e),i=this.moveData.get(s)||[],n=i.find(o=>o.move.fromX===t.fromX&&o.move.fromY===t.fromY&&o.move.toX===t.toX&&o.move.toY===t.toY);n?(n.count++,n.lastUsed=Date.now()):i.push({move:t,count:1,lastUsed:Date.now()}),i.sort((o,l)=>l.count-o.count),i.length>this.maxMovesStored&&i.pop(),this.moveData.set(s,i)}getMovesByFrequency(e){return this.moveData.get(this.normalizeKey(e))||[]}normalizeKey(e){return e.replace(/\s+/g,"")}pruneOldMoves(e){const t=Date.now();for(const[s,i]of this.moveData.entries()){const n=i.filter(o=>t-o.lastUsed<e);n.length>0?this.moveData.set(s,n):this.moveData.delete(s)}}}class U{constructor(e,t=3e4){this.color=e,this.maxTime=t}killerMoves=new Map;moveHistory=[];gamesAnalyzer=new _;contextualDatabase=new z;gamesLoaded=!1;startTime=0;invalidMoves=new Set;async loadGamesData(){await this.gamesAnalyzer.loadGamesData(),this.gamesLoaded=!0}makeMove(e){if(!this.gamesLoaded)throw new Error("Games data not loaded.");this.startTime=Date.now();const t=L.getOpeningMove(e.getCurrentMovesHash());if(t)return this.finalizeMove(t,e);const s=this.getEndgameMove(e);if(s)return this.finalizeMove(s,e);const i=this.getAnalyzedMove(e);if(i)return this.finalizeMove(i,e);const n=this.iterativeDeepening(e);return n?this.getAllValidMoves(e).some(r=>r.fromX===n.fromX&&r.fromY===n.fromY&&r.toX===n.toX&&r.toY===n.toY)?this.finalizeMove(n,e):(console.warn("⚠️ Coup illégal détecté juste avant exécution."),null):null}finalizeMove(e,t){return this.moveHistory.push(e),this.contextualDatabase.recordMove(t.getCurrentMovesHash(),e),e}getEndgameMove(e){if(e.getPieceCount()<=5){const t=j.getEndgameMoves(e.getCurrentMovesHash());return t?t[0]:null}return null}getAnalyzedMove(e){const t=this.gamesAnalyzer.getBestMove(e.getCurrentMovesHash());return t?this.convertMove(t):null}convertMove(e){const[t,s,i,n]=e.match(/\d+/g).map(Number);return{fromX:t,fromY:s,toX:i,toY:n}}addInvalidMove(e){this.invalidMoves.add(`${e.fromX}${e.fromY}${e.toX}${e.toY}`)}isMoveInvalid(e){return this.invalidMoves.has(`${e.fromX}${e.fromY}${e.toX}${e.toY}`)}iterativeDeepening(e){let t=null,s=-1/0;const i=this.startTime+this.maxTime;let n=this.getAllValidMoves(e);if(n.length===0)return null;const o=n.filter(r=>{const a=e.getPiece(r.toX,r.toY),h=e.getPiece(r.fromX,r.fromY);e.movePiece(r.fromX,r.fromY,r.toX,r.toY);const P=!e.isKingInCheck(this.color);return e.setPiece(r.fromX,r.fromY,h),e.setPiece(r.toX,r.toY,a),P});o.length>0&&(n=o);const l=n.length>25?2:4;n=n.map(r=>{const a=e.getPiece(r.toX,r.toY),h=e.getPiece(r.fromX,r.fromY);e.movePiece(r.fromX,r.fromY,r.toX,r.toY);const P=K(e,this.color);return e.setPiece(r.fromX,r.fromY,h),e.setPiece(r.toX,r.toY,a),{...r,weight:P}}).sort((r,a)=>(a.weight??0)-(r.weight??0));for(let r=1;r<=l&&!(Date.now()>i);r++)for(const a of n){if(Date.now()>i)return t;const h=e.getPiece(a.toX,a.toY),P=e.getPiece(a.fromX,a.fromY);e.movePiece(a.fromX,a.fromY,a.toX,a.toY);const m=-this.minimax(e,r-1,-1/0,1/0,!1);if(e.setPiece(a.fromX,a.fromY,P),e.setPiece(a.toX,a.toY,h),m>s&&(s=m,t=a),s>=1e4)return t}return t}minimax(e,t,s,i,n){const o=Date.now();if(t===0||o-this.startTime>=this.maxTime)return K(e,this.color)+S(e,this.color);const l=this.getAllValidMoves(e);if(l.length===0)return-9999;let r;if(n){r=-1/0;for(const a of l){if(Date.now()-this.startTime>=this.maxTime)break;const h=e.getPiece(a.toX,a.toY),P=e.getPiece(a.fromX,a.fromY);e.movePiece(a.fromX,a.fromY,a.toX,a.toY);const m=-this.minimax(e,t-1,-i,-s,!1);if(e.setPiece(a.fromX,a.fromY,P),e.setPiece(a.toX,a.toY,h),r=Math.max(r,m),s=Math.max(s,r),s>=i){this.killerMoves.set(t,(this.killerMoves.get(t)||[]).slice(0,1).concat(a));break}}}else{r=1/0;for(const a of l){if(Date.now()-this.startTime>=this.maxTime)break;const h=e.getPiece(a.toX,a.toY),P=e.getPiece(a.fromX,a.fromY);e.movePiece(a.fromX,a.fromY,a.toX,a.toY);const m=-this.minimax(e,t-1,-i,-s,!0);if(e.setPiece(a.fromX,a.fromY,P),e.setPiece(a.toX,a.toY,h),r=Math.min(r,m),i=Math.min(i,r),s>=i){this.killerMoves.set(t,(this.killerMoves.get(t)||[]).slice(0,1).concat(a));break}}}return r}getAllValidMoves(e){const t=[];for(let s=0;s<8;s++)for(let i=0;i<8;i++){const n=e.getPiece(i,s);if(n&&n.color===this.color){const o=e.getValidMoves(i,s),l=e.isKingInCheck(this.color);for(const r of o){const{x:a,y:h}=r,P=e.getPiece(a,h),m=e.getPiece(i,s);e.movePiece(i,s,a,h);let d=-1,v=-1;if(m.type==="king")d=a,v=h;else{const w=e.findKing(this.color);if(!w){e.setPiece(i,s,m),e.setPiece(a,h,P);continue}d=w.x,v=w.y}const I=e.isWithinBounds(d,v)&&!e.isSquareUnderAttack(d,v,this.color);e.setPiece(i,s,m),e.setPiece(a,h,P),(!l&&I||l&&I)&&t.push({fromX:i,fromY:s,toX:a,toY:h})}}}return t}}class W extends E{hasMoved=!1;_toX=null;_toY=null;_board=null;constructor(e){super(e,c.PAWN)}isValidMove(e,t,s,i,n){if(s<0||s>=8||i<0||i>=8)return!1;const o=this.color===f.WHITE?-1:1,l=this.color===f.WHITE?6:1,r=this.color===f.WHITE?0:7,a=(i-t)*o,h=s-e;return h===0&&a===1&&!n.getPiece(s,i)?i===r?this.handlePromotion(s,i,n):!0:h===0&&a===2&&t===l&&!n.getPiece(s,i)&&!n.getPiece(e,t+o)?(n.updateEnPassantTarget(e,t,s,i,this),!0):Math.abs(h)===1&&a===1&&n.getPiece(s,i)&&this.canCapture(s,i,n)?i===r?this.handlePromotion(s,i,n):!0:Math.abs(h)===1&&a===1&&n.isEnPassantMove(e,t,s,i)?(n.captureEnPassantIfValid(e,t,s,i),!0):!1}handlePromotion(e,t,s){return this._toX=e,this._toY=t,this._board=s,!0}}var $=Object.freeze({__proto__:null,Pawn:W});let M,p;self.onmessage=async u=>{const{boardData:e,aiColor:t,invalidMove:s}=u.data;e&&t&&(M=new U(t),await M.loadGamesData(),p=await y.fromData(e)),s&&M.addInvalidMove(s);let i=M.makeMove(p),n=null,o=!1;if(i){if(p.isCapture(i.fromX,i.fromY,i.toX,i.toY)){const r=p.getPiece(i.toX,i.toY);r&&(n={capturedWhite:[],capturedBlack:[]},r.color===f.WHITE?n.capturedWhite.push(r.type):n.capturedBlack.push(r.type))}const l=p.getPiece(i.fromX,i.fromY);if(l instanceof W){const r=t===f.WHITE?7:0;i.toY===r&&(o=l.handlePromotion(i.toX,i.toY,p))}}self.postMessage({bestMove:i,captureData:n,promotionRequired:o})};export{E as P,c as a,g as c};
//# sourceMappingURL=ai.worker-BWJlaGph.js.map
